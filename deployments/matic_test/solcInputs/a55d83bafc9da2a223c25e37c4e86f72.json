{
  "language": "Solidity",
  "sources": {
    "contracts/Arkreen/AKREVesting.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\r\nimport \"@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol\";\r\nimport \"@openzeppelin/contracts/security/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\r\nimport \"./ConfirmedOwner.sol\";  \r\n\r\ncontract AKREVesting is ConfirmedOwner, ReentrancyGuard {\r\n    using SafeERC20 for IERC20;\r\n\r\n    struct VestingSchedule {\r\n        bool initialized;\r\n        // time of the end of the cliff period\r\n        uint256 cliffEnd;\r\n        // start time of the vesting period\r\n        uint256 start;\r\n        // duration of the vesting period in seconds\r\n        uint256 duration;\r\n        // total amount of tokens to be released at the end of the vesting\r\n        uint256 amountTotal;\r\n        // amount of tokens already released\r\n        uint256 released;\r\n        // whether or not the vesting has been revoked\r\n        bool revoked;\r\n    }\r\n\r\n    // address of the ERC20 token\r\n    IERC20 private immutable _token;\r\n\r\n    mapping(address => VestingSchedule) private vestingSchedules;\r\n    uint256 private vestingSchedulesTotalAmount;\r\n\r\n    event VestingScheduleCreated(address indexed beneficiary, uint256 amount);\r\n    event Released(address indexed beneficiary, uint256 amount);\r\n    event Revoked(address indexed beneficiary, uint256 amountUnreleased);\r\n\r\n    /// @dev Reverts if the vesting schedule does not exist or has been revoked\r\n    modifier onlyIfVestingScheduleNotRevoked(address beneficiary) {\r\n        require(\r\n            !vestingSchedules[beneficiary].revoked,\r\n            \"Vesting schedule was revoked\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @dev Creates a vesting contract\r\n    /// @param token_ address of the ERC20 token contract\r\n    constructor(address token_) {\r\n        require(token_ != address(0), \"Token cannot be zero address\");\r\n        _token = IERC20(token_);\r\n    }\r\n\r\n    /// @notice Creates a new vesting schedule for a beneficiary\r\n    /// @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n    /// @param _start start time of the vesting period\r\n    /// @param _cliff duration in seconds of the cliff in which tokens will begin to vest\r\n    /// @param _duration duration in seconds of the period in which the tokens will vest\r\n    /// @param _amount total amount of tokens to be released at the end of the vesting\r\n    function createVestingSchedule(\r\n        address _beneficiary,\r\n        uint256 _start,\r\n        uint256 _cliff,\r\n        uint256 _duration,\r\n        uint256 _amount\r\n    ) external onlyOwner {\r\n        require(!vestingSchedules[_beneficiary].initialized, \"Already initialized\");\r\n        require(_duration > 0, \"Duration must be > 0\");\r\n        require(_amount > 0, \"Amount must be > 0\");\r\n        require(_cliff <= _duration, \"Cliff must be <= duration\");\r\n        require(getWithdrawableAmount() >= _amount, \"Not sufficient tokens\");\r\n\r\n        vestingSchedules[_beneficiary] = VestingSchedule(\r\n            true,\r\n            _start + _cliff,\r\n            _start,\r\n            _duration,\r\n            _amount,\r\n            0,\r\n            false\r\n        );\r\n\r\n        vestingSchedulesTotalAmount += _amount;\r\n\r\n        emit VestingScheduleCreated(_beneficiary, _amount);\r\n    }\r\n\r\n    /// @notice Revokes the vesting schedule for given beneficiary\r\n    /// @param _beneficiary address of the beneficiary to whom vested tokens are transferred\r\n    function revoke(address _beneficiary) external onlyOwner\r\n            onlyIfVestingScheduleNotRevoked(_beneficiary)\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[_beneficiary];\r\n\r\n        vestingSchedule.initialized = false;\r\n        vestingSchedule.revoked = true;\r\n\r\n        uint256 unreleased = vestingSchedule.amountTotal - vestingSchedule.released;\r\n\r\n        if (unreleased > 0) {\r\n            vestingSchedulesTotalAmount -= unreleased;\r\n            _token.safeTransfer(owner(), unreleased);\r\n        }\r\n\r\n        emit Revoked(_beneficiary, unreleased);\r\n    }\r\n\r\n    /// @notice Release vested amount of tokens\r\n    /// @param beneficiary address of the beneficiary to whom vested tokens are transferred\r\n    /// @param amount the amount to release\r\n    function release(address beneficiary, uint256 amount) external nonReentrant\r\n            onlyIfVestingScheduleNotRevoked(beneficiary)\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[beneficiary];\r\n        require(msg.sender == beneficiary || msg.sender == owner(), \r\n                \"Only beneficiary and owner can release vested tokens\");\r\n\r\n        uint256 releasableAmount = _computeReleasableAmount(vestingSchedule);\r\n        require(releasableAmount >= amount, \"Amount is too high\");\r\n\r\n        vestingSchedule.released += amount;\r\n        vestingSchedulesTotalAmount -= amount;\r\n\r\n        _token.safeTransfer(beneficiary, amount);\r\n\r\n        emit Released(beneficiary, amount);\r\n    }\r\n\r\n    /// @notice Withdraw the specified amount if possible\r\n    /// @param amount the amount to withdraw\r\n    function withdraw(uint256 amount) external onlyOwner nonReentrant {\r\n        require(getWithdrawableAmount() >= amount, \"Not enough withdrawable funds\");\r\n        _token.safeTransfer(owner(), amount);\r\n    }\r\n\r\n    /// @notice Returns the address of the ERC20 token managed by the vesting contract\r\n    function getToken() external view returns (address) {\r\n        return address(_token);\r\n    }\r\n\r\n    /// @notice Returns the total amount of vesting schedules\r\n    function getVestingSchedulesTotalAmount() external view returns (uint256) {\r\n        return vestingSchedulesTotalAmount;\r\n    }\r\n\r\n    /// @notice Returns the vesting schedule information for a given identifier\r\n    /// @param beneficiary address of the beneficiary to whom vested tokens are transferred\r\n    /// @return vestingSchedule the vesting schedule structure information\r\n    function getVestingSchedule(address beneficiary) external view\r\n            returns (VestingSchedule memory vestingSchedule)\r\n    {\r\n        vestingSchedule = vestingSchedules[beneficiary];\r\n    }\r\n\r\n    /// @notice Computes the vested amount of tokens for the given vesting schedule identifier\r\n    /// @param beneficiary address of the beneficiary to whom vested tokens are transferred\r\n    /// @return releasableAmount the vested amount\r\n    function computeReleasableAmount(address beneficiary) external view\r\n            returns (uint256 releasableAmount)\r\n    {\r\n        VestingSchedule storage vestingSchedule = vestingSchedules[beneficiary];\r\n        releasableAmount = !vestingSchedule.revoked\r\n                           ? _computeReleasableAmount(vestingSchedule)\r\n                           : 0;\r\n    }\r\n\r\n    /// @dev Returns the amount of tokens that can be withdrawn by the owner\r\n    /// @return the amount of tokens\r\n    function getWithdrawableAmount() public view returns (uint256) {\r\n        return _token.balanceOf(address(this)) - vestingSchedulesTotalAmount;\r\n    }\r\n\r\n    /// @dev Computes the releasable amount of tokens for a vesting schedule\r\n    /// @param vestingSchedule vesting schedule struct\r\n    /// @return releasableAmount the amount of releasable tokens\r\n    function _computeReleasableAmount(VestingSchedule memory vestingSchedule) private view\r\n            returns (uint256 releasableAmount)\r\n    {\r\n        uint256 currentTime = block.timestamp;\r\n\r\n        if (currentTime >= vestingSchedule.start + vestingSchedule.duration) {\r\n            releasableAmount = vestingSchedule.amountTotal - vestingSchedule.released;\r\n        } else if (currentTime > vestingSchedule.cliffEnd) {\r\n            uint256 timeFromStart = currentTime - vestingSchedule.start;\r\n            uint256 vestedAmount = (vestingSchedule.amountTotal * timeFromStart) /\r\n                                    vestingSchedule.duration;\r\n            releasableAmount = vestedAmount - vestingSchedule.released;\r\n        }\r\n    }\r\n}"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/utils/SafeERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/utils/SafeERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20.sol\";\nimport \"../extensions/draft-IERC20Permit.sol\";\nimport \"../../../utils/Address.sol\";\n\n/**\n * @title SafeERC20\n * @dev Wrappers around ERC20 operations that throw on failure (when the token\n * contract returns false). Tokens that return no value (and instead revert or\n * throw on failure) are also supported, non-reverting calls are assumed to be\n * successful.\n * To use this library you can add a `using SafeERC20 for IERC20;` statement to your contract,\n * which allows you to call the safe operations as `token.safeTransfer(...)`, etc.\n */\nlibrary SafeERC20 {\n    using Address for address;\n\n    function safeTransfer(\n        IERC20 token,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transfer.selector, to, value));\n    }\n\n    function safeTransferFrom(\n        IERC20 token,\n        address from,\n        address to,\n        uint256 value\n    ) internal {\n        _callOptionalReturn(token, abi.encodeWithSelector(token.transferFrom.selector, from, to, value));\n    }\n\n    /**\n     * @dev Deprecated. This function has issues similar to the ones found in\n     * {IERC20-approve}, and its usage is discouraged.\n     *\n     * Whenever possible, use {safeIncreaseAllowance} and\n     * {safeDecreaseAllowance} instead.\n     */\n    function safeApprove(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        // safeApprove should only be called when setting an initial allowance,\n        // or when resetting it to zero. To increase and decrease it, use\n        // 'safeIncreaseAllowance' and 'safeDecreaseAllowance'\n        require(\n            (value == 0) || (token.allowance(address(this), spender) == 0),\n            \"SafeERC20: approve from non-zero to non-zero allowance\"\n        );\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, value));\n    }\n\n    function safeIncreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        uint256 newAllowance = token.allowance(address(this), spender) + value;\n        _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n    }\n\n    function safeDecreaseAllowance(\n        IERC20 token,\n        address spender,\n        uint256 value\n    ) internal {\n        unchecked {\n            uint256 oldAllowance = token.allowance(address(this), spender);\n            require(oldAllowance >= value, \"SafeERC20: decreased allowance below zero\");\n            uint256 newAllowance = oldAllowance - value;\n            _callOptionalReturn(token, abi.encodeWithSelector(token.approve.selector, spender, newAllowance));\n        }\n    }\n\n    function safePermit(\n        IERC20Permit token,\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal {\n        uint256 nonceBefore = token.nonces(owner);\n        token.permit(owner, spender, value, deadline, v, r, s);\n        uint256 nonceAfter = token.nonces(owner);\n        require(nonceAfter == nonceBefore + 1, \"SafeERC20: permit did not succeed\");\n    }\n\n    /**\n     * @dev Imitates a Solidity high-level call (i.e. a regular function call to a contract), relaxing the requirement\n     * on the return value: the return value is optional (but if data is returned, it must not be false).\n     * @param token The token targeted by the call.\n     * @param data The call data (encoded using abi.encode or one of its variants).\n     */\n    function _callOptionalReturn(IERC20 token, bytes memory data) private {\n        // We need to perform a low level call here, to bypass Solidity's return data size checking mechanism, since\n        // we're implementing it ourselves. We use {Address.functionCall} to perform this call, which verifies that\n        // the target address contains contract code and also asserts for success in the low-level call.\n\n        bytes memory returndata = address(token).functionCall(data, \"SafeERC20: low-level call failed\");\n        if (returndata.length > 0) {\n            // Return data is optional\n            require(abi.decode(returndata, (bool)), \"SafeERC20: ERC20 operation did not succeed\");\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/security/ReentrancyGuard.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (security/ReentrancyGuard.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant _NOT_ENTERED = 1;\n    uint256 private constant _ENTERED = 2;\n\n    uint256 private _status;\n\n    constructor() {\n        _status = _NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        // On the first call to nonReentrant, _notEntered will be true\n        require(_status != _ENTERED, \"ReentrancyGuard: reentrant call\");\n\n        // Any calls to nonReentrant after this point will fail\n        _status = _ENTERED;\n\n        _;\n\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = _NOT_ENTERED;\n    }\n}\n"
    },
    "@openzeppelin/contracts/access/Ownable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/Context.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract Ownable is Context {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    constructor() {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n}\n"
    },
    "contracts/Arkreen/ConfirmedOwner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @title The ConfirmedOwner contract\n * @notice A contract with helpers for basic contract ownership.\n * @dev derived from https://github.com/smartcontractkit/chainlink\n */\ncontract ConfirmedOwner {\n    address private _owner;\n    address private _pendingOwner;\n\n    event OwnershipTransferRequested(address indexed from, address indexed to);\n    event OwnershipTransferred(address indexed from, address indexed to);\n\n    constructor() {\n        _owner = msg.sender;\n        emit OwnershipTransferred(address(0), msg.sender);\n    }\n\n    /**\n     * @notice Reverts if called by anyone other than the contract owner.\n     */\n    modifier onlyOwner() {\n        require(msg.sender == _owner, \"Only callable by owner\");\n        _;\n    }\n\n    /**\n     * @notice Allows an owner to begin transferring ownership to a new address,\n     * pending.\n     */\n    function transferOwnership(address to) public onlyOwner {\n        require(to != msg.sender, \"Cannot transfer to self\");\n\n        _pendingOwner = to;\n\n        emit OwnershipTransferRequested(_owner, to);\n    }\n\n    /**\n     * @notice Allows an ownership transfer to be completed by the recipient.\n     */\n    function acceptOwnership() external {\n        require(msg.sender == _pendingOwner, \"Must be proposed owner\");\n\n        address oldOwner = _owner;\n        _owner = msg.sender;\n        _pendingOwner = address(0);\n\n        emit OwnershipTransferred(oldOwner, msg.sender);\n    }\n\n    /**\n     * @notice Get the current owner\n     */\n    function owner() public view returns (address) {\n        return _owner;\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/extensions/draft-IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Context.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract Context {\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n}\n"
    },
    "contracts/test/AMMV2/Governance/FeswaNFT.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/utils/math/SafeMath.sol\";\nimport \"@openzeppelin/contracts/access/Ownable.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\nimport \"@openzeppelin/contracts/token/ERC721/ERC721.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol\";\nimport \"@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol\";\n\nimport \"./utils/TransferHelper.sol\";\nimport \"./patch/NFTPatchCaller.sol\";\n\n    interface IFeSwapFactory {\n        function createUpdatePair(address tokenA, address tokenB, address pairOwner, uint256 rateTrigger, uint256 switchOracle) \n                                    external returns (address pairAAB,address pairABB);\n    }\n\n    enum PoolRunningPhase {\n        BidToStart,\n        BidPhase, \n        BidDelaying,\n        BidSettled,\n        PoolHolding, \n        PoolForSale\n    }\n\n    struct FeswaPair {\n        address tokenA;\n        address tokenB;\n        uint128 currentPrice;\n        uint48  timeCreated;\n        uint48  lastBidTime; \n        PoolRunningPhase  poolState;\n    }\n\n/**\n * @title FeswaNFT contract\n * @dev Extends ERC721 Non-Fungible Token Standard basic implementation\n */\n\ncontract FeswaNFT is ERC721, ERC721Enumerable, ERC721URIStorage, Ownable, NFTPatchCaller { \n    //    using SafeMath for uint256;\t// seems not necessary\n\n    // Public variables\n    string public constant NAME = 'FeSwap Pool NFT';\n    string public constant SYMBOL = 'FESN';\n\n    // Price offering duration: two weeks \n    uint256 public constant OPEN_BID_DURATION = (3600 * 24 * 3);\n\n    uint256 public constant RECLAIM_DURATION  = (3600 * 24 * 4);    // NFT will be reclaimed if the token pair is not created in the duration \n\n    // Price offering waiting duration: 2 Hours\n    uint256 public constant CLOSE_BID_DELAY = (3600 * 2);           \n\n    // Airdrop for the first tender: 1000 FESW\n    // uint256 public constant AIRDROP_FOR_FIRST    = 1000e18;             // BNB:      1000\n    uint256 public constant AIRDROP_FOR_FIRST       = 3000e18;             // MATIC:    3000\n    // uint256 public constant AIRDROP_FOR_FIRST    = 5000e18;             // Avalanche: 5000\n\n    // BNB = 1; MATIC = 100; Arbitrum, Rinkeby = 0.25; Avalanche=5, HT = 20, Fantom = 80, Harmony = 500\n\n    // Airdrop for the next tender: 10000 FESW/BNB\n    uint256 public constant AIRDROP_RATE_FOR_NEXT_BIDDER = 10_000 / 100;      // 10_000 / 1, BNB = 1; MATIC = 100 ; Arbitrum: 40_000\n\n    // Airdrop rate for Bid winner: 50000 FESW/BNB\n    uint256 public constant AIRDROP_RATE_FOR_WINNER = 50_000 / 100;           // 50_000 / 1; Arbitrum: 200_000\n\n    // Minimum price increase for tender: 0.02 BNB, 2 MATIC\n    uint256 public constant MINIMUM_PRICE_INCREACE = 2e16 * 100;              //  2e16 * 1; Arbitrum: 5e15\n\n    // Max price for NFT sale: 100,000 BNB/ 100M MATIC \n    uint256 public constant MAX_SALE_PRICE = 1000_000e18 * 100;               // 1000_000e18 * 1; Arbitrum: 250_000e18\n\n    // Bidding airdrop cap : 2500 BNB\n    // uint256 private constant BIDDING_AIRDROP_CAP = 2500e18;             // BNB:     2500 BNB\n    uint256 private constant BIDDING_AIRDROP_CAP    = 2800e18 * 100;       // MATIC:   280,000 MATIC\n\n    // contract of Feswap DAO Token\n    address public immutable FeswapToken;\n\n    // contract of Token Pair Factory\n    address public immutable PairFactory;\n\n    // Sale start timestamp\n    uint256 public immutable SaleStartTime;                                   //2021/09/28 08:00\n\n    uint128 public TotalBidValue;\n    uint64  public AirdropDepletionTime;\n\n    // Mapping from token ID to token pair infomation\n    mapping (uint256 => FeswaPair) public ListPools;\n \n    // Events\n    event PairCreadted(address indexed tokenA, address indexed tokenB, uint256 tokenID);\n  \n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor (address feswaToken, address pairFactory, uint256 saleStartTime ) \n        ERC721(NAME, SYMBOL)\n    {\n        FeswapToken = feswaToken;\n        PairFactory = pairFactory;\n        SaleStartTime = saleStartTime;\n    }\n\n    /**\n     * @dev Bid for the token-pair swap pool with higher price. \n     * Create the new NFT for the fisrt-time calling with initial price \n     */\n    function BidFeswaPair(address tokenA, address tokenB, address to) external payable returns (uint256 tokenID) {\n        require(block.timestamp > SaleStartTime, 'FESN: BID NOT STARTED');\n        require(tokenA != address(0) && tokenB != address(0) && to != address(0) , 'FeSwap: ZERO_ADDRESS');\n        require(tokenA != tokenB, 'FESN: IDENTICAL_ADDRESSES');\n        require(Address.isContract(tokenA) && Address.isContract(tokenB), 'FESN: Must be token');\n        require(!Address.isContract(msg.sender), 'FESN: Contract Not Allowed');\n        if(to != msg.sender) require(!Address.isContract(to), 'FESN: Contract Not Allowed');\n\n        (address token0, address token1) = (tokenA <= tokenB) ? (tokenA, tokenB) : (tokenB, tokenA);\n        tokenID  = uint256(keccak256(abi.encodePacked(address(this), token0, token1)));\n\n        uint256 airdropAmount = 0;\n\n        if(_exists(tokenID )){\n            bool isReclaimable = false;\n            address preOwner = ownerOf(tokenID);\n            FeswaPair storage pairInfo = ListPools[tokenID]; \n\n            if(pairInfo.poolState == PoolRunningPhase.BidPhase){\n                if( block.timestamp > (pairInfo.timeCreated + OPEN_BID_DURATION + RECLAIM_DURATION)) {\n                    isReclaimable = true;\n                }\n                else{\n                    require(block.timestamp <= pairInfo.timeCreated + OPEN_BID_DURATION, 'FESN: BID TOO LATE 1');  // Bid keep open for 3 days\n                    if(block.timestamp >= (pairInfo.timeCreated + OPEN_BID_DURATION - CLOSE_BID_DELAY)) {\n                        pairInfo.poolState = PoolRunningPhase.BidDelaying;\n                    }\n                }\n            } else {\n                require(pairInfo.poolState == PoolRunningPhase.BidDelaying, 'FESN: BID COMPLETED');\n                if( block.timestamp > (pairInfo.lastBidTime + CLOSE_BID_DELAY + RECLAIM_DURATION)) {\n                    isReclaimable = true;\n                }\n                else{\n                    require(block.timestamp <= pairInfo.lastBidTime + CLOSE_BID_DELAY, 'FESN: BID TOO LATE 2');\n                }\n            }\n\n            if(!isReclaimable)\n            {\n                require(msg.value >= pairInfo.currentPrice * 102 / 100, 'FESN: PAY LESS 1');  // minimum 2% increase\n                require(msg.value >= pairInfo.currentPrice + MINIMUM_PRICE_INCREACE, 'FESN: PAY LESS 2');  // minimum 0.02 BNB increase\n\n                // calculate airdrop amount, may be zero if airdrop depleted\n                airdropAmount = getAirDropAmount(msg.value - pairInfo.currentPrice);\n\n                // repay amount\n                uint256 repayAmount = pairInfo.currentPrice;\n                \n                // Change the token owner\n                _transfer(preOwner, to, tokenID);\n                \n                // update pairInfo information\n                pairInfo.lastBidTime = uint48(block.timestamp);\n                pairInfo.currentPrice = uint128(msg.value);\n\n                // Airdrop to the next coming tenders\n                if(airdropAmount > 0) TransferHelper.safeTransfer(FeswapToken, to, airdropAmount);\n\n                // Repay the previous owner             \n                TransferHelper.safeTransferETH(preOwner, repayAmount);\n                return tokenID;\n            }\n\n            // Prepare to reclaim the swap token-pair, half of the bidding price will be returned\n            uint256 returnPrice = pairInfo.currentPrice / 2;\n\n            // Change the token owner\n            _transfer(preOwner, to, tokenID);\n            \n            // return back 50% of the previous price\n            if( returnPrice > 0 ){\n                if((AirdropDepletionTime==0) || (pairInfo.timeCreated <= AirdropDepletionTime))\n                    TransferHelper.safeTransfer(FeswapToken, preOwner, returnPrice * AIRDROP_RATE_FOR_WINNER);\n\n                // As preOwner cannot be contact, re-entry not possible here       \n                TransferHelper.safeTransferETH(preOwner, returnPrice);\n            }\n        } else {\n            // _mint will check 'to' not be Zero, and tokenID not repeated.\n            _mint(to, tokenID);\n            emit PairCreadted(token0, token1, tokenID);             // (token0, token1, tokenID)\n            \n            // Only creators of the first 50,000 token pairs will receive the airdrop\n//          if (totalSupply() <= 50_000) airdropAmount = AIRDROP_FOR_FIRST;     // BNB\n            if (totalSupply() <= 10_000) airdropAmount = AIRDROP_FOR_FIRST;     // MATIC\n//          if (totalSupply() <= 4_000) airdropAmount = AIRDROP_FOR_FIRST;      // AVALANCHE\n  \n        }\n            \n        // Prepare swap token-pair infomation for initial creation or re-bidding\n        FeswaPair memory newPairInfo;\n        newPairInfo.tokenA = token0;\n        newPairInfo.tokenB = token1;\n        newPairInfo.currentPrice = uint128(msg.value);              \n        newPairInfo.timeCreated = uint48(block.timestamp);\n        newPairInfo.lastBidTime = uint48(block.timestamp);\n        newPairInfo.poolState = PoolRunningPhase.BidPhase;\n        ListPools[tokenID] = newPairInfo;\n\n        if(msg.value > 0) airdropAmount += getAirDropAmount(msg.value);\n\n        // Airdrop to the first tender, airdropAmount maybe 0 after 50K/10K token pair created\n        if(airdropAmount > 0) TransferHelper.safeTransfer(FeswapToken, to, airdropAmount);\n    }\n\n    function getAirDropAmount(uint256 userBidValue) internal returns (uint256 airdropAmount) {\n        airdropAmount = 0;\n        if(AirdropDepletionTime == 0) {\n            uint256 availableAirdrop = BIDDING_AIRDROP_CAP - TotalBidValue;\n            uint256 airdropValue = userBidValue;\n            if(availableAirdrop <= airdropValue) {\n                airdropValue = availableAirdrop;\n                AirdropDepletionTime = uint64(block.timestamp);\n            }\n            airdropAmount = airdropValue * AIRDROP_RATE_FOR_NEXT_BIDDER;\n        }\n        TotalBidValue += uint128(userBidValue);\n        return airdropAmount;\n    }\n\n    /**\n     * @dev Settle the bid for the swap pair. \n     */\n    function ManageFeswaPair( uint256 tokenID, address pairProfitReceiver, uint256 rateTrigger, uint256 switchOracleOn ) \n                external returns (address pairAAB, address pairABB) \n    {\n        require(msg.sender == ownerOf(tokenID), 'FESN: NOT TOKEN OWNER');       // ownerOf checked if tokenID existing\n\n        FeswaPair storage pairInfo = ListPools[tokenID]; \n        if(pairInfo.poolState < PoolRunningPhase.BidSettled){\n            if(pairInfo.poolState == PoolRunningPhase.BidPhase){\n                require(block.timestamp > pairInfo.timeCreated + OPEN_BID_DURATION, 'FESN: BID ON GOING 1');  \n            } else {\n                assert(pairInfo.poolState == PoolRunningPhase.BidDelaying); \n                require(block.timestamp > pairInfo.lastBidTime + CLOSE_BID_DELAY, 'FESN: BID ON GOING 2');\n            }\n\n            // could prevent recursive calling\n            pairInfo.poolState = PoolRunningPhase.BidSettled;\n\n            // Airdrop to the NFT owner, may be over airdropped, the over part paid from FeSwap Fund\n            if(pairInfo.currentPrice > 0) { \n                if((AirdropDepletionTime == 0) || (pairInfo.timeCreated <= AirdropDepletionTime))\n                    TransferHelper.safeTransfer(FeswapToken, msg.sender, pairInfo.currentPrice * AIRDROP_RATE_FOR_WINNER);\n            }    \n        }\n\n        (address tokenA, address tokenB) = (pairInfo.tokenA, pairInfo.tokenB);\n\n        // Create or Update the Pair settings \n        (pairAAB, pairABB) = IFeSwapFactory(PairFactory).createUpdatePair(tokenA, tokenB, pairProfitReceiver, rateTrigger, switchOracleOn); \n    }\n\n\n    /**\n     * @dev Sell the Pair with the specified Price. \n     */\n    function FeswaPairForSale(uint256 tokenID, uint256 pairPrice) external returns (uint256 newPrice) {\n        require(msg.sender == ownerOf(tokenID), 'FESN: NOT TOKEN OWNER');       // ownerOf checked if tokenID existing\n        \n        FeswaPair storage pairInfo = ListPools[tokenID]; \n        require(pairInfo.poolState >= PoolRunningPhase.BidSettled, 'FESN: BID NOT SETTLED'); \n\n        if(pairPrice != 0){\n            require(pairPrice <= MAX_SALE_PRICE, 'FESN: PRICE TOO HIGH'); \n            pairInfo.poolState = PoolRunningPhase.PoolForSale;\n            pairInfo.currentPrice = uint128(pairPrice);\n        } else {\n            pairInfo.poolState = PoolRunningPhase.PoolHolding;\n        }\n        \n        return pairPrice;\n    }    \n\n    /**\n     * @dev Sell the Pair with the specified Price. \n     */\n    function FeswaPairBuyIn(uint256 tokenID, uint256 newPrice, address to) external payable returns (uint256 getPrice) {\n        require(_exists(tokenID), 'FESN: TOKEN NOT CREATED');\n        FeswaPair storage pairInfo = ListPools[tokenID]; \n        require(pairInfo.poolState == PoolRunningPhase.PoolForSale, 'FESN: NOT FOR SALE');\n\n        uint256  currentPrice = pairInfo.currentPrice;\n        require(msg.value >= currentPrice, 'FESN: PAY LESS');  \n        require(newPrice <= MAX_SALE_PRICE, 'FESN: PRICE TOO HIGH'); \n\n        // Change the token owner\n        address preOwner = ownerOf(tokenID);\n\n        // send NFT to msg.sender, not to `to` Address\n        _transfer(preOwner, msg.sender, tokenID);\n\n        if(newPrice != 0){\n            pairInfo.currentPrice = uint128(newPrice);\n        } else {\n            pairInfo.poolState = PoolRunningPhase.PoolHolding;\n        }\n\n        // Modify the profit receiver \n        IFeSwapFactory(PairFactory).createUpdatePair(pairInfo.tokenA, pairInfo.tokenB, to, 0, 0);     \n\n        // Send ETH to the owner                    \n        TransferHelper.safeTransferETH(preOwner, currentPrice);\n        if( msg.value > currentPrice) \n            TransferHelper.safeTransferETH(msg.sender, msg.value - currentPrice);\n\n        return currentPrice;\n    }    \n\n    /**\n     * @dev Return the token-pair information \n     */\n    function getPoolInfoByTokens(address tokenA, address tokenB) external view returns (uint256 tokenID, address nftOwner, FeswaPair memory pairInfo) {\n        (address token0, address token1) = (tokenA < tokenB) ? (tokenA, tokenB) : (tokenB, tokenA);\n        tokenID = uint256(keccak256(abi.encodePacked(address(this), token0, token1)));\n        (nftOwner, pairInfo) = getPoolInfo(tokenID);\n    }\n\n    /**\n     * @dev Return the token pair addresses by TokenID \n     */\n    function getPoolInfo(uint256 tokenID) public view returns (address nftOwner, FeswaPair memory pairInfo) {\n        if(_exists(tokenID)){\n            nftOwner = ownerOf(tokenID);\n            pairInfo = ListPools[tokenID];\n        }\n    }\n\n    /**\n     * @dev Withdraw\n     */\n    function withdraw(address to, uint256 value) public onlyOwner{\n        require(address(this).balance >= value, 'FESN: INSUFFICIENT BALANCE');\n        TransferHelper.safeTransferETH(to, value);\n    }\n\n    function _beforeTokenTransfer(address from, address to, uint256 tokenId)\n        internal\n        override(ERC721, ERC721Enumerable)\n    {\n        super._beforeTokenTransfer(from, to, tokenId);\n    }\n\n    function _burn(uint256 tokenId) internal override(ERC721, ERC721URIStorage) {\n        super._burn(tokenId);\n    }\n\n    function tokenURI(uint256 tokenId)\n        public\n        view\n        override(ERC721, ERC721URIStorage)\n        returns (string memory)\n    {\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(ERC721, ERC721Enumerable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }    \n\n    /**\n     * @dev @dev Set the prefix for the tokenURIs.\n     */\n//    function setTokenURIPrefix(string memory prefix) public onlyOwner {\n//        _setBaseURI(prefix);\n//    }\n\n//    function setTokenURI(uint256 tokenID, string memory tokenURI) public {\n//        require(msg.sender == ownerOf(tokenID), 'FESN: NOT TOKEN OWNER');       // ownerOf checked if tokenID existing\n//        _setTokenURI(tokenID, tokenURI);\n//    }\n}\n"
    },
    "@openzeppelin/contracts/utils/math/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/math/SafeMath.sol)\n\npragma solidity ^0.8.0;\n\n// CAUTION\n// This version of SafeMath should only be used with Solidity 0.8 or later,\n// because it relies on the compiler's built in overflow checks.\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations.\n *\n * NOTE: `SafeMath` is generally not needed starting with Solidity 0.8, since the compiler\n * now has built in overflow checking.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryAdd(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            uint256 c = a + b;\n            if (c < a) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function trySub(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b > a) return (false, 0);\n            return (true, a - b);\n        }\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, with an overflow flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMul(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n            // benefit is lost if 'b' is also tested.\n            // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n            if (a == 0) return (true, 0);\n            uint256 c = a * b;\n            if (c / a != b) return (false, 0);\n            return (true, c);\n        }\n    }\n\n    /**\n     * @dev Returns the division of two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryDiv(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a / b);\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers, with a division by zero flag.\n     *\n     * _Available since v3.4._\n     */\n    function tryMod(uint256 a, uint256 b) internal pure returns (bool, uint256) {\n        unchecked {\n            if (b == 0) return (false, 0);\n            return (true, a % b);\n        }\n    }\n\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     *\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a + b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     *\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a * b;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator.\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a / b;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a % b;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {trySub}.\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     *\n     * - Subtraction cannot overflow.\n     */\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b <= a, errorMessage);\n            return a - b;\n        }\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers, reverting with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a / b;\n        }\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * reverting with custom message when dividing by zero.\n     *\n     * CAUTION: This function is deprecated because it requires allocating memory for the error\n     * message unnecessarily. For custom revert reasons use {tryMod}.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     *\n     * - The divisor cannot be zero.\n     */\n    function mod(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        unchecked {\n            require(b > 0, errorMessage);\n            return a % b;\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/ERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721.sol\";\nimport \"./IERC721Receiver.sol\";\nimport \"./extensions/IERC721Metadata.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/Context.sol\";\nimport \"../../utils/Strings.sol\";\nimport \"../../utils/introspection/ERC165.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721 is Context, ERC165, IERC721, IERC721Metadata {\n    using Address for address;\n    using Strings for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    constructor(string memory name_, string memory symbol_) {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165, IERC165) returns (bool) {\n        return\n            interfaceId == type(IERC721).interfaceId ||\n            interfaceId == type(IERC721Metadata).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721Receiver(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721Receiver.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\nimport \"./IERC721Enumerable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721Enumerable is ERC721, IERC721Enumerable {\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165, ERC721) returns (bool) {\n        return interfaceId == type(IERC721Enumerable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Enumerable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/ERC721URIStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/extensions/ERC721URIStorage.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721.sol\";\n\n/**\n * @dev ERC721 token with storage based token URI management.\n */\nabstract contract ERC721URIStorage is ERC721 {\n    using Strings for uint256;\n\n    // Optional mapping for token URIs\n    mapping(uint256 => string) private _tokenURIs;\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory _tokenURI = _tokenURIs[tokenId];\n        string memory base = _baseURI();\n\n        // If there is no base URI, return the token URI.\n        if (bytes(base).length == 0) {\n            return _tokenURI;\n        }\n        // If both are set, concatenate the baseURI and tokenURI (via abi.encodePacked).\n        if (bytes(_tokenURI).length > 0) {\n            return string(abi.encodePacked(base, _tokenURI));\n        }\n\n        return super.tokenURI(tokenId);\n    }\n\n    /**\n     * @dev Sets `_tokenURI` as the tokenURI of `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _setTokenURI(uint256 tokenId, string memory _tokenURI) internal virtual {\n        require(_exists(tokenId), \"ERC721URIStorage: URI set of nonexistent token\");\n        _tokenURIs[tokenId] = _tokenURI;\n    }\n\n    /**\n     * @dev See {ERC721-_burn}. This override additionally checks to see if a\n     * token-specific URI was set for the token, and if so, it deletes the token URI from\n     * the storage mapping.\n     */\n    function _burn(uint256 tokenId) internal virtual override {\n        super._burn(tokenId);\n\n        if (bytes(_tokenURIs[tokenId]).length != 0) {\n            delete _tokenURIs[tokenId];\n        }\n    }\n}\n"
    },
    "contracts/test/AMMV2/Governance/utils/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}\n"
    },
    "contracts/test/AMMV2/Governance/patch/NFTPatchCaller.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.9;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to the patch \n *      using the EVM instruction `delegatecall`. The success and return data of the delegated call \n *      will be returned back to the caller of the proxy.\n */\nabstract contract NFTPatchCaller {\n    // DELEGATE_TARGET = uint160(                      // downcast to match the address type.\n    //                      uint256(                    // convert to uint to truncate upper digits.\n    //                          keccak256(                // compute the CREATE2 hash using 4 inputs.\n    //                              abi.encodePacked(       // pack all inputs to the hash together.\n    //                                  hex\"ff\",              // start with 0xff to distinguish from RLP.\n    //                                  address(this),        // this contract will be the caller.\n    //                                  salt,                 // pass in the supplied salt value.\n    //                                  _metamorphicContractInitializationCodeHash // the init code hash.\n    //                              )\n    //                          )\n    //                      )\n    //                   )\n    //\n    // salt = keccak256(\"Feswap NFT Patch\") = 0x291AD4D300CBA1259F2807167DE059F45F0EA7EDC76A99BE5290E88E498EC62B\n    // metamorphicContractInitializationCode = 0x60006020816004601c335a63aaf10f428752fa60185780fd5b808151803b80938091923cf3\n    // _metamorphicContractInitializationCodeHash = keccak256(metamorphicContractInitializationCode)\n    //                                            = 0x15bfb1132dc67a984de77a9eef294f7e58964d02c62a359fd6f3c0c1d443e35c \n    // address(this): 0x84e924C5E04438D2c1Df1A981f7E7104952e6de1 (Test) \n    // address(this): 0x6A8FE4753AB456e85E1379432d92ABF1fB49B5Df (Rinkeby/BSC/Polygon/Harmoney/Arbitrum/Fantom/Avalance/Heco Testnet) \n    // address(this): 0x8565570A7cB2b2508F9180AD83e8f58F25e41596 (Goerli) \n    // address(this): 0x0528D7de63aafdF748a5ef530949C80c4e8fbeC7 (Polygon Mainnet) \n   \n//  address public constant DELEGATE_TARGET = 0x92DD76703DACF9BE7F61CBC7ADAF77319084DBF8;   // (Goerli)\n//  address public constant DELEGATE_TARGET = 0x0c30E7e5361533961CC651ba4F32EA222C0D214B;   // (Test)\n//  address public constant DELEGATE_TARGET = 0x90ccE03b617AAA4924bEabc41856973f52684B9B;   // (BSC/MATIC Testnet)\n    address public constant DELEGATE_TARGET = 0x90A52bC0Ed546Cd90CD0C1BF271a497746874A9f;   // (Polygon Mainnet)\n\n    /**\n     * @dev Delegates the current call to `DELEGATE_TARGET`.\n     *\n     * This function does not return to its internall call site, it will return directly to the external caller.\n     */\n\n    receive() external virtual payable {\n        revert(\"Refused!\");\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback () external payable virtual {\n       // solhint-disable-next-line no-inline-assembly\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), DELEGATE_TARGET, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 { revert(0, returndatasize()) }\n            default { return(0, returndatasize()) }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721 is IERC165 {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721Receiver {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Metadata is IERC721 {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/ERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165 is IERC165 {\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165).interfaceId;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/introspection/IERC165.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165 {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts/token/ERC721/extensions/IERC721Enumerable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721Enumerable is IERC721 {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "contracts/GreenBTCImage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n\r\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nimport \"./libraries/FormattedStrings.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\n\r\nimport './GreenBTCType.sol';\r\n\r\ncontract GreenBTCImage {\r\n \r\n    using Strings for uint128;\r\n    using Strings for uint256;\r\n    using Strings for address;\r\n    using FormattedStrings for uint256;\r\n\r\n    function _decimalTruncate(string memory _str, uint256 decimalDigits) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(_str);\r\n        uint256 dotIndex = strBytes.length;\r\n\r\n        for (uint256 i = 0; i < strBytes.length; i++) {\r\n            if (strBytes[i] == \".\") {\r\n\r\n                if(i + decimalDigits + 1 < strBytes.length){\r\n                    dotIndex = i + decimalDigits + 1;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory result = new bytes(dotIndex);\r\n        for (uint256 i = 0; i < dotIndex; i++) {\r\n            result[i] = strBytes[i];\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n\r\n\r\n    function getCertificateSVG(address owner, GreenBTCInfo calldata gbtc, NFTStatus calldata dataNFT) external pure returns(string memory) {\r\n\r\n        string memory svgData;\r\n        uint256 tokenID = gbtc.height;\r\n\r\n        bytes memory typeNFT;\r\n        string memory turncateEnergy = _decimalTruncate(gbtc.energyStr, 3);\r\n        if(dataNFT.open == false || dataNFT.reveal == false) { \r\n            svgData = getBlindBoxSVGBytes(tokenID);\r\n            typeNFT = 'Mystery Box';\r\n        } else {\r\n            if(dataNFT.won) {\r\n                svgData = getGreenTreeSVGBytes(gbtc.greenType);\r\n                typeNFT = 'Genesis Seed';\r\n            } else {\r\n                svgData = getCertificateSVGBytes(owner, gbtc);    \r\n                typeNFT = 'Certificate';\r\n            }      \r\n        }\r\n\r\n        bytes memory dataURI = abi.encodePacked(\r\n            '{\"name\":\"GreenBTC #',\r\n            tokenID.toString(),\r\n            '\",\"description\":\"',\r\n            \"Climate Actions For Greening BTC.\",\r\n            '\",\"image\":\"data:image/svg+xml;base64,',\r\n            svgData,\r\n            '\",\"attributes\":[{\"display_type\":\"number\",\"trait_type\":\"Height\",\"value\":',\r\n            tokenID.toString(),\r\n            '},{\"trait_type\":\"Energy\",\"value\":\"',\r\n            turncateEnergy,\r\n            ' kWh\"},{\"trait_type\":\"Type\",\"value\":\"',\r\n            typeNFT,\r\n            '\"}]}'\r\n        );\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(dataURI)));\r\n    }\r\n\r\n    function getCertificateSVGBytes(address owner, GreenBTCInfo calldata gbtc) internal pure returns(string memory) {\r\n\r\n        string memory turncateEnergy = _decimalTruncate(gbtc.energyStr, 3);\r\n\r\n        string memory artFlag = ((gbtc.greenType & 0xF0) == 0x10) \r\n                                  ? '<text x=\"15\" y=\"135\" class=\"prefix__medium\">*ART</text>' \r\n                                  : '';\r\n\r\n        bytes memory imgBytes = abi.encodePacked(\r\n            '<svg width=\"300\" height=\"300\" xmlns=\"http://www.w3.org/2000/svg\" font-family=\"Courier New\">'\r\n            '<rect width=\"300\" height=\"300\" rx=\"10\" fill=\"#f3f6d3\" />'\r\n            '<path fill=\"#fffef8\" d=\"M0 60h300v125H0z\" />'\r\n            '<rect y=\"240\" width=\"300\" height=\"60\" rx=\"10\" fill=\"#e5d2bd\" />'\r\n            '<path fill=\"#f6dfeb\" d=\"M0 180h300v70H0z\" />'\r\n            '<text x=\"15\" y=\"25\" class=\"prefix__medium\">GREENBTC CERTIFICATE</text>'\r\n            '<path fill=\"#8E8984\" d=\"M15 50h115v.409H15z\" />'\r\n            '<path opacity=\".1\" stroke=\"#5F5246\" stroke-width=\"20\" stroke-dasharray=\"5 5 5\" d=\"M275 208v87\" />'\r\n            '<text x=\"15\" y=\"95\" class=\"prefix__medium\">HEIGHT&gt;</text>'\r\n            '<text x=\"110\" y=\"95\" class=\"prefix__medium\">',\r\n            gbtc.height.toString(),\r\n            '</text>'\r\n            '<text x=\"15\" y=\"115\" class=\"prefix__medium\">ENERGY&gt;</text>'\r\n            '<text x=\"110\" y=\"115\" class=\"prefix__medium\">',\r\n            turncateEnergy,\r\n            '  kWh'\r\n            '</text>',\r\n            artFlag,\r\n            '<text x=\"15\" y=\"210\" class=\"prefix__medium\">OWNER:</text>'\r\n            '<text x=\"15\" y=\"230\" font-size=\"9\">',\r\n            owner.toHexString(),\r\n            '</text>'\r\n            '<g opacity=\".25\" fill=\"#FFC736\">'\r\n            '<path d=\"M223.859 16.717h-.26V0H203.51v16.717h-20.096v123.824h20.096v16.733h20.089v-16.733h.26v-26.773H210.2V90.342h13.659V63.57H210.2V43.49h13.659V16.717zM236.579 63.57h17.148c5.547 0 10.044-4.495 10.044-10.04 0-5.545-4.497-10.04-10.044-10.04h-17.148V0h20.071v16.832c18.974 1.489 33.907 17.35 33.907 36.698a36.655 36.655 0 01-8.866 23.957 38.316 38.316 0 018.866 24.568c0 19.7-14.809 35.943-33.907 38.214v17.005h-20.071v-43.506h15.473c6.473 0 11.719-5.244 11.719-11.713 0-6.469-5.246-11.713-11.719-11.713h-15.473V63.57z\" />'\r\n            '</g>'\r\n            '<style>.prefix__medium{font-size:16px}</style>'\r\n            '</svg>'\r\n        );\r\n\r\n        return  string(Base64.encode(imgBytes));\r\n    }\r\n\r\n    function getGreenTreeSVGBytes(uint8 greenType) internal pure returns(string memory) {\r\n\r\n        string memory artFlag = ((greenType & 0xF0) == 0x10) \r\n                                  ? '<rect width=\"10\" height=\"10\" x=\"290\" y=\"280\" fill=\"#fff\"/>'\r\n                                    '<rect width=\"10\" height=\"10\" x=\"280\" y=\"280\" fill=\"#58a90f\"/>'\r\n                                    '<rect width=\"10\" height=\"10\" x=\"290\" y=\"290\" fill=\"#58a90f\"/>'\r\n                                    '<rect width=\"10\" height=\"10\" x=\"280\" y=\"290\" fill=\"#fff\"/>'\r\n                                   : '';\r\n\r\n        bytes memory imgBytes = abi.encodePacked(\r\n            '<svg width=\"320\" height=\"320\" viewBox=\"0 0 320 320\" xmlns=\"http://www.w3.org/2000/svg\" shape-rendering=\"crispEdges\">'\r\n                '<rect width=\"100%\" height=\"100%\" fill=\"none\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"0\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"10\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"20\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"30\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"40\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"50\" fill=\"#49b652\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"0\" y=\"60\" fill=\"#49b652\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"60\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"120\" y=\"60\" fill=\"#49b652\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"60\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"170\" y=\"60\" fill=\"#49b652\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"60\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"220\" y=\"60\" fill=\"#49b652\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"0\" y=\"70\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"70\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"70\" fill=\"#287a17\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"120\" y=\"70\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"130\" y=\"70\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"140\" y=\"70\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"70\" fill=\"#58a90f\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"170\" y=\"70\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"180\" y=\"70\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"190\" y=\"70\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"70\" fill=\"#287a17\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"70\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"230\" y=\"70\" fill=\"#49b652\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"0\" y=\"80\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"80\" y=\"80\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"80\" fill=\"#287a17\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"80\" fill=\"#1e6310\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"120\" y=\"80\" fill=\"#287a17\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"130\" y=\"80\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"80\" fill=\"#58a90f\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"170\" y=\"80\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"190\" y=\"80\" fill=\"#287a17\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"80\" fill=\"#1e6310\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"80\" fill=\"#287a17\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"230\" y=\"80\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"240\" y=\"80\" fill=\"#49b652\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"0\" y=\"90\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"90\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"90\" fill=\"#287a17\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"120\" y=\"90\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"130\" y=\"90\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"140\" y=\"90\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"90\" fill=\"#58a90f\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"170\" y=\"90\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"180\" y=\"90\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"190\" y=\"90\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"90\" fill=\"#287a17\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"90\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"230\" y=\"90\" fill=\"#49b652\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"0\" y=\"100\" fill=\"#49b652\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"100\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"120\" y=\"100\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"140\" y=\"100\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"100\" fill=\"#58a90f\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"170\" y=\"100\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"180\" y=\"100\" fill=\"#49b652\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"100\" fill=\"#0e3500\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"220\" y=\"100\" fill=\"#49b652\"/>'\r\n                '<rect width=\"130\" height=\"10\" x=\"0\" y=\"110\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"130\" y=\"110\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"140\" y=\"110\" fill=\"#b7a31c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"110\" fill=\"#bec028\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"170\" y=\"110\" fill=\"#b7a31c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"180\" y=\"110\" fill=\"#30120b\"/>'\r\n                '<rect width=\"130\" height=\"10\" x=\"190\" y=\"110\" fill=\"#49b652\"/>'\r\n                '<rect width=\"120\" height=\"10\" x=\"0\" y=\"120\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"120\" y=\"120\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"130\" y=\"120\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"140\" y=\"120\" fill=\"#30120b\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"120\" fill=\"#b7a31c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"170\" y=\"120\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"180\" y=\"120\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"190\" y=\"120\" fill=\"#30120b\"/>'\r\n                '<rect width=\"120\" height=\"10\" x=\"200\" y=\"120\" fill=\"#49b652\"/>'\r\n                '<rect width=\"110\" height=\"10\" x=\"0\" y=\"130\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"110\" y=\"130\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"120\" y=\"130\" fill=\"#662819\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"130\" y=\"130\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"130\" fill=\"#30120b\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"170\" y=\"130\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"190\" y=\"130\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"200\" y=\"130\" fill=\"#30120b\"/>'\r\n                '<rect width=\"110\" height=\"10\" x=\"210\" y=\"130\" fill=\"#49b652\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"0\" y=\"140\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"100\" y=\"140\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"110\" y=\"140\" fill=\"#662819\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"120\" y=\"140\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"200\" y=\"140\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"210\" y=\"140\" fill=\"#30120b\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"220\" y=\"140\" fill=\"#49b652\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"0\" y=\"150\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"150\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"100\" y=\"150\" fill=\"#662819\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"110\" y=\"150\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"60\" height=\"10\" x=\"130\" y=\"150\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"190\" y=\"150\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"210\" y=\"150\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"150\" fill=\"#30120b\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"230\" y=\"150\" fill=\"#49b652\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"0\" y=\"160\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"160\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"100\" y=\"160\" fill=\"#662819\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"110\" y=\"160\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"60\" height=\"10\" x=\"130\" y=\"160\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"190\" y=\"160\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"210\" y=\"160\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"160\" fill=\"#30120b\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"230\" y=\"160\" fill=\"#49b652\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"0\" y=\"170\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"80\" y=\"170\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"170\" fill=\"#662819\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"100\" y=\"170\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"130\" y=\"170\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"170\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"170\" y=\"170\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"190\" y=\"170\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"170\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"230\" y=\"170\" fill=\"#30120b\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"240\" y=\"170\" fill=\"#49b652\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"0\" y=\"180\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"80\" y=\"180\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"180\" fill=\"#662819\"/>'\r\n                '<rect width=\"70\" height=\"10\" x=\"100\" y=\"180\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"170\" y=\"180\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"190\" y=\"180\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"180\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"230\" y=\"180\" fill=\"#30120b\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"240\" y=\"180\" fill=\"#49b652\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"0\" y=\"190\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"80\" y=\"190\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"190\" fill=\"#662819\"/>'\r\n                '<rect width=\"50\" height=\"10\" x=\"100\" y=\"190\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"40\" height=\"10\" x=\"150\" y=\"190\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"190\" y=\"190\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"190\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"230\" y=\"190\" fill=\"#30120b\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"240\" y=\"190\" fill=\"#49b652\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"0\" y=\"200\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"80\" y=\"200\" fill=\"#30120b\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"200\" fill=\"#662819\"/>'\r\n                '<rect width=\"50\" height=\"10\" x=\"100\" y=\"200\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"200\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"50\" height=\"10\" x=\"170\" y=\"200\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"200\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"230\" y=\"200\" fill=\"#30120b\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"240\" y=\"200\" fill=\"#49b652\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"0\" y=\"210\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"80\" y=\"210\" fill=\"#30120b\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"90\" y=\"210\" fill=\"#662819\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"110\" y=\"210\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"210\" y=\"210\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"230\" y=\"210\" fill=\"#30120b\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"240\" y=\"210\" fill=\"#49b652\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"0\" y=\"220\" fill=\"#49b652\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"90\" y=\"220\" fill=\"#30120b\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"220\" fill=\"#662819\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"120\" y=\"220\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"150\" y=\"220\" fill=\"#ffffff\"/>'\r\n                '<rect width=\"30\" height=\"10\" x=\"170\" y=\"220\" fill=\"#722f1c\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"220\" fill=\"#662819\"/>'\r\n                '<rect width=\"10\" height=\"10\" x=\"220\" y=\"220\" fill=\"#30120b\"/>'\r\n                '<rect width=\"90\" height=\"10\" x=\"230\" y=\"220\" fill=\"#49b652\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"0\" y=\"230\" fill=\"#49b652\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"230\" fill=\"#30120b\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"120\" y=\"230\" fill=\"#662819\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"230\" fill=\"#30120b\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"220\" y=\"230\" fill=\"#49b652\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"0\" y=\"240\" fill=\"#49b652\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"100\" y=\"240\" fill=\"#426c4a\"/>'\r\n                '<rect width=\"80\" height=\"10\" x=\"120\" y=\"240\" fill=\"#30120b\"/>'\r\n                '<rect width=\"20\" height=\"10\" x=\"200\" y=\"240\" fill=\"#426c4a\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"220\" y=\"240\" fill=\"#49b652\"/>'\r\n                '<rect width=\"110\" height=\"10\" x=\"0\" y=\"250\" fill=\"#49b652\"/>'\r\n                '<rect width=\"100\" height=\"10\" x=\"110\" y=\"250\" fill=\"#426c4a\"/>'\r\n                '<rect width=\"110\" height=\"10\" x=\"210\" y=\"250\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"260\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"270\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"280\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"290\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"300\" fill=\"#49b652\"/>'\r\n                '<rect width=\"320\" height=\"10\" x=\"0\" y=\"310\" fill=\"#49b652\"/>',\r\n                artFlag,\r\n                '</svg>'\r\n        );\r\n\r\n        return  string(Base64.encode(imgBytes));\r\n    }\r\n\r\n    function getBlindBoxSVGBytes(uint256 num) internal pure returns(string memory){\r\n        bytes memory imgBytes = abi.encodePacked(\r\n            '<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 192 192\" preserveAspectRatio=\"xMinYMin meet\" fill=\"none\">'\r\n            '<style>.f{font-family:Montserrat,arial,sans-serif;dominant-baseline:middle;text-anchor:middle}</style>'\r\n            '<path d=\"M96.864 172.667L33.356 136v56.833L96.863 246v-73.333zM160.4 135.997l-63.51 36.667v73.333l63.51-76.54v-33.46z\"/>'\r\n            '<path d=\"M96.86 99.33L33.352 62.665v73.333l63.508 36.667V99.33z\" fill=\"#E8C684\"/>'\r\n            '<path d=\"M160.395 62.67L96.887 99.335v73.333l63.508-36.667V62.67z\" fill=\"#D7A94F\"/>'\r\n            '<path d=\"M160.395 62.667L96.887 26 33.378 62.667l63.509 36.666 63.508-36.666z\" fill=\"#EEDEA6\"/>'\r\n            '<text class=\"f\" x=\"118\" y=\"7\" transform=\"rotate(30.5) skewX(-30)\" fill=\"#98601e\" font-size=\"16\" font-weight=\"400\">',\r\n            num.toString(),\r\n            \"</text>\"\r\n            '<text class=\"f\" x=\"68\" y=\"82\" transform=\"skewY(26.83) scale(.92718 1.07853)\" fill=\"rgba(255,255,255,.5)\" font-size=\"42\">?</text>'\r\n            \"</svg>\"\r\n        );\r\n\r\n        return  string(Base64.encode(imgBytes));\r\n    }\r\n\r\n}"
    },
    "@openzeppelin/contracts/utils/Base64.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Base64.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Provides a set of functions to operate with Base64 strings.\n *\n * _Available since v4.5._\n */\nlibrary Base64 {\n    /**\n     * @dev Base64 Encoding/Decoding Table\n     */\n    string internal constant _TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n\n    /**\n     * @dev Converts a `bytes` to its Bytes64 `string` representation.\n     */\n    function encode(bytes memory data) internal pure returns (string memory) {\n        /**\n         * Inspired by Brecht Devos (Brechtpd) implementation - MIT licence\n         * https://github.com/Brechtpd/base64/blob/e78d9fd951e7b0977ddca77d92dc85183770daf4/base64.sol\n         */\n        if (data.length == 0) return \"\";\n\n        // Loads the table into memory\n        string memory table = _TABLE;\n\n        // Encoding takes 3 bytes chunks of binary data from `bytes` data parameter\n        // and split into 4 numbers of 6 bits.\n        // The final Base64 length should be `bytes` data length multiplied by 4/3 rounded up\n        // - `data.length + 2`  -> Round up\n        // - `/ 3`              -> Number of 3-bytes chunks\n        // - `4 *`              -> 4 characters for each chunk\n        string memory result = new string(4 * ((data.length + 2) / 3));\n\n        /// @solidity memory-safe-assembly\n        assembly {\n            // Prepare the lookup table (skip the first \"length\" byte)\n            let tablePtr := add(table, 1)\n\n            // Prepare result pointer, jump over length\n            let resultPtr := add(result, 32)\n\n            // Run over the input, 3 bytes at a time\n            for {\n                let dataPtr := data\n                let endPtr := add(data, mload(data))\n            } lt(dataPtr, endPtr) {\n\n            } {\n                // Advance 3 bytes\n                dataPtr := add(dataPtr, 3)\n                let input := mload(dataPtr)\n\n                // To write each character, shift the 3 bytes (18 bits) chunk\n                // 4 times in blocks of 6 bits for each character (18, 12, 6, 0)\n                // and apply logical AND with 0x3F which is the number of\n                // the previous character in the ASCII table prior to the Base64 Table\n                // The result is then added to the table to get the character to write,\n                // and finally write it in the result pointer but with a left shift\n                // of 256 (1 byte) - 8 (1 ASCII char) = 248 bits\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(18, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(12, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(shr(6, input), 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n\n                mstore8(resultPtr, mload(add(tablePtr, and(input, 0x3F))))\n                resultPtr := add(resultPtr, 1) // Advance\n            }\n\n            // When data `bytes` is not exactly 3 bytes long\n            // it is padded with `=` characters at the end\n            switch mod(mload(data), 3)\n            case 1 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n                mstore8(sub(resultPtr, 2), 0x3d)\n            }\n            case 2 {\n                mstore8(sub(resultPtr, 1), 0x3d)\n            }\n        }\n\n        return result;\n    }\n}\n"
    },
    "contracts/libraries/FormattedStrings.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nlibrary FormattedStrings {\r\n    /**\r\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\r\n            Base on OpenZeppelin `toString` method from `String` library\r\n     */\r\n    function toFormattedString(uint256 value) internal pure returns (string memory) {\r\n        // Inspired by OraclizeAPI's implementation - MIT licence\r\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\r\n\r\n        if (value == 0) {\r\n            return \"0\";\r\n        }\r\n        uint256 temp = value;\r\n        uint256 digits;\r\n        while (temp != 0) {\r\n            digits++;\r\n            temp /= 10;\r\n        }\r\n        uint256 pos;\r\n        uint256 comas = digits / 3;\r\n        digits = digits + (digits % 3 == 0 ? comas - 1 : comas);\r\n        bytes memory buffer = new bytes(digits);\r\n        while (value != 0) {\r\n            digits -= 1;\r\n            if (pos == 3) {\r\n                buffer[digits] = \",\";\r\n                pos = 0;\r\n            } else {\r\n                buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\r\n                value /= 10;\r\n                pos++;\r\n            }\r\n        }\r\n        return string(buffer);\r\n    }\r\n}"
    },
    "contracts/libraries/TransferHelper.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n// helper methods for interacting with ERC20 tokens and sending ETH that do not consistently return true/false\nlibrary TransferHelper {\n    function safeApprove(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('approve(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x095ea7b3, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: APPROVE_FAILED');\n    }\n\n    function safeTransfer(address token, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transfer(address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0xa9059cbb, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FAILED');\n    }\n\n    function safeTransferFrom(address token, address from, address to, uint value) internal {\n        // bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\n        (bool success, bytes memory data) = token.call(abi.encodeWithSelector(0x23b872dd, from, to, value));\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\n    }\n\n    function safeTransferETH(address to, uint value) internal {\n        (bool success,) = to.call{value:value}(new bytes(0));\n        require(success, 'TransferHelper: ETH_TRANSFER_FAILED');\n    }\n}"
    },
    "contracts/GreenBTCType.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nstruct GreenBTCInfo {\r\n    uint128     height;\r\n    uint128     ARTCount;\r\n    address     minter;             // Minter of the respective NFT\r\n    uint8       greenType;          // High nibble:  ART type: 0, CART, 1, Arkreen ART; Low nibble: mint type, 1: system, 2: user;  \r\n    string      blockTime;          // For NFT display\r\n    string      energyStr;          // For NTT display\r\n}\r\n\r\nstruct NFTStatus {\r\n    address     opener;\r\n    uint64      blockHeight;\r\n    bool        open;\r\n    bool        reveal;\r\n    bool        won;\r\n    uint256     seed;\r\n}\r\n\r\nstruct OpenInfo {\r\n    uint64      tokenID;            // The token ID of the NFT opened\r\n    uint64      openHeight;         // The height of the block opening the NFT\r\n}\r\n\r\nstruct Sig {\r\n    uint8       v;\r\n    bytes32     r;\r\n    bytes32     s;              \r\n}\r\n\r\nstruct PayInfo {\r\n    address     token;\r\n    uint256     amount;\r\n}\r\n\r\nstruct BadgeInfo {\r\n    address     beneficiary;\r\n    string      offsetEntityID;\r\n    string      beneficiaryID;\r\n    string      offsetMessage;\r\n}"
    },
    "contracts/interfaces/IGreenBTCImage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '../GreenBTCType.sol';\r\n\r\ninterface IGreenBTCImage {\r\n    function getCertificateSVG(address owner, GreenBTCInfo calldata gbtc, NFTStatus calldata dataNFT) \r\n                                external pure returns(string memory);\r\n}\r\n"
    },
    "hardhat/console.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >= 0.4.22 <0.9.0;\n\nlibrary console {\n\taddress constant CONSOLE_ADDRESS = address(0x000000000000000000636F6e736F6c652e6c6f67);\n\n\tfunction _sendLogPayload(bytes memory payload) private view {\n\t\tuint256 payloadLength = payload.length;\n\t\taddress consoleAddress = CONSOLE_ADDRESS;\n\t\tassembly {\n\t\t\tlet payloadStart := add(payload, 32)\n\t\t\tlet r := staticcall(gas(), consoleAddress, payloadStart, payloadLength, 0, 0)\n\t\t}\n\t}\n\n\tfunction log() internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log()\"));\n\t}\n\n\tfunction logInt(int256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(int256)\", p0));\n\t}\n\n\tfunction logUint(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction logString(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction logBool(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction logAddress(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction logBytes(bytes memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes)\", p0));\n\t}\n\n\tfunction logBytes1(bytes1 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes1)\", p0));\n\t}\n\n\tfunction logBytes2(bytes2 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes2)\", p0));\n\t}\n\n\tfunction logBytes3(bytes3 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes3)\", p0));\n\t}\n\n\tfunction logBytes4(bytes4 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes4)\", p0));\n\t}\n\n\tfunction logBytes5(bytes5 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes5)\", p0));\n\t}\n\n\tfunction logBytes6(bytes6 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes6)\", p0));\n\t}\n\n\tfunction logBytes7(bytes7 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes7)\", p0));\n\t}\n\n\tfunction logBytes8(bytes8 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes8)\", p0));\n\t}\n\n\tfunction logBytes9(bytes9 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes9)\", p0));\n\t}\n\n\tfunction logBytes10(bytes10 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes10)\", p0));\n\t}\n\n\tfunction logBytes11(bytes11 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes11)\", p0));\n\t}\n\n\tfunction logBytes12(bytes12 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes12)\", p0));\n\t}\n\n\tfunction logBytes13(bytes13 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes13)\", p0));\n\t}\n\n\tfunction logBytes14(bytes14 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes14)\", p0));\n\t}\n\n\tfunction logBytes15(bytes15 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes15)\", p0));\n\t}\n\n\tfunction logBytes16(bytes16 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes16)\", p0));\n\t}\n\n\tfunction logBytes17(bytes17 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes17)\", p0));\n\t}\n\n\tfunction logBytes18(bytes18 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes18)\", p0));\n\t}\n\n\tfunction logBytes19(bytes19 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes19)\", p0));\n\t}\n\n\tfunction logBytes20(bytes20 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes20)\", p0));\n\t}\n\n\tfunction logBytes21(bytes21 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes21)\", p0));\n\t}\n\n\tfunction logBytes22(bytes22 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes22)\", p0));\n\t}\n\n\tfunction logBytes23(bytes23 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes23)\", p0));\n\t}\n\n\tfunction logBytes24(bytes24 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes24)\", p0));\n\t}\n\n\tfunction logBytes25(bytes25 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes25)\", p0));\n\t}\n\n\tfunction logBytes26(bytes26 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes26)\", p0));\n\t}\n\n\tfunction logBytes27(bytes27 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes27)\", p0));\n\t}\n\n\tfunction logBytes28(bytes28 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes28)\", p0));\n\t}\n\n\tfunction logBytes29(bytes29 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes29)\", p0));\n\t}\n\n\tfunction logBytes30(bytes30 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes30)\", p0));\n\t}\n\n\tfunction logBytes31(bytes31 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes31)\", p0));\n\t}\n\n\tfunction logBytes32(bytes32 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bytes32)\", p0));\n\t}\n\n\tfunction log(uint256 p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256)\", p0));\n\t}\n\n\tfunction log(string memory p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string)\", p0));\n\t}\n\n\tfunction log(bool p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool)\", p0));\n\t}\n\n\tfunction log(address p0) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address)\", p0));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool)\", p0, p1));\n\t}\n\n\tfunction log(string memory p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool)\", p0, p1));\n\t}\n\n\tfunction log(bool p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address)\", p0, p1));\n\t}\n\n\tfunction log(address p0, uint256 p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256)\", p0, p1));\n\t}\n\n\tfunction log(address p0, string memory p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string)\", p0, p1));\n\t}\n\n\tfunction log(address p0, bool p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool)\", p0, p1));\n\t}\n\n\tfunction log(address p0, address p1) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address)\", p0, p1));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(bool p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, bool p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, bool p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool)\", p0, p1, p2));\n\t}\n\n\tfunction log(address p0, address p1, address p2) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address)\", p0, p1, p2));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(uint256 p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(uint256,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(string memory p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(string,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(bool p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(bool,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, uint256 p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,uint256,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, string memory p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,string,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, bool p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,bool,address,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, uint256 p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,uint256,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, string memory p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,string,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, bool p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,bool,address)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, uint256 p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,uint256)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, string memory p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,string)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, bool p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,bool)\", p0, p1, p2, p3));\n\t}\n\n\tfunction log(address p0, address p1, address p2, address p3) internal view {\n\t\t_sendLogPayload(abi.encodeWithSignature(\"log(address,address,address,address)\", p0, p1, p2, p3));\n\t}\n\n}\n"
    },
    "contracts/ArkreenBadge.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\r\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\r\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\r\n\r\nimport './ArkreenBadgeStorage.sol';\r\nimport \"./interfaces/IPausable.sol\";\r\nimport \"./interfaces/IArkreenRegistry.sol\";\r\nimport \"./interfaces/IArkreenRECIssuance.sol\";\r\nimport \"./interfaces/IArkreenBadgeImage.sol\";\r\nimport \"./interfaces/IERC5192.sol\";\r\nimport \"./ArkreenBadgeType.sol\";  \r\n\r\nimport \"./libraries/MemArrays.sol\";  \r\n\r\n// Import this file to use console.log\r\nimport \"hardhat/console.sol\";\r\n\r\ncontract ArkreenBadge is\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    ERC721EnumerableUpgradeable,\r\n    IERC721Receiver,\r\n    ArkreenBadgeStorage,\r\n    IERC5192\r\n{\r\n    using AddressUpgradeable for address;\r\n    using MemArrays for uint256[];\r\n\r\n    // Public variables\r\n    string public constant NAME = 'Arkreen REC Badge';\r\n    string public constant SYMBOL = 'ARB';\r\n\r\n     // Events\r\n    event ArkreenRegistryUpdated(address newArkreenRegistry);\r\n    event OffsetCertificateMinted(uint256 tokenId);\r\n    event OffsetCertificateUpdated(uint256 tokenId);\r\n    event OffsetAttached(uint256 tokenId, uint256[] offsetIds);\r\n  \r\n    modifier whenNotPaused() {\r\n        require(!IPausable(arkreenRegistry).paused(), 'ARB: Paused');\r\n        _;\r\n    }\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize(address arkRegistry) external virtual initializer {\r\n        __Ownable_init_unchained();\r\n        __UUPSUpgradeable_init();        \r\n        __ERC721_init_unchained(NAME, SYMBOL);\r\n        arkreenRegistry = arkRegistry;\r\n        baseURI = 'https://www.arkreen.com/badge/' ;\r\n    }   \r\n\r\n    function postUpdate() external onlyProxy onlyOwner \r\n    {}\r\n\r\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner\r\n    {}\r\n\r\n    /** \r\n     * @dev Update the arkreenRegistry contract address.\r\n     */\r\n    function updateArkreenRegistry(address _address) external virtual onlyOwner {\r\n        arkreenRegistry = _address;\r\n        emit ArkreenRegistryUpdated(_address);\r\n    }\r\n\r\n    /** \r\n     * @dev Change the minimum offset amount \r\n     */\r\n    function setMinOffsetAmount(uint256 amount) external virtual onlyOwner {\r\n        minOffsetAmount = uint128(amount);\r\n    }\r\n\r\n    function registerDetail(uint256 amount, uint256 tokenId, bool bNew) external returns (uint256, uint256) {\r\n\r\n        // The caller should be the REC token contract\r\n        require( IArkreenRegistry(arkreenRegistry).tokenRECs(msg.sender) != address(0), 'ARB: Caller Not Allowed');\r\n        require(tokenId == partialARECIDExt[msg.sender], 'ARB: Error TokenId');\r\n\r\n        uint256 curAmount = partialAvailableAmountExt[msg.sender];\r\n        if(bNew) {\r\n            // Only register new details while offsetting more than current paratial amount\r\n            require(amount == curAmount, 'ARB: Wrong New');    \r\n            detailsCounter += 1;\r\n        } else {\r\n            require(amount <= curAmount, 'ARB: Wrong Amount');\r\n        }\r\n\r\n        OffsetDetail memory offsetDetail;\r\n        offsetDetail.amount = uint128(amount);\r\n        offsetDetail.tokenId = uint64(tokenId);\r\n\r\n        OffsetDetails[detailsCounter].push(offsetDetail);            \r\n        curAmount = (partialAvailableAmountExt[msg.sender] -= amount);   // if bNew is true, partialAvailableAmountExt will be 0\r\n        \r\n        return (detailsCounter, curAmount);\r\n    }\r\n\r\n    function getDetailStatus(address tokenAREC) external view returns (uint256, uint256) {\r\n        return (partialAvailableAmountExt[tokenAREC], partialARECIDExt[tokenAREC]);\r\n    }\r\n\r\n    /** \r\n     * @dev To register offset actions so that they can be linked to an offset certificate NFT.\r\n     * Can only be called from the REC token contract, or from the REC issuance contrarct\r\n     * @param offsetEntity The entity that is offsetting the renewable energy.\r\n     * @param issuerREC The address of the REC issuer.\r\n     * @param amount The amount of the RE that is offset.\r\n     */\r\n    function registerOffset(\r\n        address offsetEntity,\r\n        address issuerREC,\r\n        uint256 amount,\r\n        uint256 tokenId\r\n    ) external returns (uint256) {\r\n        address RECIssuance = IArkreenRegistry(arkreenRegistry).getRECIssuance();\r\n        bool isRECIssuance = (msg.sender == RECIssuance);\r\n        bool isOffsetTokenId = (tokenId == 0) || ((tokenId >> 64) != 0);        // FLAG_OFFSET = 1<<64, to compliant with old design \r\n\r\n        // Check called from the REC token contract, or from the REC issuance contrarct\r\n        require( isRECIssuance || issuerREC == IArkreenRegistry(arkreenRegistry).tokenRECs(msg.sender), 'ARB: Wrong Issuer');\r\n\r\n        // TokenId should not be zero for RECIssuance, and should be offset type for RECToken\r\n        require(isRECIssuance != isOffsetTokenId, 'ARB: Wrong TokenId');\r\n\r\n        // Check the minimum offset amount\r\n        require( amount >= minOffsetAmount, 'ARB: Less Amount');\r\n\r\n        uint256 offsetId = offsetCounter + 1;\r\n        offsetCounter = offsetId;\r\n\r\n        if(isOffsetTokenId) {\r\n            if(tokenId != 0) {                          // to be compliant with old design\r\n                tokenId = uint64(tokenId);\r\n                if(tokenId ==0) {\r\n                    tokenId = partialARECIDExt[msg.sender] + (1<<63);\r\n                    partialAvailableAmountExt[msg.sender] -= amount;\r\n                } else {\r\n                    tokenId = uint64(detailsCounter) + (3<< 62);\r\n                }\r\n            }\r\n        }\r\n\r\n        OffsetAction memory offsetAction = OffsetAction(offsetEntity, issuerREC, uint128(amount), uint64(tokenId),\r\n                                                        uint56(block.timestamp), false);\r\n        offsetActions[offsetId] = offsetAction;\r\n\r\n        // Add offset ID to the user\r\n        userActions[offsetEntity].push(offsetId);\r\n        totalOffsetRegistered += amount;\r\n\r\n        return offsetId;\r\n    }\r\n\r\n    /**\r\n     * @dev Attach new offset action ids to an existing NFT.\r\n     * @param tokenId Id of the NFT to attach offset actions to.\r\n     * @param offsetIds List of offset action ids to link with the NFT.\r\n     */\r\n    function attachOffsetEvents(\r\n        uint256 tokenId,\r\n        uint256[] calldata offsetIds\r\n    ) external {\r\n        address tokenOwner = ownerOf(tokenId);\r\n        require(msg.sender == tokenOwner, 'ARB: Not Owner');\r\n        require(block.timestamp < (certificates[tokenId].creationTime + 3 days), 'ARB: Time Elapsed');        \r\n\r\n        uint256 offsetAmount =_attachOffsetEvents(tokenId, tokenOwner, offsetIds);\r\n        certificates[tokenId].offsetTotalAmount += offsetAmount;\r\n\r\n        // Accumulate the total retired offset amount\r\n        totalOffsetRetired += offsetAmount;\r\n        emit OffsetAttached(tokenId, offsetIds);\r\n    }    \r\n\r\n    /**\r\n     * @dev Attach offset actions to an NFT\r\n     * @param tokenId Id of the NFT to attach offset actions to\r\n     * @param offsetEntity Entity that is attaching offset actions\r\n     * @param offsetIds List of offset action ids to attach\r\n     */\r\n    function _attachOffsetEvents(\r\n        uint256 tokenId,\r\n        address offsetEntity,\r\n        uint256[] calldata offsetIds\r\n    ) internal returns(uint256) {\r\n        // List should not be empty\r\n        require(offsetIds.length != 0, 'ARB Empty List');\r\n\r\n        //slither-disable-next-line uninitialized-local\r\n        uint256 offsetAmount;\r\n\r\n        //slither-disable-next-line uninitialized-local\r\n        for (uint256 i; i < offsetIds.length; i++) {\r\n            uint256 offsetId = offsetIds[i];\r\n\r\n            // Check entity is identical\r\n            require(offsetActions[offsetId].offsetEntity == offsetEntity, 'ARB: Wrong Enity');\r\n\r\n            // Should not be attached\r\n            require(!offsetActions[offsetId].bClaimed, 'ARB: Already Claimed');\r\n            offsetActions[offsetId].bClaimed = true;\r\n\r\n            certificates[tokenId].offsetIds.push(offsetId);\r\n            offsetAmount += uint256(offsetActions[offsetId].amount);\r\n        }\r\n        \r\n        return offsetAmount;\r\n    }    \r\n\r\n    /**\r\n     * @dev Mint new RET Offset Certificate NFT which contains how much renewable energy are offset.\r\n     * @param offsetEntity The entity that holds offset actions and is eligible to mint an NFT.\r\n     * @param offsetEntityID ID string of the offset entity.\r\n     * @param beneficiary Beneficiary address for whom the RE was offset.\r\n     * @param beneficiaryID ID string of the beneficiary.\r\n     * @param offsetMessage Message to illustrate the offset intention.\r\n     * @param offsetIds ID list of the offset actions to attach to the NFT.\r\n     */\r\n    function mintCertificate(\r\n        address             offsetEntity,\r\n        address             beneficiary,\r\n        string calldata     offsetEntityID,\r\n        string calldata     beneficiaryID,\r\n        string calldata     offsetMessage,\r\n        uint256[] calldata  offsetIds\r\n    ) external virtual {\r\n        // The caller is either the offseting enity, or the REC token contract, or the REC issuance contract\r\n        require(_msgSender() == offsetEntity ||\r\n                IArkreenRegistry(arkreenRegistry).getRECIssuance() == msg.sender ||\r\n                IArkreenRegistry(arkreenRegistry).tokenRECs(msg.sender) != address(0),\r\n                'ARB: Caller Not Allowed');\r\n\r\n        uint256 tokenId = totalSupply() + 1;\r\n        _safeMint(offsetEntity, tokenId);\r\n\r\n        // Attach offset events to the newly minted NFT\r\n        uint256 offsetAmount = _attachOffsetEvents(tokenId, offsetEntity, offsetIds);\r\n\r\n        certificates[tokenId].offsetEntity = offsetEntity;\r\n        certificates[tokenId].beneficiary = beneficiary;\r\n        certificates[tokenId].offsetEntityID = offsetEntityID;      \r\n        certificates[tokenId].beneficiaryID = beneficiaryID;\r\n        certificates[tokenId].offsetMessage = offsetMessage;\r\n        certificates[tokenId].creationTime = block.timestamp;\r\n        certificates[tokenId].offsetTotalAmount += offsetAmount;\r\n\r\n        // Accumulate the total retired offset amount\r\n        totalOffsetRetired += offsetAmount;\r\n\r\n        emit OffsetCertificateMinted(tokenId);\r\n        emit Locked(tokenId);\r\n    }\r\n\r\n    /**\r\n     * @dev Update the message of offset certificate NFT, only callable within 3 days post creation.\r\n     * Empty values are ignored, existing stored values are kept.\r\n     * @param tokenId ID of the NFT to update.\r\n     * @param offsetEntityID Identification string for the offset entity.\r\n     * @param beneficiary Address of the beneficiary to store in the NFT.\r\n     * @param beneficiaryID Identification string of the beneficiary\r\n     * @param offsetMessage Offset indication message to store in the NFT.\r\n     */\r\n    function updateCertificate(\r\n        uint256 tokenId,\r\n        address beneficiary,        \r\n        string calldata offsetEntityID,\r\n        string calldata beneficiaryID,\r\n        string calldata offsetMessage\r\n    ) external virtual {\r\n        require(msg.sender == ownerOf(tokenId), 'ARB: Not Owner');\r\n        require(block.timestamp < (certificates[tokenId].creationTime + 3 days), 'ARB: Time Elapsed');\r\n\r\n        if (beneficiary != address(0)) {\r\n            certificates[tokenId].beneficiary = beneficiary;\r\n        }\r\n        if (bytes(offsetEntityID).length != 0) {\r\n            certificates[tokenId].offsetEntityID = offsetEntityID;\r\n        }\r\n        if (bytes(beneficiaryID).length != 0) {\r\n            certificates[tokenId].beneficiaryID = beneficiaryID;\r\n        }\r\n        if (bytes(offsetMessage).length != 0) {\r\n            certificates[tokenId].offsetMessage = offsetMessage;\r\n        }\r\n\r\n        emit OffsetCertificateUpdated(tokenId);\r\n    }\r\n\r\n\r\n    /// @dev Receive hook to liquidize Arkreen RE Certificate into RE ERC20 Token\r\n    function onERC721Received(\r\n        address,  /* operator */\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata data\r\n    ) external virtual override whenNotPaused returns (bytes4) {\r\n\r\n        // Check calling from REC Manager\r\n        address issuerREC = IArkreenRegistry(arkreenRegistry).getRECIssuance();\r\n        require( issuerREC == msg.sender, 'ARB: Not From REC Issuance');\r\n\r\n        (address issuer, uint128 amountREC, uint8 status, uint16 idAsset) = IArkreenRECIssuance(msg.sender).getRECDataCore(tokenId);\r\n\r\n        if(from == IArkreenRegistry(arkreenRegistry).getRECToken(issuer, idAsset)) {\r\n            require(status == uint256(RECStatus.Retired), 'ARB: Wrong Status'); \r\n            require(partialAvailableAmountExt[from] == 0, 'ARB: Partial Left');\r\n            partialARECIDExt[from] = tokenId;\r\n            partialAvailableAmountExt[from] = amountREC;\r\n            return this.onERC721Received.selector;\r\n        }\r\n\r\n        require( keccak256(data) == keccak256(\"Redeem\"), 'ARB: Refused');\r\n        require( status == uint256(RECStatus.Certified), 'ARB: Wrong Status');  // Checking may be removed\r\n\r\n        totalRedeemed = totalRedeemed + amountREC;\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    function supportsInterface(bytes4 interfaceId)\r\n        public view override( ERC721EnumerableUpgradeable) returns (bool)\r\n    {\r\n        return  interfaceId == type(IERC721Receiver).interfaceId || \r\n                interfaceId == type(IERC5192).interfaceId || \r\n                super.supportsInterface(interfaceId);\r\n    }  \r\n\r\n    /**\r\n     * @dev Get all the offset record of the specified NFT.        \r\n     */\r\n    function getCertificate(uint256 tokenId) external view returns (OffsetRecord memory) {\r\n        return certificates[tokenId];\r\n    }\r\n\r\n    /**\r\n     * @dev Get the list of all the offset actions ids        \r\n     */\r\n    function getUserEvents(address user) external view returns (uint256[] memory) {\r\n        return userActions[user];\r\n    }\r\n\r\n    /// @dev retrieve all data from OffsetAction struct\r\n    function getOffsetActions(uint256 offsetId) external view virtual returns (OffsetAction memory) {\r\n        return (offsetActions[offsetId]);\r\n    }    \r\n    \r\n    /// @dev retrieve the offset detaild specified by OffsetDetailId\r\n    function getOffsetDetails(uint256 OffsetDetailId) external view virtual returns (OffsetDetail[] memory) {\r\n        return (OffsetDetails[OffsetDetailId]);\r\n    } \r\n\r\n    /**\r\n     * @dev Get total offset amount of the specified NFT.        \r\n     */\r\n    function getOffsetAmount(uint256 tokenId) external view returns (uint256 amount) {\r\n        return certificates[tokenId].offsetTotalAmount;\r\n    }\r\n\r\n    /** \r\n     * @dev Change the BaseURI\r\n     */\r\n    function setBaseURI(string memory newBaseURI) external virtual onlyOwner {\r\n        baseURI = newBaseURI;\r\n    }\r\n\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        OffsetRecord storage offsetRecord = certificates[tokenId];\r\n        uint256 actionNumber = offsetRecord.offsetIds.length;\r\n\r\n        uint256[] memory idsAREC = new uint256[](0);\r\n        uint256 actionType;\r\n\r\n        for (uint256 index = 0; index < actionNumber; index++) {\r\n            uint256 offsetIds = offsetRecord.offsetIds[index];\r\n            uint256 idRetiredAREC = offsetActions[offsetIds].tokenId; \r\n            uint256 tag = idRetiredAREC >> 62;  \r\n\r\n            if (tag == 0) {\r\n                actionType |= 1;\r\n                idsAREC = idsAREC.insertInOrder(idRetiredAREC);\r\n            } else { \r\n                actionType |= 2;\r\n                uint256 idARECDetail = idRetiredAREC & (1<<62 - 1);                 // Remove the two msb tag bits \r\n\r\n                if (tag == 2) {\r\n                    idsAREC = idsAREC.insertInOrder(idARECDetail);\r\n                } else {\r\n                    OffsetDetail[] storage offsetDetails = OffsetDetails[idARECDetail];\r\n                    for (uint256 ind = 0; ind < offsetDetails.length; ind++) {\r\n                        idsAREC = idsAREC.insertInOrder(offsetDetails[ind].tokenId);\r\n                    }\r\n                }\r\n            } \r\n        }\r\n\r\n        return IArkreenBadgeImage(arkreenBadgeImage).getBadgeSVG(tokenId, offsetRecord, actionType, idsAREC);\r\n    }\r\n\r\n    function updateCID(uint256[] calldata tokenId, string[] calldata cid) external virtual onlyOwner {\r\n        require(tokenId.length == cid.length, \"'ARB: Wrong Data\");\r\n\r\n        for(uint256 index; index < tokenId.length; index++ ) {\r\n          cidBadge[tokenId[index]] = cid[index];\r\n        }\r\n    }    \r\n\r\n    function setBadgeImage(address newImage) external virtual onlyOwner {\r\n        require(newImage != address(0), 'ARB: Zero Address');\r\n        arkreenBadgeImage = IArkreenBadgeImage(newImage);\r\n    }       \r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. Miner Info is checked as the following rules:  \r\n     * A) Game miner cannot be transferred\r\n     * B) Only miner in Normal state can be transferred\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override (ERC721EnumerableUpgradeable) {\r\n        require(from == address(0), 'ARB: Transfer Not Allowed');\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n\r\n    function locked(uint256 tokenId) external view returns (bool){\r\n        require((tokenId > 0) && (tokenId <= totalSupply()), 'ARB: Wrong tokenId');\r\n        return true;  \r\n    }\r\n\r\n    // Add SBT interface(0.1.1)\r\n    // Add offset trace function (0.2.0)\r\n    function getVersion() external pure virtual returns (string memory) {\r\n        return \"0.2.0\";\r\n    }\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Address.sol)\n\npragma solidity ^0.8.1;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary AddressUpgradeable {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     *\n     * [IMPORTANT]\n     * ====\n     * You shouldn't rely on `isContract` to protect against flash loan attacks!\n     *\n     * Preventing calls from contracts is highly discouraged. It breaks composability, breaks support for smart wallets\n     * like Gnosis Safe, and does not provide security since it can be circumvented by calling from a contract\n     * constructor.\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize/address.code.length, which returns 0\n        // for contracts in construction, since the code is only stored at the end\n        // of the constructor execution.\n\n        return account.code.length > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n                /// @solidity memory-safe-assembly\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary StringsUpgradeable {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n    uint8 private constant _ADDRESS_LENGTH = 20;\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts an `address` with fixed length of 20 bytes to its not checksummed ASCII `string` hexadecimal representation.\n     */\n    function toHexString(address addr) internal pure returns (string memory) {\n        return toHexString(uint256(uint160(addr)), _ADDRESS_LENGTH);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/Ownable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which provides a basic access control mechanism, where\n * there is an account (an owner) that can be granted exclusive access to\n * specific functions.\n *\n * By default, the owner account will be the one that deploys the contract. This\n * can later be changed with {transferOwnership}.\n *\n * This module is used through inheritance. It will make available the modifier\n * `onlyOwner`, which can be applied to your functions to restrict their use to\n * the owner.\n */\nabstract contract OwnableUpgradeable is Initializable, ContextUpgradeable {\n    address private _owner;\n\n    event OwnershipTransferred(address indexed previousOwner, address indexed newOwner);\n\n    /**\n     * @dev Initializes the contract setting the deployer as the initial owner.\n     */\n    function __Ownable_init() internal onlyInitializing {\n        __Ownable_init_unchained();\n    }\n\n    function __Ownable_init_unchained() internal onlyInitializing {\n        _transferOwnership(_msgSender());\n    }\n\n    /**\n     * @dev Throws if called by any account other than the owner.\n     */\n    modifier onlyOwner() {\n        _checkOwner();\n        _;\n    }\n\n    /**\n     * @dev Returns the address of the current owner.\n     */\n    function owner() public view virtual returns (address) {\n        return _owner;\n    }\n\n    /**\n     * @dev Throws if the sender is not the owner.\n     */\n    function _checkOwner() internal view virtual {\n        require(owner() == _msgSender(), \"Ownable: caller is not the owner\");\n    }\n\n    /**\n     * @dev Leaves the contract without owner. It will not be possible to call\n     * `onlyOwner` functions anymore. Can only be called by the current owner.\n     *\n     * NOTE: Renouncing ownership will leave the contract without an owner,\n     * thereby removing any functionality that is only available to the owner.\n     */\n    function renounceOwnership() public virtual onlyOwner {\n        _transferOwnership(address(0));\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Can only be called by the current owner.\n     */\n    function transferOwnership(address newOwner) public virtual onlyOwner {\n        require(newOwner != address(0), \"Ownable: new owner is the zero address\");\n        _transferOwnership(newOwner);\n    }\n\n    /**\n     * @dev Transfers ownership of the contract to a new account (`newOwner`).\n     * Internal function without access restriction.\n     */\n    function _transferOwnership(address newOwner) internal virtual {\n        address oldOwner = _owner;\n        _owner = newOwner;\n        emit OwnershipTransferred(oldOwner, newOwner);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/ERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../ERC721Upgradeable.sol\";\nimport \"./IERC721EnumerableUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev This implements an optional extension of {ERC721} defined in the EIP that adds\n * enumerability of all the token ids in the contract as well as all token ids owned by each\n * account.\n */\nabstract contract ERC721EnumerableUpgradeable is Initializable, ERC721Upgradeable, IERC721EnumerableUpgradeable {\n    function __ERC721Enumerable_init() internal onlyInitializing {\n    }\n\n    function __ERC721Enumerable_init_unchained() internal onlyInitializing {\n    }\n    // Mapping from owner to list of owned token IDs\n    mapping(address => mapping(uint256 => uint256)) private _ownedTokens;\n\n    // Mapping from token ID to index of the owner tokens list\n    mapping(uint256 => uint256) private _ownedTokensIndex;\n\n    // Array with all token ids, used for enumeration\n    uint256[] private _allTokens;\n\n    // Mapping from token id to position in the allTokens array\n    mapping(uint256 => uint256) private _allTokensIndex;\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC721Upgradeable) returns (bool) {\n        return interfaceId == type(IERC721EnumerableUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenOfOwnerByIndex}.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721Upgradeable.balanceOf(owner), \"ERC721Enumerable: owner index out of bounds\");\n        return _ownedTokens[owner][index];\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _allTokens.length;\n    }\n\n    /**\n     * @dev See {IERC721Enumerable-tokenByIndex}.\n     */\n    function tokenByIndex(uint256 index) public view virtual override returns (uint256) {\n        require(index < ERC721EnumerableUpgradeable.totalSupply(), \"ERC721Enumerable: global index out of bounds\");\n        return _allTokens[index];\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual override {\n        super._beforeTokenTransfer(from, to, tokenId);\n\n        if (from == address(0)) {\n            _addTokenToAllTokensEnumeration(tokenId);\n        } else if (from != to) {\n            _removeTokenFromOwnerEnumeration(from, tokenId);\n        }\n        if (to == address(0)) {\n            _removeTokenFromAllTokensEnumeration(tokenId);\n        } else if (to != from) {\n            _addTokenToOwnerEnumeration(to, tokenId);\n        }\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's ownership-tracking data structures.\n     * @param to address representing the new owner of the given token ID\n     * @param tokenId uint256 ID of the token to be added to the tokens list of the given address\n     */\n    function _addTokenToOwnerEnumeration(address to, uint256 tokenId) private {\n        uint256 length = ERC721Upgradeable.balanceOf(to);\n        _ownedTokens[to][length] = tokenId;\n        _ownedTokensIndex[tokenId] = length;\n    }\n\n    /**\n     * @dev Private function to add a token to this extension's token tracking data structures.\n     * @param tokenId uint256 ID of the token to be added to the tokens list\n     */\n    function _addTokenToAllTokensEnumeration(uint256 tokenId) private {\n        _allTokensIndex[tokenId] = _allTokens.length;\n        _allTokens.push(tokenId);\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's ownership-tracking data structures. Note that\n     * while the token is not assigned a new owner, the `_ownedTokensIndex` mapping is _not_ updated: this allows for\n     * gas optimizations e.g. when performing a transfer operation (avoiding double writes).\n     * This has O(1) time complexity, but alters the order of the _ownedTokens array.\n     * @param from address representing the previous owner of the given token ID\n     * @param tokenId uint256 ID of the token to be removed from the tokens list of the given address\n     */\n    function _removeTokenFromOwnerEnumeration(address from, uint256 tokenId) private {\n        // To prevent a gap in from's tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = ERC721Upgradeable.balanceOf(from) - 1;\n        uint256 tokenIndex = _ownedTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary\n        if (tokenIndex != lastTokenIndex) {\n            uint256 lastTokenId = _ownedTokens[from][lastTokenIndex];\n\n            _ownedTokens[from][tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n            _ownedTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n        }\n\n        // This also deletes the contents at the last position of the array\n        delete _ownedTokensIndex[tokenId];\n        delete _ownedTokens[from][lastTokenIndex];\n    }\n\n    /**\n     * @dev Private function to remove a token from this extension's token tracking data structures.\n     * This has O(1) time complexity, but alters the order of the _allTokens array.\n     * @param tokenId uint256 ID of the token to be removed from the tokens list\n     */\n    function _removeTokenFromAllTokensEnumeration(uint256 tokenId) private {\n        // To prevent a gap in the tokens array, we store the last token in the index of the token to delete, and\n        // then delete the last slot (swap and pop).\n\n        uint256 lastTokenIndex = _allTokens.length - 1;\n        uint256 tokenIndex = _allTokensIndex[tokenId];\n\n        // When the token to delete is the last token, the swap operation is unnecessary. However, since this occurs so\n        // rarely (when the last minted token is burnt) that we still do the swap here to avoid the gas cost of adding\n        // an 'if' statement (like in _removeTokenFromOwnerEnumeration)\n        uint256 lastTokenId = _allTokens[lastTokenIndex];\n\n        _allTokens[tokenIndex] = lastTokenId; // Move the last token to the slot of the to-delete token\n        _allTokensIndex[lastTokenId] = tokenIndex; // Update the moved token's index\n\n        // This also deletes the contents at the last position of the array\n        delete _allTokensIndex[tokenId];\n        _allTokens.pop();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/utils/UUPSUpgradeable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../ERC1967/ERC1967UpgradeUpgradeable.sol\";\nimport \"./Initializable.sol\";\n\n/**\n * @dev An upgradeability mechanism designed for UUPS proxies. The functions included here can perform an upgrade of an\n * {ERC1967Proxy}, when this contract is set as the implementation behind such a proxy.\n *\n * A security mechanism ensures that an upgrade does not turn off upgradeability accidentally, although this risk is\n * reinstated if the upgrade retains upgradeability but removes the security mechanism, e.g. by replacing\n * `UUPSUpgradeable` with a custom implementation of upgrades.\n *\n * The {_authorizeUpgrade} function must be overridden to include access restriction to the upgrade mechanism.\n *\n * _Available since v4.1._\n */\nabstract contract UUPSUpgradeable is Initializable, IERC1822ProxiableUpgradeable, ERC1967UpgradeUpgradeable {\n    function __UUPSUpgradeable_init() internal onlyInitializing {\n    }\n\n    function __UUPSUpgradeable_init_unchained() internal onlyInitializing {\n    }\n    /// @custom:oz-upgrades-unsafe-allow state-variable-immutable state-variable-assignment\n    address private immutable __self = address(this);\n\n    /**\n     * @dev Check that the execution is being performed through a delegatecall call and that the execution context is\n     * a proxy contract with an implementation (as defined in ERC1967) pointing to self. This should only be the case\n     * for UUPS and transparent proxies that are using the current contract as their implementation. Execution of a\n     * function through ERC1167 minimal proxies (clones) would not normally pass this test, but is not guaranteed to\n     * fail.\n     */\n    modifier onlyProxy() {\n        require(address(this) != __self, \"Function must be called through delegatecall\");\n        require(_getImplementation() == __self, \"Function must be called through active proxy\");\n        _;\n    }\n\n    /**\n     * @dev Check that the execution is not being performed through a delegate call. This allows a function to be\n     * callable on the implementing contract but not through proxies.\n     */\n    modifier notDelegated() {\n        require(address(this) == __self, \"UUPSUpgradeable: must not be called through delegatecall\");\n        _;\n    }\n\n    /**\n     * @dev Implementation of the ERC1822 {proxiableUUID} function. This returns the storage slot used by the\n     * implementation. It is used to validate that the this implementation remains valid after an upgrade.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy. This is guaranteed by the `notDelegated` modifier.\n     */\n    function proxiableUUID() external view virtual override notDelegated returns (bytes32) {\n        return _IMPLEMENTATION_SLOT;\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeTo(address newImplementation) external virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, new bytes(0), false);\n    }\n\n    /**\n     * @dev Upgrade the implementation of the proxy to `newImplementation`, and subsequently execute the function call\n     * encoded in `data`.\n     *\n     * Calls {_authorizeUpgrade}.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function upgradeToAndCall(address newImplementation, bytes memory data) external payable virtual onlyProxy {\n        _authorizeUpgrade(newImplementation);\n        _upgradeToAndCallUUPS(newImplementation, data, true);\n    }\n\n    /**\n     * @dev Function that should revert when `msg.sender` is not authorized to upgrade the contract. Called by\n     * {upgradeTo} and {upgradeToAndCall}.\n     *\n     * Normally, this function will use an xref:access.adoc[access control] modifier such as {Ownable-onlyOwner}.\n     *\n     * ```solidity\n     * function _authorizeUpgrade(address) internal override onlyOwner {}\n     * ```\n     */\n    function _authorizeUpgrade(address newImplementation) internal virtual;\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/ArkreenBadgeStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./ArkreenBadgeType.sol\";  \nimport \"./interfaces/IArkreenBadgeImage.sol\";\n\nabstract contract ArkreenBadgeStorage {\n    string public baseURI;\n    uint256 public minOffsetAmount;\n\n    address public arkreenRegistry;                // contracts storing all miner's ownership        \n\n    /// @dev Counter of total offset action, also the id tracks the offset action\n    uint256 public offsetCounter;\n\n    /// @dev Total redeemed REC amount\n    uint256 public totalRedeemed;\n\n    /// @dev Total offset AREC amount registered in offset actions\n    uint256 public totalOffsetRegistered;\n\n    /// @dev Total offset AREC amount retired in AREC retiremment certificateion\n    uint256 public totalOffsetRetired;    \n      \n    /// @dev mapping from offsetCounter to OffsetAction data\n    mapping(uint256 => OffsetAction) public offsetActions;\n\n    /// @dev List all the offset action ids belonging to user\n    mapping(address => uint256[]) public userActions;\n\n    mapping(uint256 => OffsetRecord) public certificates;       // Retirement Badges\n\n    uint256 public partialARECID;                        // AREC NFT ID partialy offset\n    uint256 public partialAvailableAmount;               // Amount available for partial offset\n\n    uint256 public detailsCounter;\n    mapping(uint256 => OffsetDetail[]) public OffsetDetails;\n\n    mapping(address => uint256) public partialARECIDExt;            // AREC NFT ID already partialy offset, from REC Token to ID\n    mapping(address => uint256) public partialAvailableAmountExt;   // Amount available for partial offset, from REC Token to Amount\n\n    mapping(uint256 => string) public cidBadge; \n\n    IArkreenBadgeImage arkreenBadgeImage;\n}\n"
    },
    "contracts/interfaces/IPausable.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IPausable {\n    function paused() external view returns (bool);\n    function pause() external;\n    function unpause() external;\n}\n"
    },
    "contracts/interfaces/IArkreenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IArkreenRegistry {\n    function getArkreenMiner() external view returns (address);\n    function recIssuers(address) external view returns (uint256);\n    function getRECIssuance() external view returns (address);\n    function isRECIssuer(address) external view returns(bool);\n    function getRECToken(address, uint256) external view returns (address);\n    function tokenRECs(address) external view returns (address);  \n    function getArkreenRetirement() external view returns (address);  \n    function getAssetInfo(uint256) external view returns (address issuer, address tokenREC,\n                                    address tokenPay, uint128 rateToIssue, uint16 rateToLiquidize);\n}\n"
    },
    "contracts/interfaces/IArkreenRECIssuance.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"../ArkreenRECIssuanceType.sol\";\r\n\r\ninterface IArkreenRECIssuance {\r\n    function baseURI() external view returns (string memory);\r\n    function getRECData(uint256 tokenId) external view returns (RECData memory);\r\n    function getRECDataCore(uint256 tokenId) external view \r\n                            returns(address issuer, uint128 amountREC, uint8 status, uint16 idAsset); \r\n    function safeTransferFrom(address from, address to, uint256 tokenId) external;\r\n}\r\n"
    },
    "contracts/interfaces/IArkreenBadgeImage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '../ArkreenBadgeType.sol';\r\n\r\ninterface IArkreenBadgeImage {\r\n    function getBadgeSVG(\r\n        uint256 tokenId,\r\n        OffsetRecord calldata offsetRecord,\r\n        uint256 actionType,\r\n        uint256[] calldata idsOfAREC\r\n    ) external pure returns(string memory);                                \r\n}\r\n"
    },
    "contracts/interfaces/IERC5192.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IERC5192 {\n  /// @notice Emitted when the locking status is changed to locked.\n  /// @dev If a token is minted and the status is locked, this event should be emitted.\n  /// @param tokenId The identifier for a token.\n  event Locked(uint256 tokenId);\n\n  /// @notice Emitted when the locking status is changed to unlocked.\n  /// @dev If a token is minted and the status is unlocked, this event should be emitted.\n  /// @param tokenId The identifier for a token.\n  event Unlocked(uint256 tokenId);\n\n  /// @notice Returns the locking status of an Soulbound Token\n  /// @dev SBTs assigned to zero address are considered invalid, and queries\n  /// about them do throw.\n  /// @param tokenId The identifier for an SBT.\n  function locked(uint256 tokenId) external view returns (bool);\n}"
    },
    "contracts/ArkreenBadgeType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nstruct OffsetRecord {\n    address   offsetEntity;\n    address   beneficiary;\n    string    offsetEntityID;\n    string    beneficiaryID;\n    string    offsetMessage;\n    uint256   creationTime;\n    uint256   offsetTotalAmount;\n    uint256[] offsetIds;\n}\n/**\n * @dev Detailed offset info, both applicable for REC NFT and REC token.\n */\nstruct OffsetAction {\n    address offsetEntity;\n    address issuerREC;                    // the ERC20 token can be referred from registed issuer address\n    uint128 amount;\n    uint64  tokenId;                      // id of the REC NFT, = 0 for REC ERC20 token\n    uint56  createdAt;\n    bool    bClaimed;\n}\nstruct OffsetDetail {\n    uint64  tokenId;                      // id of the REC NFT, = 0 for REC ERC20 token\n    uint128 amount;\n}\n"
    },
    "contracts/libraries/MemArrays.sol": {
      "content": "// SPDX-License-Identifier: MIT\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to array types in memory\n */\nlibrary MemArrays {\n    /**\n     * @dev Insert the element into an array in memory in ascending order, and return the new array in memomry\n     */\n    function insertInOrder(uint256[] memory array, uint256 element) internal pure returns (uint256[] memory) {\n        uint256[] memory arrayNew = new uint256[](array.length + 1); \n\n        uint256 index = 0;\n        uint256 indexTo = 0;\n        while (index < array.length) {\n            if(element == array[index]) {                           // Already existed, return original\n                return array;\n            }\n            else if(element < array[index]) {                       // Insert here\n                arrayNew[indexTo] = element;\n                indexTo++;\n            }\n            arrayNew[indexTo] = array[index];                       // Copy one by one\n            indexTo++;\n            index++;\n        }\n        if(indexTo == index) {                                      // Not inserted, append as the last one                \n            arrayNew[indexTo] = element;\n        }\n        return arrayNew;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Context.sol)\n\npragma solidity ^0.8.0;\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\nabstract contract ContextUpgradeable is Initializable {\n    function __Context_init() internal onlyInitializing {\n    }\n\n    function __Context_init_unchained() internal onlyInitializing {\n    }\n    function _msgSender() internal view virtual returns (address) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes calldata) {\n        return msg.data;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/utils/Initializable.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../../utils/AddressUpgradeable.sol\";\n\n/**\n * @dev This is a base contract to aid in writing upgradeable contracts, or any kind of contract that will be deployed\n * behind a proxy. Since proxied contracts do not make use of a constructor, it's common to move constructor logic to an\n * external initializer function, usually called `initialize`. It then becomes necessary to protect this initializer\n * function so it can only be called once. The {initializer} modifier provided by this contract will have this effect.\n *\n * The initialization functions use a version number. Once a version number is used, it is consumed and cannot be\n * reused. This mechanism prevents re-execution of each \"step\" but allows the creation of new initialization steps in\n * case an upgrade adds a module that needs to be initialized.\n *\n * For example:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * contract MyToken is ERC20Upgradeable {\n *     function initialize() initializer public {\n *         __ERC20_init(\"MyToken\", \"MTK\");\n *     }\n * }\n * contract MyTokenV2 is MyToken, ERC20PermitUpgradeable {\n *     function initializeV2() reinitializer(2) public {\n *         __ERC20Permit_init(\"MyToken\");\n *     }\n * }\n * ```\n *\n * TIP: To avoid leaving the proxy in an uninitialized state, the initializer function should be called as early as\n * possible by providing the encoded function call as the `_data` argument to {ERC1967Proxy-constructor}.\n *\n * CAUTION: When used with inheritance, manual care must be taken to not invoke a parent initializer twice, or to ensure\n * that all initializers are idempotent. This is not verified automatically as constructors are by Solidity.\n *\n * [CAUTION]\n * ====\n * Avoid leaving a contract uninitialized.\n *\n * An uninitialized contract can be taken over by an attacker. This applies to both a proxy and its implementation\n * contract, which may impact the proxy. To prevent the implementation contract from being used, you should invoke\n * the {_disableInitializers} function in the constructor to automatically lock it when it is deployed:\n *\n * [.hljs-theme-light.nopadding]\n * ```\n * /// @custom:oz-upgrades-unsafe-allow constructor\n * constructor() {\n *     _disableInitializers();\n * }\n * ```\n * ====\n */\nabstract contract Initializable {\n    /**\n     * @dev Indicates that the contract has been initialized.\n     * @custom:oz-retyped-from bool\n     */\n    uint8 private _initialized;\n\n    /**\n     * @dev Indicates that the contract is in the process of being initialized.\n     */\n    bool private _initializing;\n\n    /**\n     * @dev Triggered when the contract has been initialized or reinitialized.\n     */\n    event Initialized(uint8 version);\n\n    /**\n     * @dev A modifier that defines a protected initializer function that can be invoked at most once. In its scope,\n     * `onlyInitializing` functions can be used to initialize parent contracts. Equivalent to `reinitializer(1)`.\n     */\n    modifier initializer() {\n        bool isTopLevelCall = !_initializing;\n        require(\n            (isTopLevelCall && _initialized < 1) || (!AddressUpgradeable.isContract(address(this)) && _initialized == 1),\n            \"Initializable: contract is already initialized\"\n        );\n        _initialized = 1;\n        if (isTopLevelCall) {\n            _initializing = true;\n        }\n        _;\n        if (isTopLevelCall) {\n            _initializing = false;\n            emit Initialized(1);\n        }\n    }\n\n    /**\n     * @dev A modifier that defines a protected reinitializer function that can be invoked at most once, and only if the\n     * contract hasn't been initialized to a greater version before. In its scope, `onlyInitializing` functions can be\n     * used to initialize parent contracts.\n     *\n     * `initializer` is equivalent to `reinitializer(1)`, so a reinitializer may be used after the original\n     * initialization step. This is essential to configure modules that are added through upgrades and that require\n     * initialization.\n     *\n     * Note that versions can jump in increments greater than 1; this implies that if multiple reinitializers coexist in\n     * a contract, executing them in the right order is up to the developer or operator.\n     */\n    modifier reinitializer(uint8 version) {\n        require(!_initializing && _initialized < version, \"Initializable: contract is already initialized\");\n        _initialized = version;\n        _initializing = true;\n        _;\n        _initializing = false;\n        emit Initialized(version);\n    }\n\n    /**\n     * @dev Modifier to protect an initialization function so that it can only be invoked by functions with the\n     * {initializer} and {reinitializer} modifiers, directly or indirectly.\n     */\n    modifier onlyInitializing() {\n        require(_initializing, \"Initializable: contract is not initializing\");\n        _;\n    }\n\n    /**\n     * @dev Locks the contract, preventing any future reinitialization. This cannot be part of an initializer call.\n     * Calling this in the constructor of a contract will prevent that contract from being initialized or reinitialized\n     * to any version. It is recommended to use this to lock implementation contracts that are designed to be called\n     * through proxies.\n     */\n    function _disableInitializers() internal virtual {\n        require(!_initializing, \"Initializable: contract is initializing\");\n        if (_initialized < type(uint8).max) {\n            _initialized = type(uint8).max;\n            emit Initialized(type(uint8).max);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/ERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/ERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC721Upgradeable.sol\";\nimport \"./IERC721ReceiverUpgradeable.sol\";\nimport \"./extensions/IERC721MetadataUpgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../utils/StringsUpgradeable.sol\";\nimport \"../../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of https://eips.ethereum.org/EIPS/eip-721[ERC721] Non-Fungible Token Standard, including\n * the Metadata extension, but not including the Enumerable extension, which is available separately as\n * {ERC721Enumerable}.\n */\ncontract ERC721Upgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, IERC721Upgradeable, IERC721MetadataUpgradeable {\n    using AddressUpgradeable for address;\n    using StringsUpgradeable for uint256;\n\n    // Token name\n    string private _name;\n\n    // Token symbol\n    string private _symbol;\n\n    // Mapping from token ID to owner address\n    mapping(uint256 => address) private _owners;\n\n    // Mapping owner address to token count\n    mapping(address => uint256) private _balances;\n\n    // Mapping from token ID to approved address\n    mapping(uint256 => address) private _tokenApprovals;\n\n    // Mapping from owner to operator approvals\n    mapping(address => mapping(address => bool)) private _operatorApprovals;\n\n    /**\n     * @dev Initializes the contract by setting a `name` and a `symbol` to the token collection.\n     */\n    function __ERC721_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC721_init_unchained(name_, symbol_);\n    }\n\n    function __ERC721_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(ERC165Upgradeable, IERC165Upgradeable) returns (bool) {\n        return\n            interfaceId == type(IERC721Upgradeable).interfaceId ||\n            interfaceId == type(IERC721MetadataUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IERC721-balanceOf}.\n     */\n    function balanceOf(address owner) public view virtual override returns (uint256) {\n        require(owner != address(0), \"ERC721: address zero is not a valid owner\");\n        return _balances[owner];\n    }\n\n    /**\n     * @dev See {IERC721-ownerOf}.\n     */\n    function ownerOf(uint256 tokenId) public view virtual override returns (address) {\n        address owner = _owners[tokenId];\n        require(owner != address(0), \"ERC721: invalid token ID\");\n        return owner;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-symbol}.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev See {IERC721Metadata-tokenURI}.\n     */\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\n        _requireMinted(tokenId);\n\n        string memory baseURI = _baseURI();\n        return bytes(baseURI).length > 0 ? string(abi.encodePacked(baseURI, tokenId.toString())) : \"\";\n    }\n\n    /**\n     * @dev Base URI for computing {tokenURI}. If set, the resulting URI for each\n     * token will be the concatenation of the `baseURI` and the `tokenId`. Empty\n     * by default, can be overridden in child contracts.\n     */\n    function _baseURI() internal view virtual returns (string memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IERC721-approve}.\n     */\n    function approve(address to, uint256 tokenId) public virtual override {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        require(to != owner, \"ERC721: approval to current owner\");\n\n        require(\n            _msgSender() == owner || isApprovedForAll(owner, _msgSender()),\n            \"ERC721: approve caller is not token owner nor approved for all\"\n        );\n\n        _approve(to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-getApproved}.\n     */\n    function getApproved(uint256 tokenId) public view virtual override returns (address) {\n        _requireMinted(tokenId);\n\n        return _tokenApprovals[tokenId];\n    }\n\n    /**\n     * @dev See {IERC721-setApprovalForAll}.\n     */\n    function setApprovalForAll(address operator, bool approved) public virtual override {\n        _setApprovalForAll(_msgSender(), operator, approved);\n    }\n\n    /**\n     * @dev See {IERC721-isApprovedForAll}.\n     */\n    function isApprovedForAll(address owner, address operator) public view virtual override returns (bool) {\n        return _operatorApprovals[owner][operator];\n    }\n\n    /**\n     * @dev See {IERC721-transferFrom}.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        //solhint-disable-next-line max-line-length\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n\n        _transfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) public virtual override {\n        safeTransferFrom(from, to, tokenId, \"\");\n    }\n\n    /**\n     * @dev See {IERC721-safeTransferFrom}.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) public virtual override {\n        require(_isApprovedOrOwner(_msgSender(), tokenId), \"ERC721: caller is not token owner nor approved\");\n        _safeTransfer(from, to, tokenId, data);\n    }\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * `data` is additional data, it has no specified format and it is sent in call to `to`.\n     *\n     * This internal function is equivalent to {safeTransferFrom}, and can be used to e.g.\n     * implement alternative mechanisms to perform token transfer, such as signature-based.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeTransfer(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _transfer(from, to, tokenId);\n        require(_checkOnERC721Received(from, to, tokenId, data), \"ERC721: transfer to non ERC721Receiver implementer\");\n    }\n\n    /**\n     * @dev Returns whether `tokenId` exists.\n     *\n     * Tokens can be managed by their owner or approved accounts via {approve} or {setApprovalForAll}.\n     *\n     * Tokens start existing when they are minted (`_mint`),\n     * and stop existing when they are burned (`_burn`).\n     */\n    function _exists(uint256 tokenId) internal view virtual returns (bool) {\n        return _owners[tokenId] != address(0);\n    }\n\n    /**\n     * @dev Returns whether `spender` is allowed to manage `tokenId`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function _isApprovedOrOwner(address spender, uint256 tokenId) internal view virtual returns (bool) {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n        return (spender == owner || isApprovedForAll(owner, spender) || getApproved(tokenId) == spender);\n    }\n\n    /**\n     * @dev Safely mints `tokenId` and transfers it to `to`.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _safeMint(address to, uint256 tokenId) internal virtual {\n        _safeMint(to, tokenId, \"\");\n    }\n\n    /**\n     * @dev Same as {xref-ERC721-_safeMint-address-uint256-}[`_safeMint`], with an additional `data` parameter which is\n     * forwarded in {IERC721Receiver-onERC721Received} to contract recipients.\n     */\n    function _safeMint(\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) internal virtual {\n        _mint(to, tokenId);\n        require(\n            _checkOnERC721Received(address(0), to, tokenId, data),\n            \"ERC721: transfer to non ERC721Receiver implementer\"\n        );\n    }\n\n    /**\n     * @dev Mints `tokenId` and transfers it to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {_safeMint} whenever possible\n     *\n     * Requirements:\n     *\n     * - `tokenId` must not exist.\n     * - `to` cannot be the zero address.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _mint(address to, uint256 tokenId) internal virtual {\n        require(to != address(0), \"ERC721: mint to the zero address\");\n        require(!_exists(tokenId), \"ERC721: token already minted\");\n\n        _beforeTokenTransfer(address(0), to, tokenId);\n\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(address(0), to, tokenId);\n\n        _afterTokenTransfer(address(0), to, tokenId);\n    }\n\n    /**\n     * @dev Destroys `tokenId`.\n     * The approval is cleared when the token is burned.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _burn(uint256 tokenId) internal virtual {\n        address owner = ERC721Upgradeable.ownerOf(tokenId);\n\n        _beforeTokenTransfer(owner, address(0), tokenId);\n\n        // Clear approvals\n        _approve(address(0), tokenId);\n\n        _balances[owner] -= 1;\n        delete _owners[tokenId];\n\n        emit Transfer(owner, address(0), tokenId);\n\n        _afterTokenTransfer(owner, address(0), tokenId);\n    }\n\n    /**\n     * @dev Transfers `tokenId` from `from` to `to`.\n     *  As opposed to {transferFrom}, this imposes no restrictions on msg.sender.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     *\n     * Emits a {Transfer} event.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {\n        require(ERC721Upgradeable.ownerOf(tokenId) == from, \"ERC721: transfer from incorrect owner\");\n        require(to != address(0), \"ERC721: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, tokenId);\n\n        // Clear approvals from the previous owner\n        _approve(address(0), tokenId);\n\n        _balances[from] -= 1;\n        _balances[to] += 1;\n        _owners[tokenId] = to;\n\n        emit Transfer(from, to, tokenId);\n\n        _afterTokenTransfer(from, to, tokenId);\n    }\n\n    /**\n     * @dev Approve `to` to operate on `tokenId`\n     *\n     * Emits an {Approval} event.\n     */\n    function _approve(address to, uint256 tokenId) internal virtual {\n        _tokenApprovals[tokenId] = to;\n        emit Approval(ERC721Upgradeable.ownerOf(tokenId), to, tokenId);\n    }\n\n    /**\n     * @dev Approve `operator` to operate on all of `owner` tokens\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function _setApprovalForAll(\n        address owner,\n        address operator,\n        bool approved\n    ) internal virtual {\n        require(owner != operator, \"ERC721: approve to caller\");\n        _operatorApprovals[owner][operator] = approved;\n        emit ApprovalForAll(owner, operator, approved);\n    }\n\n    /**\n     * @dev Reverts if the `tokenId` has not been minted yet.\n     */\n    function _requireMinted(uint256 tokenId) internal view virtual {\n        require(_exists(tokenId), \"ERC721: invalid token ID\");\n    }\n\n    /**\n     * @dev Internal function to invoke {IERC721Receiver-onERC721Received} on a target address.\n     * The call is not executed if the target address is not a contract.\n     *\n     * @param from address representing the previous owner of the given token ID\n     * @param to target address that will receive the tokens\n     * @param tokenId uint256 ID of the token to be transferred\n     * @param data bytes optional data to send along with the call\n     * @return bool whether the call correctly returned the expected magic value\n     */\n    function _checkOnERC721Received(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes memory data\n    ) private returns (bool) {\n        if (to.isContract()) {\n            try IERC721ReceiverUpgradeable(to).onERC721Received(_msgSender(), from, tokenId, data) returns (bytes4 retval) {\n                return retval == IERC721ReceiverUpgradeable.onERC721Received.selector;\n            } catch (bytes memory reason) {\n                if (reason.length == 0) {\n                    revert(\"ERC721: transfer to non ERC721Receiver implementer\");\n                } else {\n                    /// @solidity memory-safe-assembly\n                    assembly {\n                        revert(add(32, reason), mload(reason))\n                    }\n                }\n            }\n        } else {\n            return true;\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any token transfer. This includes minting\n     * and burning.\n     *\n     * Calling conditions:\n     *\n     * - When `from` and `to` are both non-zero, ``from``'s `tokenId` will be\n     * transferred to `to`.\n     * - When `from` is zero, `tokenId` will be minted for `to`.\n     * - When `to` is zero, ``from``'s `tokenId` will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 tokenId\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[44] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721EnumerableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC721/extensions/IERC721Enumerable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721EnumerableUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the total amount of tokens stored by the contract.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID owned by `owner` at a given `index` of its token list.\n     * Use along with {balanceOf} to enumerate all of ``owner``'s tokens.\n     */\n    function tokenOfOwnerByIndex(address owner, uint256 index) external view returns (uint256);\n\n    /**\n     * @dev Returns a token ID at a given `index` of all the tokens stored by the contract.\n     * Use along with {totalSupply} to enumerate all tokens.\n     */\n    function tokenByIndex(uint256 index) external view returns (uint256);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC721/IERC721.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev Required interface of an ERC721 compliant contract.\n */\ninterface IERC721Upgradeable is IERC165Upgradeable {\n    /**\n     * @dev Emitted when `tokenId` token is transferred from `from` to `to`.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables `approved` to manage the `tokenId` token.\n     */\n    event Approval(address indexed owner, address indexed approved, uint256 indexed tokenId);\n\n    /**\n     * @dev Emitted when `owner` enables or disables (`approved`) `operator` to manage all of its assets.\n     */\n    event ApprovalForAll(address indexed owner, address indexed operator, bool approved);\n\n    /**\n     * @dev Returns the number of tokens in ``owner``'s account.\n     */\n    function balanceOf(address owner) external view returns (uint256 balance);\n\n    /**\n     * @dev Returns the owner of the `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function ownerOf(uint256 tokenId) external view returns (address owner);\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId,\n        bytes calldata data\n    ) external;\n\n    /**\n     * @dev Safely transfers `tokenId` token from `from` to `to`, checking first that contract recipients\n     * are aware of the ERC721 protocol to prevent tokens from being forever locked.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must exist and be owned by `from`.\n     * - If the caller is not `from`, it must have been allowed to move this token by either {approve} or {setApprovalForAll}.\n     * - If `to` refers to a smart contract, it must implement {IERC721Receiver-onERC721Received}, which is called upon a safe transfer.\n     *\n     * Emits a {Transfer} event.\n     */\n    function safeTransferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Transfers `tokenId` token from `from` to `to`.\n     *\n     * WARNING: Usage of this method is discouraged, use {safeTransferFrom} whenever possible.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `tokenId` token must be owned by `from`.\n     * - If the caller is not `from`, it must be approved to move this token by either {approve} or {setApprovalForAll}.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 tokenId\n    ) external;\n\n    /**\n     * @dev Gives permission to `to` to transfer `tokenId` token to another account.\n     * The approval is cleared when the token is transferred.\n     *\n     * Only a single account can be approved at a time, so approving the zero address clears previous approvals.\n     *\n     * Requirements:\n     *\n     * - The caller must own the token or be an approved operator.\n     * - `tokenId` must exist.\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address to, uint256 tokenId) external;\n\n    /**\n     * @dev Approve or remove `operator` as an operator for the caller.\n     * Operators can call {transferFrom} or {safeTransferFrom} for any token owned by the caller.\n     *\n     * Requirements:\n     *\n     * - The `operator` cannot be the caller.\n     *\n     * Emits an {ApprovalForAll} event.\n     */\n    function setApprovalForAll(address operator, bool _approved) external;\n\n    /**\n     * @dev Returns the account approved for `tokenId` token.\n     *\n     * Requirements:\n     *\n     * - `tokenId` must exist.\n     */\n    function getApproved(uint256 tokenId) external view returns (address operator);\n\n    /**\n     * @dev Returns if the `operator` is allowed to manage all of the assets of `owner`.\n     *\n     * See {setApprovalForAll}\n     */\n    function isApprovedForAll(address owner, address operator) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/IERC721ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC721/IERC721Receiver.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title ERC721 token receiver interface\n * @dev Interface for any contract that wants to support safeTransfers\n * from ERC721 asset contracts.\n */\ninterface IERC721ReceiverUpgradeable {\n    /**\n     * @dev Whenever an {IERC721} `tokenId` token is transferred to this contract via {IERC721-safeTransferFrom}\n     * by `operator` from `from`, this function is called.\n     *\n     * It must return its Solidity selector to confirm the token transfer.\n     * If any other value is returned or the interface is not implemented by the recipient, the transfer will be reverted.\n     *\n     * The selector can be obtained in Solidity with `IERC721Receiver.onERC721Received.selector`.\n     */\n    function onERC721Received(\n        address operator,\n        address from,\n        uint256 tokenId,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC721/extensions/IERC721MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC721/extensions/IERC721Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC721Upgradeable.sol\";\n\n/**\n * @title ERC-721 Non-Fungible Token Standard, optional metadata extension\n * @dev See https://eips.ethereum.org/EIPS/eip-721\n */\ninterface IERC721MetadataUpgradeable is IERC721Upgradeable {\n    /**\n     * @dev Returns the token collection name.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the token collection symbol.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the Uniform Resource Identifier (URI) for `tokenId` token.\n     */\n    function tokenURI(uint256 tokenId) external view returns (string memory);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/ERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/ERC165.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC165Upgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC165} interface.\n *\n * Contracts that want to implement ERC165 should inherit from this contract and override {supportsInterface} to check\n * for the additional interface id that will be supported. For example:\n *\n * ```solidity\n * function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n *     return interfaceId == type(MyInterface).interfaceId || super.supportsInterface(interfaceId);\n * }\n * ```\n *\n * Alternatively, {ERC165Storage} provides an easier to use but more expensive implementation.\n */\nabstract contract ERC165Upgradeable is Initializable, IERC165Upgradeable {\n    function __ERC165_init() internal onlyInitializing {\n    }\n\n    function __ERC165_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IERC165Upgradeable).interfaceId;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/introspection/IERC165Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/introspection/IERC165.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC165 standard, as defined in the\n * https://eips.ethereum.org/EIPS/eip-165[EIP].\n *\n * Implementers can declare support of contract interfaces, which can then be\n * queried by others ({ERC165Checker}).\n *\n * For an implementation, see {ERC165}.\n */\ninterface IERC165Upgradeable {\n    /**\n     * @dev Returns true if this contract implements the interface defined by\n     * `interfaceId`. See the corresponding\n     * https://eips.ethereum.org/EIPS/eip-165#how-interfaces-are-identified[EIP section]\n     * to learn more about how these ids are created.\n     *\n     * This function call must use less than 30 000 gas.\n     */\n    function supportsInterface(bytes4 interfaceId) external view returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/interfaces/draft-IERC1822Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822ProxiableUpgradeable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/ERC1967/ERC1967UpgradeUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeaconUpgradeable.sol\";\nimport \"../../interfaces/draft-IERC1822Upgradeable.sol\";\nimport \"../../utils/AddressUpgradeable.sol\";\nimport \"../../utils/StorageSlotUpgradeable.sol\";\nimport \"../utils/Initializable.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967UpgradeUpgradeable is Initializable {\n    function __ERC1967Upgrade_init() internal onlyInitializing {\n    }\n\n    function __ERC1967Upgrade_init_unchained() internal onlyInitializing {\n    }\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(AddressUpgradeable.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlotUpgradeable.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlotUpgradeable.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822ProxiableUpgradeable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlotUpgradeable.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(AddressUpgradeable.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            AddressUpgradeable.isContract(IBeaconUpgradeable(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlotUpgradeable.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            _functionDelegateCall(IBeaconUpgradeable(newBeacon).implementation(), data);\n        }\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function _functionDelegateCall(address target, bytes memory data) private returns (bytes memory) {\n        require(AddressUpgradeable.isContract(target), \"Address: delegate call to non-contract\");\n\n        // solhint-disable-next-line avoid-low-level-calls\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return AddressUpgradeable.verifyCallResult(success, returndata, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/proxy/beacon/IBeaconUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeaconUpgradeable {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/StorageSlotUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlotUpgradeable {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "contracts/ArkreenRECIssuanceType.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nenum RECStatus {\n  Pending,            // 0\n  Rejected,           // 1\n  Cancelled,          // 2\n  Certified,          // 3\n  Retired,            // 4\n  Liquidized          // 5\n}\n\nstruct Signature {\n    address     token;\n    uint256     value;\n    uint256     deadline;  \n    uint8       v;\n    bytes32     r;\n    bytes32     s;              \n}\n\nstruct PayInfo {\n    address     token;\n    uint256     value;\n}\n\nstruct RECRequest {\n    address   issuer;\n    uint32    startTime;\n    uint32    endTime;\n    uint128   amountREC;\n    string    cID;\n    string    region;      \n    string    url;\n    string    memo;\n} \n\nstruct RECData {\n    address   issuer;\n    string    serialNumber;\n    address   minter;\n    uint32    startTime;\n    uint32    endTime;\n    uint128   amountREC;\n    uint8     status;\n    string    cID;\n    string    region;\n    string    url;\n    string    memo;\n    uint16    idAsset;\n}\n\nstruct ARECAmount {\n    uint256   ARECID;\n    uint128   amountREC;\n}\n\nstruct RECMintPrice {\n    address   token;\n    uint256   value;\n}\n"
    },
    "contracts/ArkreenBadgeImage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nimport \"./libraries/FormattedStrings.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\nimport \"./libraries/BytesLib.sol\";\r\n\r\nimport \"./ArkreenBadgeType.sol\";\r\n\r\n// Import this file to use console.log\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract ArkreenBadgeImage {\r\n \r\n    using Strings for uint128;\r\n    using Strings for uint256;\r\n    using Strings for address;\r\n    using FormattedStrings for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    function _decimalTruncate(string memory _str, uint256 decimalDigits) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(_str);\r\n        uint256 dotIndex = strBytes.length;\r\n\r\n        for (uint256 i = 0; i < strBytes.length; i++) {\r\n            if (strBytes[i] == \".\") {\r\n\r\n                if(i + decimalDigits + 1 < strBytes.length){\r\n                    dotIndex = i + decimalDigits + 1;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory result = new bytes(dotIndex);\r\n        for (uint256 i = 0; i < dotIndex; i++) {\r\n            result[i] = strBytes[i];\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n\r\n    function toFixedPoint(uint256 value, uint256 decimal) internal pure returns (string memory) {\r\n        require(decimal <= 18, \"Strings: Fixed point too long\");\r\n        string memory valueString = value.toString();\r\n        \r\n        if (decimal == 0) return valueString;\r\n\r\n        bytes memory valueBytes = bytes(valueString);\r\n        uint256 length = valueBytes.length;\r\n\r\n        bytes memory resulInBytes;\r\n        if (length > decimal) {\r\n            resulInBytes = valueBytes.slice(0, length - decimal).concat(\".\")                // Integer part\r\n                                .concat(valueBytes.slice(length - decimal, decimal));       // Decimal part\r\n        } else {\r\n            resulInBytes = bytes(\"0.000000000000000000\").slice(0, decimal + 2 - length)     // Maximum 18 decimals\r\n                                .concat(valueBytes);\r\n        }\r\n        return string(resulInBytes);\r\n    }\r\n\r\n    function getBadgeSVG(\r\n        uint256 tokenId,\r\n        OffsetRecord calldata offsetRecord,\r\n        uint256 actionType,\r\n        uint256[] calldata idsOfAREC\r\n    ) external pure returns(string memory) {\r\n\r\n        bytes memory dataURI;\r\n        string memory tokenString = tokenId.toString();\r\n\r\n        {\r\n            string memory energyInBadge = _decimalTruncate(toFixedPoint(offsetRecord.offsetTotalAmount, 9), 3);\r\n            address beneficiary = offsetRecord.beneficiary;\r\n            if (beneficiary == address(0))  beneficiary = offsetRecord.offsetEntity;\r\n\r\n            string memory svgData = getBadgeSVGImage(beneficiary.toHexString(), energyInBadge);\r\n\r\n            dataURI = abi.encodePacked(\r\n                            '{\"name\":\"ArkreenClimateBadge #',\r\n                            tokenString,\r\n                            '\",\"description\":\"',\r\n                            'Proof of the climate actions for carbon offset.',\r\n                            '\",\"image\":\"data:image/svg+xml;base64,',\r\n                            svgData,\r\n                            '\",\"attributes\":[{\"display_type\":\"number\",\"trait_type\":\"AREC Badge ID\",\"value\":',\r\n                            tokenString,\r\n                            '},{\"trait_type\":\"Renewable Energy\",\"value\":\"',\r\n                            energyInBadge,\r\n                            ' kWh\"},{\"display_type\":\"date\",\"trait_type\":\"AREC Badge Time\",\"value\":',\r\n                            offsetRecord.creationTime.toString(),\r\n                            '},'       \r\n                        );\r\n        }\r\n\r\n        {\r\n            string memory typeAction;\r\n            if (actionType == 1) { \r\n                typeAction ='Redeem';\r\n            } else if (actionType == 2) {\r\n                typeAction = 'Offset';\r\n            } else {\r\n                typeAction = 'Redeem,Offset';\r\n            }\r\n\r\n            dataURI = abi.encodePacked(dataURI,\r\n                            '{\"trait_type\":\"Climate Action Type\",\"value\":\"',\r\n                            typeAction,\r\n                            '\"},{\"display_type\":\"number\",\"trait_type\":\"Climate Action Number\",\"value\":',\r\n                            offsetRecord.offsetIds.length.toString(),\r\n                            '},'\r\n                        );\r\n        }\r\n\r\n        {\r\n            bytes memory actionIds;\r\n            for (uint256 index=0; index < offsetRecord.offsetIds.length; index++) {\r\n                if (index == 0) actionIds = bytes(offsetRecord.offsetIds[0].toString());\r\n                else actionIds = actionIds.concat(\",\").concat(bytes(offsetRecord.offsetIds[index].toString()));\r\n            }\r\n        \r\n            dataURI = abi.encodePacked(dataURI,\r\n                            '{\"trait_type\":\"Climate Action IDs\",\"value\":\"',\r\n                            string(actionIds),\r\n                            '\"},'\r\n                        );\r\n        }\r\n\r\n        {\r\n            bytes memory arecNftIds;\r\n            for (uint256 index=0; index < idsOfAREC.length; index++) {\r\n                if (index==0) arecNftIds = bytes(idsOfAREC[0].toString());\r\n                else arecNftIds = arecNftIds.concat(\",\").concat(bytes(idsOfAREC[index].toString()));\r\n            }\r\n        \r\n            dataURI = abi.encodePacked(dataURI,\r\n                            '{\"trait_type\":\"Retired AREC NFTs\",\"value\":\"',\r\n                            string(arecNftIds),\r\n                            '\"},'\r\n                        );\r\n        }\r\n\r\n        {\r\n            bytes memory bytesBadgeFile = 'https://arec.arkreen.com/badges/AREC_Badge_000000.pdf';\r\n            bytes memory tokenInBytes = bytes(tokenString);\r\n            bytes memory BadgeFile = bytesBadgeFile.slice(0, bytesBadgeFile.length - 4 - tokenInBytes.length)\r\n                                        .concat(tokenInBytes.concat('.pdf'));\r\n\r\n            dataURI = abi.encodePacked(dataURI,\r\n                            '{\"trait_type\":\"AREC Badge File\",\"value\":\"',\r\n                            string(BadgeFile),\r\n                            '\"}]}'\r\n                        );\r\n        }\r\n\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(dataURI)));\r\n    }\r\n\r\n    function getBadgeSVGImage(string memory beneficiary, string memory energyInBadge) internal pure returns(string memory) {\r\n\r\n        bytes memory imgBytes = abi.encodePacked(\r\n\r\n            '<svg viewBox=\"0 0 400 400\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">'\r\n                '<defs>'\r\n                    '<path id=\"center\" d=\"M0 20,400,20\" stroke=\"white\" fill=\"none\"/>'\r\n                    '<path id=\"top\" transform=\"translate(140,40)\" d=\"M -70 162 A 50 50 0 1 1 190 162\"/>'\r\n                    '<path id=\"address\" transform=\"translate(140,40)\" d=\"M -98 160 A 50 50 0 1 0 218 160\"/>'\r\n                '</defs>'\r\n                '<path'\r\n                    ' d=\"M178.596 12.8029C191.891 5.3451 208.109 5.34509 221.404 12.8029L236.374 21.2005C242.954 24.8916'\r\n                    ' 250.355 26.8745 257.899 26.968L275.062 27.1805C290.305 27.3693 304.35 35.4785 312.135 48.5846L320.901'\r\n                    ' 63.3422C324.754 69.8288 330.171 75.2463 336.658 79.0992L351.415 87.865C364.522 95.6498 372.631 109.695'\r\n                    ' 372.819 124.938L373.032 142.101C373.125 149.645 375.108 157.046 378.8 163.626L387.197 178.596C394.655'\r\n                    ' 191.891 394.655 208.109 387.197 221.404L378.8 236.374C375.108 242.954 373.125 250.355 373.032'\r\n                    ' 257.899L372.819 275.062C372.631 290.305 364.522 304.35 351.415 312.135L336.658 320.901C330.171'\r\n                    ' 324.754 324.754 330.171 320.901 336.658L312.135 351.415C304.35 364.522 290.305 372.631 275.062'\r\n                    ' 372.819L257.899 373.032C250.355 373.125 242.954 375.108 236.374 378.8L221.404 387.197C208.109'\r\n                    ' 394.655 191.891 394.655 178.596 387.197L163.626 378.8C157.046 375.108 149.645 373.125 142.101'\r\n                    ' 373.032L124.938 372.819C109.695 372.631 95.6498 364.522 87.865 351.415L79.0992 336.658C75.2463'\r\n                    ' 330.171 69.8288 324.754 63.3422 320.901L48.5846 312.135C35.4785 304.35 27.3693 290.305 27.1805'\r\n                    ' 275.062L26.968 257.899C26.8745 250.355 24.8916 242.954 21.2005 236.374L12.8029 221.404C5.3451'\r\n                    ' 208.109 5.34509 191.891 12.8029 178.596L21.2005 163.626C24.8916 157.046 26.8745 149.645 26.968'\r\n                    ' 142.101L27.1805 124.938C27.3693 109.695 35.4785 95.6498 48.5846 87.865L63.3422 79.0992C69.8288'\r\n                    ' 75.2463 75.2463 69.8288 79.0992 63.3422L87.865 48.5846C95.6498 35.4785 109.695 27.3693 124.938'\r\n                    ' 27.1805L142.101 26.968C149.645 26.8745 157.046 24.8916 163.626 21.2005L178.596 12.8029Z\"'\r\n                    ' fill=\"#28282D\" stroke=\"#404047\" strokeWidth=\"1.38889\"/>'\r\n                '<circle cx=\"200\" cy=\"200\" r=\"166.667\" fill=\"#28282D\" stroke=\"#34C46E\" strokeWidth=\"2.66667\"/>'\r\n                '<rect x=\"88\" y=\"88\" width=\"224\" height=\"224\" rx=\"112\" fill=\"#2F2F34\"/>'\r\n                '<path'\r\n                    ' d=\"M198.826 167.539L182.368 193.898C180.788 196.429 182.606 199.719 185.588 199.719H244.003C247.357 199.719'\r\n                    ' 249.403 196.024 247.626 193.175L205.67 125.971C203.066 121.801 197.007 121.801 194.396 125.971L151.99'\r\n                    ' 193.898C150.409 196.429 152.227 199.719 155.209 199.719H164.692C165.175 199.719 165.65 199.596 166.072'\r\n                    ' 199.361C166.495 199.127 166.851 198.789 167.106 198.379L198.826 147.565C198.954 147.36 199.132 147.191'\r\n                    ' 199.343 147.074C199.555 146.956 199.792 146.895 200.034 146.895C200.276 146.895 200.514 146.956 200.725'\r\n                    ' 147.074C200.936 147.191 201.114 147.36 201.242 147.565L222.943 182.326C223.079 182.542 223.154 182.791'\r\n                    ' 223.162 183.046C223.169 183.301 223.108 183.553 222.985 183.776C222.861 184 222.68 184.186 222.461'\r\n                    ' 184.315C222.241 184.445 221.991 184.513 221.736 184.512H208.711C208.457 184.511 208.209 184.442 207.991'\r\n                    ' 184.313C207.773 184.183 207.593 183.997 207.471 183.775C207.348 183.553 207.287 183.301 207.294'\r\n                    ' 183.048C207.301 182.794 207.376 182.546 207.51 182.331L208.519 180.711C208.66 180.484 208.735 180.222'\r\n                    ' 208.735 179.955C208.735 179.688 208.66 179.426 208.519 179.2L201.242 167.544C201.115 167.339 200.937'\r\n                    ' 167.169 200.726 167.051C200.515 166.933 200.277 166.871 200.035 166.871C199.794 166.87 199.556 166.932'\r\n                    ' 199.344 167.048C199.133 167.165 198.955 167.334 198.826 167.539Z\"'\r\n                    ' fill=\"#34C46E\"/>'\r\n                '<text text-anchor=\"middle\" fill=\"#34C46E\">'\r\n                    '<textPath font-family=\"Montserrat\" xlink:href=\"#top\" startOffset=\"50%\" font-size=\"24\" font-weight=\"700\">'\r\n                        'Arkreen Climate Action Badge'\r\n                    '</textPath>'\r\n                '</text>'\r\n                '<text text-anchor=\"middle\" fill=\"#34C46E\">'\r\n                    '<textPath font-family=\"Montserrat\" xlink:href=\"#address\" startOffset=\"50%\" font-size=\"16\" font-weight=\"500\">',\r\n                        beneficiary,\r\n                    '</textPath>'\r\n                '</text>'\r\n                '<g transform=\"translate(0,227)\">'\r\n                    '<text font-family=\"Montserrat\" font-size=\"26px\" font-weight=\"700\" fill=\"white\" text-anchor=\"middle\" dominant-baseline=\"middle\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                            energyInBadge,\r\n                            ' ART'\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(0,253)\">'\r\n                    '<rect width=\"400\" height=\"40\"/>'\r\n                    '<text font-family=\"Montserrat\" font-size=\"12px\" font-weight=\"400\" fill=\"#7F7F8D\" text-anchor=\"middle\" dominant-baseline=\"middle\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">'\r\n                            'Offset'\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n            '</svg>'\r\n        );\r\n\r\n        return  string(Base64.encode(imgBytes));\r\n    }\r\n}"
    },
    "contracts/libraries/BytesLib.sol": {
      "content": "// SPDX-License-Identifier: Unlicense\n/*\n * @title Solidity Bytes Arrays Utils\n * @author Gonçalo Sá <goncalo.sa@consensys.net>\n *\n * @dev Bytes tightly packed arrays utility library for ethereum contracts written in Solidity.\n *      The library lets you concatenate, slice and type cast bytes arrays both in memory and storage.\n */\npragma solidity >=0.8.0 <0.9.0;\n\nlibrary BytesLib {\n    function concat(\n        bytes memory _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        bytes memory tempBytes;\n\n        assembly {\n            // Get a location of some free memory and store it in tempBytes as\n            // Solidity does for memory variables.\n            tempBytes := mload(0x40)\n\n            // Store the length of the first bytes array at the beginning of\n            // the memory for tempBytes.\n            let length := mload(_preBytes)\n            mstore(tempBytes, length)\n\n            // Maintain a memory counter for the current write location in the\n            // temp bytes array by adding the 32 bytes for the array length to\n            // the starting location.\n            let mc := add(tempBytes, 0x20)\n            // Stop copying when the memory counter reaches the length of the\n            // first bytes array.\n            let end := add(mc, length)\n\n            for {\n                // Initialize a copy counter to the start of the _preBytes data,\n                // 32 bytes into its memory.\n                let cc := add(_preBytes, 0x20)\n            } lt(mc, end) {\n                // Increase both counters by 32 bytes each iteration.\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                // Write the _preBytes data into the tempBytes memory 32 bytes\n                // at a time.\n                mstore(mc, mload(cc))\n            }\n\n            // Add the length of _postBytes to the current length of tempBytes\n            // and store it as the new length in the first 32 bytes of the\n            // tempBytes memory.\n            length := mload(_postBytes)\n            mstore(tempBytes, add(length, mload(tempBytes)))\n\n            // Move the memory counter back from a multiple of 0x20 to the\n            // actual end of the _preBytes data.\n            mc := end\n            // Stop copying when the memory counter reaches the new combined\n            // length of the arrays.\n            end := add(mc, length)\n\n            for {\n                let cc := add(_postBytes, 0x20)\n            } lt(mc, end) {\n                mc := add(mc, 0x20)\n                cc := add(cc, 0x20)\n            } {\n                mstore(mc, mload(cc))\n            }\n\n            // Update the free-memory pointer by padding our last write location\n            // to 32 bytes: add 31 bytes to the end of tempBytes to move to the\n            // next 32 byte block, then round down to the nearest multiple of\n            // 32. If the sum of the length of the two arrays is zero then add\n            // one before rounding down to leave a blank 32 bytes (the length block with 0).\n            mstore(0x40, and(\n              add(add(end, iszero(add(length, mload(_preBytes)))), 31),\n              not(31) // Round down to the nearest 32 bytes.\n            ))\n        }\n\n        return tempBytes;\n    }\n\n    function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal {\n        assembly {\n            // Read the first 32 bytes of _preBytes storage, which is the length\n            // of the array. (We don't need to use the offset into the slot\n            // because arrays use the entire slot.)\n            let fslot := sload(_preBytes.slot)\n            // Arrays of 31 bytes or less have an even value in their slot,\n            // while longer arrays have an odd value. The actual length is\n            // the slot divided by two for odd values, and the lowest order\n            // byte divided by two for even values.\n            // If the slot is even, bitwise and the slot with 255 and divide by\n            // two to get the length. If the slot is odd, bitwise and the slot\n            // with -1 and divide by two.\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n            let newlength := add(slength, mlength)\n            // slength can contain both the length and contents of the array\n            // if length < 32 bytes so let's prepare for that\n            // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n            switch add(lt(slength, 32), lt(newlength, 32))\n            case 2 {\n                // Since the new array still fits in the slot, we just need to\n                // update the contents of the slot.\n                // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length\n                sstore(\n                    _preBytes.slot,\n                    // all the modifications to the slot are inside this\n                    // next block\n                    add(\n                        // we can just add to the slot contents because the\n                        // bytes we want to change are the LSBs\n                        fslot,\n                        add(\n                            mul(\n                                div(\n                                    // load the bytes from memory\n                                    mload(add(_postBytes, 0x20)),\n                                    // zero all bytes to the right\n                                    exp(0x100, sub(32, mlength))\n                                ),\n                                // and now shift left the number of bytes to\n                                // leave space for the length in the slot\n                                exp(0x100, sub(32, newlength))\n                            ),\n                            // increase length by the double of the memory\n                            // bytes length\n                            mul(mlength, 2)\n                        )\n                    )\n                )\n            }\n            case 1 {\n                // The stored value fits in the slot, but the combined value\n                // will exceed it.\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // The contents of the _postBytes array start 32 bytes into\n                // the structure. Our first read should obtain the `submod`\n                // bytes that can fit into the unused space in the last word\n                // of the stored array. To get this, we read 32 bytes starting\n                // from `submod`, so the data we read overlaps with the array\n                // contents by `submod` bytes. Masking the lowest-order\n                // `submod` bytes allows us to add that value directly to the\n                // stored value.\n\n                let submod := sub(32, slength)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(\n                    sc,\n                    add(\n                        and(\n                            fslot,\n                            0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00\n                        ),\n                        and(mload(mc), mask)\n                    )\n                )\n\n                for {\n                    mc := add(mc, 0x20)\n                    sc := add(sc, 1)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n            default {\n                // get the keccak hash to get the contents of the array\n                mstore(0x0, _preBytes.slot)\n                // Start copying to the last used word of the stored array.\n                let sc := add(keccak256(0x0, 0x20), div(slength, 32))\n\n                // save new length\n                sstore(_preBytes.slot, add(mul(newlength, 2), 1))\n\n                // Copy over the first `submod` bytes of the new data as in\n                // case 1 above.\n                let slengthmod := mod(slength, 32)\n                let mlengthmod := mod(mlength, 32)\n                let submod := sub(32, slengthmod)\n                let mc := add(_postBytes, submod)\n                let end := add(_postBytes, mlength)\n                let mask := sub(exp(0x100, submod), 1)\n\n                sstore(sc, add(sload(sc), and(mload(mc), mask)))\n\n                for {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } lt(mc, end) {\n                    sc := add(sc, 1)\n                    mc := add(mc, 0x20)\n                } {\n                    sstore(sc, mload(mc))\n                }\n\n                mask := exp(0x100, sub(mc, end))\n\n                sstore(sc, mul(div(mload(mc), mask), mask))\n            }\n        }\n    }\n\n    function slice(\n        bytes memory _bytes,\n        uint256 _start,\n        uint256 _length\n    )\n        internal\n        pure\n        returns (bytes memory)\n    {\n        require(_length + 31 >= _length, \"slice_overflow\");\n        require(_bytes.length >= _start + _length, \"slice_outOfBounds\");\n\n        bytes memory tempBytes;\n\n        assembly {\n            switch iszero(_length)\n            case 0 {\n                // Get a location of some free memory and store it in tempBytes as\n                // Solidity does for memory variables.\n                tempBytes := mload(0x40)\n\n                // The first word of the slice result is potentially a partial\n                // word read from the original array. To read it, we calculate\n                // the length of that partial word and start copying that many\n                // bytes into the array. The first word we copy will start with\n                // data we don't care about, but the last `lengthmod` bytes will\n                // land at the beginning of the contents of the new array. When\n                // we're done copying, we overwrite the full first word with\n                // the actual length of the slice.\n                let lengthmod := and(_length, 31)\n\n                // The multiplication in the next line is necessary\n                // because when slicing multiples of 32 bytes (lengthmod == 0)\n                // the following copy loop was copying the origin's length\n                // and then ending prematurely not copying everything it should.\n                let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod)))\n                let end := add(mc, _length)\n\n                for {\n                    // The multiplication in the next line has the same exact purpose\n                    // as the one above.\n                    let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start)\n                } lt(mc, end) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    mstore(mc, mload(cc))\n                }\n\n                mstore(tempBytes, _length)\n\n                //update free-memory pointer\n                //allocating the array padded to 32 bytes like the compiler does now\n                mstore(0x40, and(add(mc, 31), not(31)))\n            }\n            //if we want a zero-length slice let's just return a zero-length array\n            default {\n                tempBytes := mload(0x40)\n                //zero out the 32 bytes slice we are about to return\n                //we need to do it because Solidity does not garbage collect\n                mstore(tempBytes, 0)\n\n                mstore(0x40, add(tempBytes, 0x20))\n            }\n        }\n\n        return tempBytes;\n    }\n\n    function toAddress(bytes memory _bytes, uint256 _start) internal pure returns (address) {\n        require(_bytes.length >= _start + 20, \"toAddress_outOfBounds\");\n        address tempAddress;\n\n        assembly {\n            tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000)\n        }\n\n        return tempAddress;\n    }\n\n    function toUint8(bytes memory _bytes, uint256 _start) internal pure returns (uint8) {\n        require(_bytes.length >= _start + 1 , \"toUint8_outOfBounds\");\n        uint8 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x1), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint16(bytes memory _bytes, uint256 _start) internal pure returns (uint16) {\n        require(_bytes.length >= _start + 2, \"toUint16_outOfBounds\");\n        uint16 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x2), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint32(bytes memory _bytes, uint256 _start) internal pure returns (uint32) {\n        require(_bytes.length >= _start + 4, \"toUint32_outOfBounds\");\n        uint32 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x4), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint64(bytes memory _bytes, uint256 _start) internal pure returns (uint64) {\n        require(_bytes.length >= _start + 8, \"toUint64_outOfBounds\");\n        uint64 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x8), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint96(bytes memory _bytes, uint256 _start) internal pure returns (uint96) {\n        require(_bytes.length >= _start + 12, \"toUint96_outOfBounds\");\n        uint96 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0xc), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint128(bytes memory _bytes, uint256 _start) internal pure returns (uint128) {\n        require(_bytes.length >= _start + 16, \"toUint128_outOfBounds\");\n        uint128 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x10), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toUint256(bytes memory _bytes, uint256 _start) internal pure returns (uint256) {\n        require(_bytes.length >= _start + 32, \"toUint256_outOfBounds\");\n        uint256 tempUint;\n\n        assembly {\n            tempUint := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempUint;\n    }\n\n    function toBytes32(bytes memory _bytes, uint256 _start) internal pure returns (bytes32) {\n        require(_bytes.length >= _start + 32, \"toBytes32_outOfBounds\");\n        bytes32 tempBytes32;\n\n        assembly {\n            tempBytes32 := mload(add(add(_bytes, 0x20), _start))\n        }\n\n        return tempBytes32;\n    }\n\n    function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) {\n        bool success = true;\n\n        assembly {\n            let length := mload(_preBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(length, mload(_postBytes))\n            case 1 {\n                // cb is a circuit breaker in the for loop since there's\n                //  no said feature for inline assembly loops\n                // cb = 1 - don't breaker\n                // cb = 0 - break\n                let cb := 1\n\n                let mc := add(_preBytes, 0x20)\n                let end := add(mc, length)\n\n                for {\n                    let cc := add(_postBytes, 0x20)\n                // the next line is the loop condition:\n                // while(uint256(mc < end) + cb == 2)\n                } eq(add(lt(mc, end), cb), 2) {\n                    mc := add(mc, 0x20)\n                    cc := add(cc, 0x20)\n                } {\n                    // if any of these checks fails then arrays are not equal\n                    if iszero(eq(mload(mc), mload(cc))) {\n                        // unsuccess:\n                        success := 0\n                        cb := 0\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n\n    function equalStorage(\n        bytes storage _preBytes,\n        bytes memory _postBytes\n    )\n        internal\n        view\n        returns (bool)\n    {\n        bool success = true;\n\n        assembly {\n            // we know _preBytes_offset is 0\n            let fslot := sload(_preBytes.slot)\n            // Decode the length of the stored array like in concatStorage().\n            let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2)\n            let mlength := mload(_postBytes)\n\n            // if lengths don't match the arrays are not equal\n            switch eq(slength, mlength)\n            case 1 {\n                // slength can contain both the length and contents of the array\n                // if length < 32 bytes so let's prepare for that\n                // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage\n                if iszero(iszero(slength)) {\n                    switch lt(slength, 32)\n                    case 1 {\n                        // blank the last byte which is the length\n                        fslot := mul(div(fslot, 0x100), 0x100)\n\n                        if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) {\n                            // unsuccess:\n                            success := 0\n                        }\n                    }\n                    default {\n                        // cb is a circuit breaker in the for loop since there's\n                        //  no said feature for inline assembly loops\n                        // cb = 1 - don't breaker\n                        // cb = 0 - break\n                        let cb := 1\n\n                        // get the keccak hash to get the contents of the array\n                        mstore(0x0, _preBytes.slot)\n                        let sc := keccak256(0x0, 0x20)\n\n                        let mc := add(_postBytes, 0x20)\n                        let end := add(mc, mlength)\n\n                        // the next line is the loop condition:\n                        // while(uint256(mc < end) + cb == 2)\n                        for {} eq(add(lt(mc, end), cb), 2) {\n                            sc := add(sc, 1)\n                            mc := add(mc, 0x20)\n                        } {\n                            if iszero(eq(sload(sc), mload(mc))) {\n                                // unsuccess:\n                                success := 0\n                                cb := 0\n                            }\n                        }\n                    }\n                }\n            }\n            default {\n                // unsuccess:\n                success := 0\n            }\n        }\n\n        return success;\n    }\n}"
    },
    "contracts/ArkreenRECIssuanceImage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport \"@openzeppelin/contracts/utils/Base64.sol\";\r\nimport \"@openzeppelin/contracts/utils/Strings.sol\";\r\n\r\nimport \"./libraries/FormattedStrings.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\nimport \"./libraries/BytesLib.sol\";\r\nimport \"./libraries/DateTime.sol\";\r\n\r\nimport \"./ArkreenRECIssuanceType.sol\";\r\n\r\n// Import this file to use console.log\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract ArkreenRECIssuanceImage {\r\n \r\n    using Strings for uint128;\r\n    using Strings for uint256;\r\n    using Strings for address;\r\n    using FormattedStrings for uint256;\r\n    using BytesLib for bytes;\r\n\r\n    function _decimalTruncate(string memory _str, uint256 decimalDigits) internal pure returns (string memory) {\r\n        bytes memory strBytes = bytes(_str);\r\n        uint256 dotIndex = strBytes.length;\r\n\r\n        for (uint256 i = 0; i < strBytes.length; i++) {\r\n            if (strBytes[i] == \".\") {\r\n\r\n                if(i + decimalDigits + 1 < strBytes.length){\r\n                    dotIndex = i + decimalDigits + 1;\r\n                }\r\n                break;\r\n            }\r\n        }\r\n\r\n        bytes memory result = new bytes(dotIndex);\r\n        for (uint256 i = 0; i < dotIndex; i++) {\r\n            result[i] = strBytes[i];\r\n        }\r\n\r\n        return string(result);\r\n    }\r\n\r\n    function toFixedPoint(uint256 value, uint256 decimal) internal pure returns (string memory) {\r\n        require(decimal <= 18, \"Strings: Fixed point too long\");\r\n        string memory valueString = value.toString();\r\n        \r\n        if (decimal == 0) return valueString;\r\n\r\n        bytes memory valueBytes = bytes(valueString);\r\n        uint256 length = valueBytes.length;\r\n\r\n        bytes memory resulInBytes;\r\n        if (length > decimal) {\r\n            resulInBytes = valueBytes.slice(0, length - decimal).concat(\".\")                // Integer part\r\n                                .concat(valueBytes.slice(length - decimal, decimal));       // Decimal part\r\n        } else {\r\n            resulInBytes = bytes(\"0.000000000000000000\").slice(0, decimal + 2 - length)     // Maximum 18 decimals\r\n                                .concat(valueBytes);\r\n        }\r\n        return string(resulInBytes);\r\n    }\r\n\r\n    function toStringDayMonth(uint16 year, uint8 month, uint8 day) internal pure returns (string memory) {\r\n        bytes memory buffer = new bytes(11);\r\n        buffer[3] = bytes1(uint8(48 + uint256(year % 10)));  year /= 10;\r\n        buffer[2] = bytes1(uint8(48 + uint256(year % 10)));  year /= 10;\r\n        buffer[1] = bytes1(uint8(48 + uint256(year % 10)));  year /= 10;\r\n        buffer[0] = bytes1(uint8(48 + uint256(year)));\r\n        buffer[4] = '-';\r\n        buffer[6] = bytes1(uint8(48 + uint256(month % 10)));  month /= 10;\r\n        buffer[5] = bytes1(uint8(48 + uint256(month))); \r\n        buffer[7] = '-';\r\n        buffer[9] = bytes1(uint8(48 + uint256(day % 10)));  day /= 10;\r\n        buffer[8] = bytes1(uint8(48 + uint256(day)));  \r\n        return string(buffer);\r\n    }\r\n\r\n\r\n    function getARECSVG(\r\n        uint256 tokenId,\r\n        address owner,\r\n        RECData memory recData\r\n    ) external pure returns(string memory) {\r\n\r\n        bytes memory dataURI;\r\n        string memory tokenString = tokenId.toString();\r\n\r\n        {\r\n            string memory energyInBadge = _decimalTruncate(toFixedPoint(recData.amountREC, 9), 3);\r\n            string memory svgData = getARECSVGImage(tokenId, owner, recData);\r\n\r\n            dataURI = abi.encodePacked(\r\n                            '{\"name\":\"AREC NDT #',\r\n                            tokenString,\r\n                            '\",\"description\":\"',\r\n                            'Details of renewable energy included in the AREC NFT.',\r\n                            '\",\"image\":\"data:image/svg+xml;base64,',\r\n                            svgData,\r\n                            '\",\"attributes\":[{\"display_type\":\"number\",\"trait_type\":\"AREC NFT ID\",\"value\":',\r\n                            tokenString,\r\n                            '},{\"trait_type\":\"Serial Number\",\"value\":\"',\r\n                            recData.serialNumber,\r\n                            '\"},{\"trait_type\":\"Renewable Energy\",\"value\":\"',\r\n                            energyInBadge,\r\n                            ' kWh\"},'\r\n                            );\r\n        }\r\n\r\n        {\r\n            dataURI = abi.encodePacked(dataURI,\r\n                            '{\"display_type\":\"date\",\"trait_type\":\"AREC Start Time\",\"value\":',\r\n                            uint256(recData.startTime).toString(),\r\n                            '},{\"display_type\":\"date\",\"trait_type\":\"AREC End Time\",\"value\":',\r\n                            uint256(recData.endTime).toString(),\r\n                            '},{\"trait_type\":\"AREC Region\",\"value\":\"',\r\n                            recData.region,\r\n                            '\"},{\"trait_type\":\"AREC URL\",\"value\":\"',\r\n                            recData.url,\r\n                            '\"}'\r\n                        );\r\n        }\r\n        if (bytes(recData.memo).length !=0) {\r\n            dataURI = abi.encodePacked(dataURI,\r\n                            ',{\"trait_type\":\"AREC Memo\",\"value\":\"',\r\n                            recData.memo,\r\n                            '\"}]}'\r\n                        );\r\n        } else {\r\n            dataURI = abi.encodePacked(dataURI, ']}');\r\n        }\r\n\r\n        return string(abi.encodePacked(\"data:application/json;base64,\", Base64.encode(dataURI)));\r\n    }\r\n\r\n    function getARECSVGImage(uint256 tokenId, address owner, RECData memory recData) internal pure returns(string memory) {\r\n\r\n        bytes memory imgBytes;\r\n        \r\n        imgBytes = abi.encodePacked(\r\n            '<svg viewBox=\"0 0 900 744\" fill=\"none\" xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\">'\r\n                '<defs>'\r\n                    '<path id=\"center\" d=\"M0 20 800 20\" stroke=\"white\" fill=\"none\"/>'\r\n                '</defs>'\r\n                '<style>.f{font-family:Montserrat;dominant-baseline:middle;text-anchor:middle}</style>'\r\n                '<style>.f4{font-family:Montserrat;font-size=12px;font-weight:400;dominant-baseline:middle;text-anchor:middle}</style>'\r\n                '<style>.fb{font-family:Montserrat;font-weight:700;dominant-baseline:middle;text-anchor:middle}</style>'\r\n                '<path fill=\"#fff\" d=\"M.5.5h899v743H.5z\"/>'\r\n                '<path stroke=\"#2F2F34\" d=\"M.5.5h899v743H.5z\"/>'\r\n                '<path stroke=\"#DBDBE4\" d=\"M24.5 24.5h851v695h-851z\"/>'\r\n                '<path stroke=\"#DBDBE4\" d=\"M32.5 32.5h835v679h-835z\"/>'\r\n                '<g>'\r\n                '<path d=\"M482 88c0 17.673-14.327 32-32 32-17.673 0-32-14.327-32-32 0-17.673 14.327-32'\r\n                    ' 32-32 17.673 0 32 14.327 32 32z\" fill=\"#00913A\"/>'\r\n                '<path d=\"M449.53 87.816l-6.583 10.543c-.632 1.013.095 2.329 1.288 2.329h23.366c1.342 0 2.16-1.478'\r\n                    ' 1.449-2.618L452.268 71.19c-1.042-1.668-3.465-1.668-4.509 0l-16.963 27.17c-.632 1.013.095 2.329 1.288'\r\n                    ' 2.329h3.793c.193-.001.383-.05.552-.143a1.15 1.15 0 00.414-.394l12.687-20.325a.573.573 0 01.967 0l8.68'\r\n                    ' 13.905a.575.575 0 01.017.58.568.568 0 01-.5.294h-5.21a.57.57 0 01-.48-.873l.404-.648a.575.575'\r\n                    ' 0 000-.604l-2.911-4.662a.566.566 0 00-.759-.199.574.574 0 00-.208.197z\" fill=\"#fff\"/>'\r\n               '</g>'\r\n                '<g transform=\"translate(50,130)\">'\r\n                    '<text class=\"f\" font-size=\"24px\" font-weight=\"700\" fill=\"#202024\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">'\r\n                          'ARKREEN RENEWABLE ENERGY CERTIFICATE'\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<line x1=\"50\" y1=\"620\" x2=\"850\" y2=\"620\" stroke=\"#E0E0E0\" stroke-width=\"1.5\" stroke-dasharray=\"4,4\" />'\r\n                '<g transform=\"translate(50,200)\">'\r\n                    '<text class=\"f4\" font-size=\"12px\" fill=\"#5D5D68\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">'\r\n                            'This certificate is issued to the account on Polygon of'\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(50,240)\">'\r\n                    '<rect width=\"800\" height=\"40\"/>'\r\n                    '<text class=\"f\" font-size=\"16px\" font-weight=\"700\" fill=\"#2f2f34\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                          owner.toHexString(),\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(50,272)\">'\r\n                    '<text class=\"f4\" font-size=\"12px\" fill=\"#5D5D68\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">'\r\n                          'by'\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(50,302)\">'\r\n                    '<text class=\"f\" font-size=\"16px\" font-weight=\"700\" fill=\"#2f2f34\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                          'Arkreen Network',\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                \r\n            );\r\n\r\n        {\r\n            string memory artAmount = _decimalTruncate(toFixedPoint(recData.amountREC, 9), 4);\r\n            bytes memory fullARTString = bytes(\"AREC certificates, representing \")\r\n                                            .concat(bytes(artAmount))\r\n                                            .concat(bytes(' MWh of electricity generated from renewable sources, recoreded in the link'));\r\n            \r\n            _decimalTruncate(toFixedPoint(recData.amountREC, 9), 4);\r\n\r\n            imgBytes = abi.encodePacked(imgBytes,\r\n\r\n                '<g transform=\"translate(50,344)\">'\r\n                    '<text class=\"f4\" font-size=\"12px\" fill=\"#5D5D68\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                            'confirming the issuance of',\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(50,384)\">'\r\n                    '<rect width=\"800\" height=\"40\" />'\r\n                    '<text class=\"f\" font-size=\"32px\" font-weight=\"700\" fill=\"#202024\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                          artAmount,\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(50,418)\">'\r\n                    '<text class=\"f4\" font-size=\"12px\" fill=\"#5D5D68\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                            string(fullARTString),\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(50,444)\">'\r\n                    '<text class=\"f\" font-size=\"12px\" font-weight=\"700\" fill=\"#2f2f34\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                          recData.url,\r\n                      '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n                '<g transform=\"translate(50,470)\">'\r\n                    '<text class=\"f4\" font-size=\"12px\" fill=\"#5D5D68\">'\r\n                        '<textPath xlink:href=\"#center\" startOffset=\"50%\">'\r\n                            'This certificate relates to the electricity generation located at or in'\r\n                        '</textPath>'\r\n                    '</text>'\r\n                '</g>'\r\n            );    \r\n        }\r\n\r\n        {\r\n            DateTimeLib.DateTime memory startTime = DateTimeLib.parseTimestamp(uint256(recData.startTime));\r\n            DateTimeLib.DateTime memory endTime = DateTimeLib.parseTimestamp(uint256(recData.endTime));\r\n            string memory startString = toStringDayMonth(startTime.year, startTime.month, startTime.day);\r\n            string memory endString = toStringDayMonth(endTime.year, endTime.month, endTime.day);\r\n\r\n            imgBytes = abi.encodePacked(imgBytes,     \r\n\r\n                    '<g transform=\"translate(50,504)\">'\r\n                        '<rect width=\"800\" height=\"40\"/>'\r\n                        '<text class=\"f\" font-size=\"16px\" font-weight=\"700\" fill=\"#2f2f34\">'\r\n                            '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                                recData.region,\r\n                            '</textPath>'\r\n                        '</text>'\r\n                    '</g>'\r\n                    '<g transform=\"translate(50,536)\">'\r\n                        '<text class=\"f4\" font-size=\"12px\" fill=\"#5D5D68\">'\r\n                            '<textPath xlink:href=\"#center\" startOffset=\"50%\">'\r\n                                'in respect of the reporting period'\r\n                            '</textPath>'\r\n                        '</text>'\r\n                    '</g>'\r\n                    '<g transform=\"translate(50,574)\">'\r\n                        '<text class=\"f4\" font-size=\"12px\" fill=\"#5D5D68\">'\r\n                            '<textPath xlink:href=\"#center\" startOffset=\"50%\">'\r\n                                'to'\r\n                            '</textPath>'\r\n                        '</text>'\r\n                    '</g>'\r\n                    '<g transform=\"translate(-20,574)\">'\r\n                        '<text class=\"f\" font-size=\"16px\" font-weight=\"500\" fill=\"#202024\">'\r\n                            '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                                startString,\r\n                            '</textPath>'\r\n                        '</text>'\r\n                    '</g>'\r\n\r\n                    '<g transform=\"translate(120,574)\">'\r\n                        '<text class=\"f\" font-size=\"16px\" font-weight=\"500\" fill=\"#202024\">'\r\n                            '<textPath xlink:href=\"#center\" startOffset=\"50%\">',\r\n                                endString,\r\n                            '</textPath>'\r\n                        '</text>'\r\n                    '</g>'\r\n                    '<line x1=\"50\" y1=\"620\" x2=\"850\" y2=\"620\" stroke=\"#E0E0E0\" stroke-width=\"1.5\" stroke-dasharray=\"4,4\" />'\r\n                '</svg>'\r\n            );\r\n        }\r\n\r\n        return  string(Base64.encode(imgBytes));\r\n    }\r\n}"
    },
    "contracts/libraries/DateTime.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n/**\r\n * Modified from https://etherscan.io/address/0x1a6184cd4c5bea62b0116de7962ee7315b7bcbce#code\r\n*/\r\nlibrary DateTimeLib {\r\n        /*\r\n         *  Date and Time utilities for ethereum contracts\r\n         *\r\n         *  address: 0x1a6184cd4c5bea62b0116de7962ee7315b7bcbce\r\n         */\r\n        struct DateTime {\r\n                uint16 year;\r\n                uint8 month;\r\n                uint8 day;\r\n                uint8 hour;\r\n                uint8 minute;\r\n                uint8 second;\r\n                uint8 weekday;\r\n        }\r\n\r\n        uint constant DAY_IN_SECONDS = 86400;\r\n        uint constant YEAR_IN_SECONDS = 31536000;\r\n        uint constant LEAP_YEAR_IN_SECONDS = 31622400;\r\n\r\n        uint constant HOUR_IN_SECONDS = 3600;\r\n        uint constant MINUTE_IN_SECONDS = 60;\r\n\r\n        uint16 constant ORIGIN_YEAR = 1970;\r\n\r\n        function isLeapYear(uint16 year) internal pure returns (bool) {\r\n                if (year % 4 != 0) {\r\n                        return false;\r\n                }\r\n                if (year % 100 != 0) {\r\n                        return true;\r\n                }\r\n                if (year % 400 != 0) {\r\n                        return false;\r\n                }\r\n                return true;\r\n        }\r\n\r\n        function parseTimestamp(uint timestamp) internal pure returns (DateTime memory dt) {\r\n                uint secondsAccountedFor = 0;\r\n                uint buf;\r\n                uint8 i;\r\n\r\n                dt.year = ORIGIN_YEAR;\r\n\r\n                // Year\r\n                while (true) {\r\n                        if (isLeapYear(dt.year)) {\r\n                                buf = LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                buf = YEAR_IN_SECONDS;\r\n                        }\r\n\r\n                        if (secondsAccountedFor + buf > timestamp) {\r\n                                break;\r\n                        }\r\n                        dt.year += 1;\r\n                        secondsAccountedFor += buf;\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(dt.year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                uint secondsInMonth;\r\n                for (i = 0; i < monthDayCounts.length; i++) {\r\n                        secondsInMonth = DAY_IN_SECONDS * monthDayCounts[i];\r\n                        if (secondsInMonth + secondsAccountedFor > timestamp) {\r\n                                dt.month = i + 1;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += secondsInMonth;\r\n                }\r\n\r\n                // Day\r\n                for (i = 0; i < monthDayCounts[dt.month - 1]; i++) {\r\n                        if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.day = i + 1;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += DAY_IN_SECONDS;\r\n                }\r\n\r\n                // Hour\r\n                for (i = 0; i < 24; i++) {\r\n                        if (HOUR_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.hour = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += HOUR_IN_SECONDS;\r\n                }\r\n\r\n                // Minute\r\n                for (i = 0; i < 60; i++) {\r\n                        if (MINUTE_IN_SECONDS + secondsAccountedFor > timestamp) {\r\n                                dt.minute = i;\r\n                                break;\r\n                        }\r\n                        secondsAccountedFor += MINUTE_IN_SECONDS;\r\n                }\r\n\r\n                if (timestamp - secondsAccountedFor > 60) {\r\n                    revert(\"\");\r\n                }\r\n\r\n                // Second\r\n                dt.second = uint8(timestamp - secondsAccountedFor);\r\n\r\n                // Day of week.\r\n                buf = timestamp / DAY_IN_SECONDS;\r\n                dt.weekday = uint8((buf + 3) % 7);\r\n        }\r\n\r\n        function getYear(uint timestamp) internal pure returns (uint16) {\r\n                return parseTimestamp(timestamp).year;\r\n        }\r\n\r\n        function getMonth(uint timestamp) internal pure returns (uint16) {\r\n                return parseTimestamp(timestamp).month;\r\n        }\r\n\r\n        function getDay(uint timestamp) internal pure returns (uint16) {\r\n                return parseTimestamp(timestamp).day;\r\n        }\r\n\r\n        function getHour(uint timestamp) internal pure returns (uint16) {\r\n                return parseTimestamp(timestamp).hour;\r\n        }\r\n\r\n        function getMinute(uint timestamp) internal pure returns (uint16) {\r\n                return parseTimestamp(timestamp).minute;\r\n        }\r\n\r\n        function getSecond(uint timestamp) internal pure returns (uint16) {\r\n                return parseTimestamp(timestamp).second;\r\n        }\r\n\r\n        function getWeekday(uint timestamp) internal pure returns (uint8) {\r\n                return parseTimestamp(timestamp).weekday;\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, 0, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) internal pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, 0, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) internal pure returns (uint timestamp) {\r\n                return toTimestamp(year, month, day, hour, minute, 0);\r\n        }\r\n\r\n        function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) {\r\n                uint16 i;\r\n\r\n                // Year\r\n                for (i = ORIGIN_YEAR; i < year; i++) {\r\n                        if (isLeapYear(i)) {\r\n                                timestamp += LEAP_YEAR_IN_SECONDS;\r\n                        }\r\n                        else {\r\n                                timestamp += YEAR_IN_SECONDS;\r\n                        }\r\n                }\r\n\r\n                // Month\r\n                uint8[12] memory monthDayCounts;\r\n                monthDayCounts[0] = 31;\r\n                if (isLeapYear(year)) {\r\n                        monthDayCounts[1] = 29;\r\n                }\r\n                else {\r\n                        monthDayCounts[1] = 28;\r\n                }\r\n                monthDayCounts[2] = 31;\r\n                monthDayCounts[3] = 30;\r\n                monthDayCounts[4] = 31;\r\n                monthDayCounts[5] = 30;\r\n                monthDayCounts[6] = 31;\r\n                monthDayCounts[7] = 31;\r\n                monthDayCounts[8] = 30;\r\n                monthDayCounts[9] = 31;\r\n                monthDayCounts[10] = 30;\r\n                monthDayCounts[11] = 31;\r\n\r\n                for (i = 1; i < month; i++) {\r\n                        timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1];\r\n                }\r\n\r\n                // Day\r\n                timestamp += DAY_IN_SECONDS * (day - 1);\r\n\r\n                // Hour\r\n                timestamp += HOUR_IN_SECONDS * (hour);\r\n\r\n                // Minute\r\n                timestamp += MINUTE_IN_SECONDS * (minute);\r\n\r\n                // Second\r\n                timestamp += second;\r\n\r\n                return timestamp;\r\n        }\r\n}"
    },
    "contracts/ArkreenRECToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol';\r\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\r\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\r\n//import '@openzeppelin/contracts/access/AccessControl.sol';\r\n\r\nimport \"./ArkreenRECIssuanceType.sol\";\r\nimport \"./interfaces/IArkreenRECIssuance.sol\";\r\nimport \"./interfaces/IArkreenRegistry.sol\";\r\nimport \"./interfaces/IArkreenBadge.sol\";\r\nimport \"./interfaces/IPausable.sol\";\r\n\r\n// Import this file to use console.log\r\n//import \"hardhat/console.sol\";\r\n\r\ncontract ArkreenRECToken is\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    ERC20Upgradeable,\r\n    IERC721Receiver\r\n{\r\n    // using SafeMath for uint256;    // seems not necessary\r\n    using AddressUpgradeable for address;\r\n\r\n    // Public constant variables\r\n    string public constant NAME = 'Arkreen REC Token';\r\n    string public constant SYMBOL = 'ART';\r\n\r\n    uint256 public constant MAX_SKIP = 20;\r\n    uint256 public constant FLAG_OFFSET = 1<<64;\r\n\r\n    // Public variables\r\n    address public arkreenRegistry;           // Registry contract storing Arkreen contracts   \r\n    address public issuerREC;                 // Address of issuer of the original REC pre-liquidized    \r\n    uint256 public totalLiquidized;           // Total amount of REC that is liquidized\r\n    uint256 public totalOffset;               // Total amount of REC that is offset \r\n\r\n    address public receiverFee;                // Receiver address to receive the liquidization fee\r\n    uint256 public ratioLiquidizedFee;         // Percentage in basis point (10000) of the liquidization fee\r\n\r\n    mapping(uint256 => uint256) public allARECLiquidized;   // Loop of all AREC ID: 1st-> 2nd-> ..-> last-> 1st\r\n    uint256 public latestARECID;                            // NFT ID of the latest AREC added to the loop \r\n    uint256 public ratioFeeToSolidify;                      // Percentage in basis point (10000) to charge for solidifying ART to AREC NFT\r\n\r\n//    uint256 partialARECID;                                // AREC NFT ID partialy offset\r\n//    uint256 partialAvailableAmount;                       // Amount available for partial offset\r\n    uint256 public triggerUpgradeAmount;                    // The amount to trigger solidify upgrade\r\n    address public climateBuilder;\r\n\r\n    // Events\r\n    event OffsetFinished(address indexed offsetEntity, uint256 amount, uint256 offsetId);\r\n    event Solidify(address indexed account, uint256 amount, uint256 numberAREC, uint256 feeSolidify);    \r\n\r\n    // Modifiers\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'ART: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!IPausable(arkreenRegistry).paused(), 'ART: Paused');\r\n        _;\r\n    }\r\n  \r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize(address arkRegistry, address issuer, string calldata name, string calldata symbol) external virtual initializer {\r\n        __Ownable_init_unchained();\r\n        __UUPSUpgradeable_init();        \r\n        if(bytes(symbol).length == 0) {\r\n          __ERC20_init_unchained(NAME, SYMBOL);\r\n        } else {\r\n          __ERC20_init_unchained(name, symbol);          \r\n        }\r\n        arkreenRegistry = arkRegistry;\r\n        issuerREC = issuer;\r\n    }\r\n\r\n    function postUpdate() external onlyProxy onlyOwner \r\n    {}\r\n\r\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner\r\n    {}    \r\n\r\n    function decimals() public view virtual override returns (uint8) {\r\n        return 9;\r\n    }\r\n\r\n    /**\r\n     * @dev Offset the RE token by burning the tokens\r\n     */\r\n    function commitOffset(uint256 amount) public virtual whenNotPaused returns (uint256 offsetActionId) {\r\n        offsetActionId = _offset(msg.sender, _msgSender(), amount);\r\n    }\r\n\r\n    /**\r\n     * @dev Third party contract triggers the RE offset in the approval of the owner\r\n     */\r\n    function commitOffsetFrom(address account, uint256 amount)\r\n        external virtual whenNotPaused returns (uint256 offsetActionId) \r\n    {\r\n        _spendAllowance(account, _msgSender(), amount);\r\n        offsetActionId = _offset(account, account, amount);\r\n    }\r\n   \r\n    /**\r\n     * @dev Internal offset function of the RE token, the RE tokens are burned\r\n     */\r\n    function _offset(address account, address owner, uint256 amount) internal virtual returns (uint256 offsetActionId) {\r\n\r\n        if(totalOffset < triggerUpgradeAmount) {                                // To check whether triggering upgrade\r\n            uint256 offsetAmount = triggerUpgradeAmount - totalOffset;\r\n            offsetAmount = (offsetAmount > amount) ? amount: offsetAmount;\r\n            amount -= offsetAmount;\r\n            _burn(account, offsetAmount);\r\n\r\n            // Track total retirement amount in TCO2 factory\r\n            address badgeContractU = IArkreenRegistry(arkreenRegistry).getArkreenRetirement();\r\n            offsetActionId = IArkreenBadge(badgeContractU).registerOffset(owner, issuerREC, offsetAmount, 0);\r\n            totalOffset += offsetAmount;\r\n\r\n            emit OffsetFinished(owner, offsetAmount, offsetActionId);\r\n            if(amount == 0) {\r\n                return offsetActionId;\r\n            }\r\n        }\r\n\r\n        require(amount != 0, 'ART: Zero Offset');\r\n\r\n        address issuanceAREC = IArkreenRegistry(arkreenRegistry).getRECIssuance();\r\n        address badgeContract = IArkreenRegistry(arkreenRegistry).getArkreenRetirement();\r\n\r\n        // Track total retirement amount in TCO2 factory\r\n        uint256 steps = 0;\r\n        uint256 curAREC; \r\n        uint256 amountFilled = 0; \r\n        uint256 amountRegister;\r\n\r\n        uint256 partialAvailableAmount;\r\n        uint256 partialARECID;\r\n\r\n        uint256 amountOffset;\r\n        uint256 detailsCounter;\r\n\r\n        (partialAvailableAmount, partialARECID) = IArkreenBadge(badgeContract).getDetailStatus(address(this));\r\n\r\n        if(amount > partialAvailableAmount) {\r\n            while(steps < MAX_SKIP) {\r\n                if(partialAvailableAmount == 0) {\r\n                    curAREC = allARECLiquidized[latestARECID];        // Get the ID at AREC NFT loop head\r\n                    _remove(latestARECID, curAREC);                   // Remove from the loop\r\n                    IArkreenRECIssuance(issuanceAREC).safeTransferFrom(address(this), badgeContract, curAREC);  // Send to Badge contract\r\n\r\n                    (, uint128 amountREC, , ) = IArkreenRECIssuance(issuanceAREC).getRECDataCore(curAREC);\r\n                    partialAvailableAmount = amountREC;\r\n                    partialARECID = curAREC;\r\n                }\r\n\r\n                if(amount <= partialAvailableAmount) {\r\n                    if (steps==0) break;   \r\n                    amountRegister = amount;\r\n                } else {\r\n                    amountRegister = partialAvailableAmount;\r\n                }\r\n                \r\n                (detailsCounter, partialAvailableAmount) = \r\n                                IArkreenBadge(badgeContract).registerDetail(amountRegister, partialARECID, (steps==0));\r\n                steps++;\r\n                amountFilled += amountRegister;\r\n                amount -= amountRegister;\r\n\r\n                if(amount==0) break;\r\n            }\r\n        }\r\n\r\n        amountOffset = (steps==0) ? amount: amountFilled;\r\n        _burn(account, amountOffset);\r\n\r\n        offsetActionId = IArkreenBadge(badgeContract).registerOffset(owner, issuerREC, amountOffset, FLAG_OFFSET+detailsCounter);\r\n        totalOffset += amountOffset;\r\n\r\n        emit OffsetFinished(owner, amountOffset, offsetActionId);\r\n    }\r\n\r\n    /**\r\n     * @dev Offset the RE token and mint a certificate in the single transaction.\r\n     * @param beneficiary Beneficiary address for whom the RE was offset.\r\n     * @param offsetEntityID ID string of the offset entity.\r\n     * @param beneficiaryID ID string of the beneficiary.\r\n     * @param offsetMessage Message to illustrate the offset intention.\r\n     * @param amount Amount to offset and issue an NFT certificate for.\r\n     */\r\n    function offsetAndMintCertificate(\r\n        address         beneficiary,\r\n        string calldata offsetEntityID,\r\n        string calldata beneficiaryID,\r\n        string calldata offsetMessage,\r\n        uint256         amount\r\n    ) external virtual whenNotPaused {\r\n        \r\n        // Offset the specified amount\r\n        address owner = _msgSender();\r\n        uint256 offsetActionId = _offset(msg.sender, owner, amount);     // maybe called from climate operator, so use msg.sender\r\n        uint256[] memory offsetActionIds = new uint256[](1);\r\n        offsetActionIds[0] = offsetActionId;\r\n\r\n        // Issue the offset certificate NFT\r\n        address badgeContract = IArkreenRegistry(arkreenRegistry).getArkreenRetirement();\r\n        IArkreenBadge(badgeContract).mintCertificate(\r\n                        owner, beneficiary, offsetEntityID, beneficiaryID, offsetMessage, offsetActionIds);\r\n    }\r\n\r\n    /**\r\n     * @dev Solidify the ART token to AREC NFT.\r\n     * @param amount The amount requesting to solidify\r\n     */\r\n    function solidify(uint256 amount) external virtual whenNotPaused \r\n                returns (uint256 solidifiedAmount, uint256 numberAREC, uint256 feeSolidify) {\r\n\r\n        require(latestARECID != 0, 'ART: No Liquidized AREC');\r\n        bool chargeOn = (receiverFee != address(0)) && (ratioFeeToSolidify != 0);           // To save gas\r\n        if(chargeOn) amount = (amount * 10000) / (10000 + ratioFeeToSolidify);             // Substract the solidify fee \r\n        \r\n        address solidifier = _msgSender();\r\n        address issuanceAREC = IArkreenRegistry(arkreenRegistry).getRECIssuance();\r\n\r\n        uint256 skips = 0;\r\n        uint256 curAREC = allARECLiquidized[latestARECID];\r\n        uint256 preAREC = latestARECID;\r\n\r\n        while (skips <= MAX_SKIP) {\r\n            (, uint128 amountREC, , ) = IArkreenRECIssuance(issuanceAREC).getRECDataCore(curAREC);\r\n            uint256 amountAREC = amountREC;\r\n\r\n            if(amount < amountAREC) {\r\n                require(solidifiedAmount != 0, 'ART: Amount Too Less');                // Must solidify the oldest AREC first\r\n                if(curAREC == latestARECID) break;\r\n                skips++;\r\n                preAREC = curAREC;\r\n                curAREC = allARECLiquidized[curAREC];\r\n            } else {\r\n                IArkreenRECIssuance(issuanceAREC).safeTransferFrom(address(this), solidifier, curAREC);\r\n                amount -= amountAREC;\r\n                solidifiedAmount += amountAREC;\r\n                numberAREC++;\r\n                curAREC = _remove(preAREC, curAREC);\r\n                if(curAREC == 0) break;\r\n            }\r\n        }\r\n\r\n        _burn(solidifier, solidifiedAmount);                    // solidifiedAmount must be more than 0 here, burn once to save gas\r\n        totalLiquidized -= solidifiedAmount;                    // \r\n\r\n        if(chargeOn) {\r\n            feeSolidify = solidifiedAmount * ratioFeeToSolidify / 10000;\r\n            _transfer(solidifier, receiverFee, feeSolidify);\r\n        }\r\n\r\n        emit Solidify(solidifier, solidifiedAmount, numberAREC, feeSolidify);      \r\n    }\r\n\r\n    /**\r\n     * @dev Remove the AREC NFT specified by curAREC from the liquidized list.\r\n     * @param preAREC The AREC NFT just previous in the list\r\n     * @param curAREC The AREC NFT to remove\r\n     * @return nextAREC the next AREC NFT ID if curAREC is not the last in the list\r\n     *         otherwise, returns 0 while curAREC is the last in the list\r\n     */\r\n    function _remove(uint256 preAREC, uint256 curAREC) internal returns (uint256 nextAREC) {\r\n        nextAREC = allARECLiquidized[curAREC];\r\n        allARECLiquidized[preAREC] = nextAREC;\r\n\r\n        if(curAREC == latestARECID) {                                   // if remove last AREC\r\n            latestARECID = (preAREC == latestARECID) ? 0 : preAREC;     // if the last AREC is the only AREC\r\n            nextAREC = 0;\r\n        } \r\n        delete allARECLiquidized[curAREC];                      // delete the current AREC\r\n    }\r\n\r\n     /// @dev Receive hook to liquidize Arkreen RE Certificate into RE ERC20 Token\r\n    function onERC721Received(\r\n        address, /* operator */\r\n        address from,\r\n        uint256 tokenId,\r\n        bytes calldata /* data */\r\n    ) external virtual override whenNotPaused returns (bytes4) {\r\n\r\n        // Check calling from REC Manager\r\n        require( IArkreenRegistry(arkreenRegistry).getRECIssuance() == msg.sender, 'ART: Not From REC Issuance');\r\n\r\n        (, uint128 amountREC, uint8 status, ) = IArkreenRECIssuance(msg.sender).getRECDataCore(tokenId);\r\n        require(status == uint256(RECStatus.Certified), 'ART: Wrong Status');\r\n        \r\n        if(latestARECID == 0) {\r\n            allARECLiquidized[tokenId] = tokenId;                           // build the loop list\r\n            latestARECID = tokenId;\r\n        } else {\r\n            allARECLiquidized[tokenId] = allARECLiquidized[latestARECID];   // Point to loop head\r\n            allARECLiquidized[latestARECID] = tokenId;                      // Add to the loop\r\n            latestARECID = tokenId;                                         // refresh the newest AREC\r\n        }\r\n\r\n        totalLiquidized += amountREC;\r\n\r\n        // Prepare liquidization fee \r\n        uint256 fee = 0;\r\n        if(ratioLiquidizedFee != 0 && receiverFee != address(0)) {\r\n            fee = amountREC * ratioLiquidizedFee / 10000;\r\n            _mint(receiverFee, fee);\r\n        }\r\n\r\n        _mint(from, amountREC - fee);\r\n\r\n        return this.onERC721Received.selector;\r\n    }\r\n\r\n    /**\r\n     * @dev set the ratio of liquidization fee\r\n     */     \r\n    function getARECInfo(uint256 number) external view returns (uint256 numAREC, ARECAmount[] memory amountAREC) {\r\n        amountAREC = new ARECAmount[](number);\r\n        if(latestARECID == 0) return (numAREC, amountAREC);\r\n\r\n        address issuanceAREC = IArkreenRegistry(arkreenRegistry).getRECIssuance();\r\n        uint256 curAREC = allARECLiquidized[latestARECID];\r\n        for(uint256 index; index < number; index++) {\r\n            amountAREC[index].ARECID = curAREC;\r\n            (, uint128 amountREC, , ) = IArkreenRECIssuance(issuanceAREC).getRECDataCore(curAREC);\r\n            amountAREC[index].amountREC = amountREC;\r\n            numAREC ++;\r\n            if(curAREC == latestARECID) break;\r\n            curAREC = allARECLiquidized[curAREC];\r\n        }\r\n    }  \r\n\r\n    function _msgSender() internal override view returns (address signer) {\r\n        signer = msg.sender;\r\n        if (msg.data.length>=20 && (signer == climateBuilder)) {\r\n            assembly {\r\n                signer := shr(96,calldataload(sub(calldatasize(),20)))\r\n            }\r\n        }    \r\n    }\r\n\r\n    /**\r\n     * @dev set the ratio of liquidization fee\r\n     */     \r\n    function setRatioFee(uint256 ratio) external onlyOwner {\r\n        require(ratio <10000, 'ART: Wrong Data');\r\n        ratioLiquidizedFee = ratio;\r\n    }  \r\n\r\n    /**\r\n     * @dev Change the REC issuance address\r\n     */     \r\n    function setIssuerREC(address issuer) external onlyOwner {\r\n        require(issuer != address(0), 'ART: Wrong Address');\r\n        issuerREC = issuer;\r\n    }\r\n\r\n    /**\r\n     * @dev set the ratio of solidify fee to Solidify from ART to AREC\r\n     */     \r\n    function setRatioFeeToSolidify(uint256 ratio) external onlyOwner {\r\n        require(ratio <10000, 'ART: Wrong Data');\r\n        ratioFeeToSolidify = ratio;\r\n    }  \r\n\r\n    /**\r\n     * @dev set the receiver of liquidization fee\r\n     */     \r\n    function setReceiverFee(address receiver) external onlyOwner {\r\n        require(receiver != address(0), 'ART: Wrong Address');\r\n        receiverFee = receiver;\r\n    }\r\n\r\n    function setTriggerAmount(uint256 amount) external onlyOwner {\r\n        triggerUpgradeAmount = amount;\r\n    }\r\n\r\n    function setClimateBuilder(address builder) external onlyOwner {\r\n        climateBuilder = builder;\r\n    }\r\n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/ERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (token/ERC20/ERC20.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IERC20Upgradeable.sol\";\nimport \"./extensions/IERC20MetadataUpgradeable.sol\";\nimport \"../../utils/ContextUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20PresetMinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin Contracts guidelines: functions revert\n * instead returning `false` on failure. This behavior is nonetheless\n * conventional and does not conflict with the expectations of ERC20\n * applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20Upgradeable is Initializable, ContextUpgradeable, IERC20Upgradeable, IERC20MetadataUpgradeable {\n    mapping(address => uint256) private _balances;\n\n    mapping(address => mapping(address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}.\n     *\n     * The default value of {decimals} is 18. To select a different value for\n     * {decimals} you should overload it.\n     *\n     * All two of these values are immutable: they can only be set once during\n     * construction.\n     */\n    function __ERC20_init(string memory name_, string memory symbol_) internal onlyInitializing {\n        __ERC20_init_unchained(name_, symbol_);\n    }\n\n    function __ERC20_init_unchained(string memory name_, string memory symbol_) internal onlyInitializing {\n        _name = name_;\n        _symbol = symbol_;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view virtual override returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5.05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless this function is\n     * overridden;\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view virtual override returns (uint8) {\n        return 18;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view virtual override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `to` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address to, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _transfer(owner, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * NOTE: If `amount` is the maximum `uint256`, the allowance is not updated on\n     * `transferFrom`. This is semantically equivalent to an infinite approval.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20}.\n     *\n     * NOTE: Does not update the allowance if the current allowance\n     * is the maximum `uint256`.\n     *\n     * Requirements:\n     *\n     * - `from` and `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``from``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        address spender = _msgSender();\n        _spendAllowance(from, spender, amount);\n        _transfer(from, to, amount);\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        _approve(owner, spender, allowance(owner, spender) + addedValue);\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        address owner = _msgSender();\n        uint256 currentAllowance = allowance(owner, spender);\n        require(currentAllowance >= subtractedValue, \"ERC20: decreased allowance below zero\");\n        unchecked {\n            _approve(owner, spender, currentAllowance - subtractedValue);\n        }\n\n        return true;\n    }\n\n    /**\n     * @dev Moves `amount` of tokens from `from` to `to`.\n     *\n     * This internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `from` cannot be the zero address.\n     * - `to` cannot be the zero address.\n     * - `from` must have a balance of at least `amount`.\n     */\n    function _transfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {\n        require(from != address(0), \"ERC20: transfer from the zero address\");\n        require(to != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(from, to, amount);\n\n        uint256 fromBalance = _balances[from];\n        require(fromBalance >= amount, \"ERC20: transfer amount exceeds balance\");\n        unchecked {\n            _balances[from] = fromBalance - amount;\n        }\n        _balances[to] += amount;\n\n        emit Transfer(from, to, amount);\n\n        _afterTokenTransfer(from, to, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply += amount;\n        _balances[account] += amount;\n        emit Transfer(address(0), account, amount);\n\n        _afterTokenTransfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements:\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        uint256 accountBalance = _balances[account];\n        require(accountBalance >= amount, \"ERC20: burn amount exceeds balance\");\n        unchecked {\n            _balances[account] = accountBalance - amount;\n        }\n        _totalSupply -= amount;\n\n        emit Transfer(account, address(0), amount);\n\n        _afterTokenTransfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner` s tokens.\n     *\n     * This internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Updates `owner` s allowance for `spender` based on spent `amount`.\n     *\n     * Does not update the allowance amount in case of infinite allowance.\n     * Revert if not enough allowance is available.\n     *\n     * Might emit an {Approval} event.\n     */\n    function _spendAllowance(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        uint256 currentAllowance = allowance(owner, spender);\n        if (currentAllowance != type(uint256).max) {\n            require(currentAllowance >= amount, \"ERC20: insufficient allowance\");\n            unchecked {\n                _approve(owner, spender, currentAllowance - amount);\n            }\n        }\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev Hook that is called after any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * has been transferred to `to`.\n     * - when `from` is zero, `amount` tokens have been minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens have been burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual {}\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[45] private __gap;\n}\n"
    },
    "contracts/interfaces/IArkreenBadge.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IArkreenBadge {\n    function registerOffset(address, address, uint256, uint256) external returns (uint256);\n    function mintCertificate(address, address, string calldata, string calldata,\n                              string calldata, uint256[] calldata) external;\n    function getDetailStatus(address) external view returns (uint256, uint256);\n    function registerDetail(uint256 amount, uint256 tokenId, bool bNew) external returns (uint256, uint256);    \n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/IERC20Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/IERC20.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20Upgradeable {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/IERC20MetadataUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/IERC20Metadata.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IERC20Upgradeable.sol\";\n\n/**\n * @dev Interface for the optional metadata functions from the ERC20 standard.\n *\n * _Available since v4.1._\n */\ninterface IERC20MetadataUpgradeable is IERC20Upgradeable {\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() external view returns (string memory);\n\n    /**\n     * @dev Returns the symbol of the token.\n     */\n    function symbol() external view returns (string memory);\n\n    /**\n     * @dev Returns the decimals places of the token.\n     */\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/HashKeyESGBTC.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\r\nimport '@openzeppelin/contracts/token/ERC721/IERC721Receiver.sol';\r\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\r\n\r\nimport \"./interfaces/IPausable.sol\";\r\nimport \"./interfaces/IERC5192.sol\";\r\nimport \"./ArkreenBuilderTypes.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\nimport \"./interfaces/IERC20Permit.sol\";\r\n\r\n// Import this file to use console.log\r\n//import \"hardhat/console.sol\";\r\n\r\ncontract HashKeyESGBTC is\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    ERC721EnumerableUpgradeable,\r\n    IERC5192\r\n{\r\n    using AddressUpgradeable for address;\r\n\r\n    // Public variables\r\n    string  public    constant NAME             = 'Eco Coiner';\r\n    string  public    constant SYMBOL           = 'EC';\r\n    uint256 public    constant ART_DECIMAL      = 9;\r\n    uint256 private   constant MAX_BRICK_ID     = 4096;\r\n    uint256 private   constant MASK_ID          = 0xFFF;\r\n\r\n    string  public baseURI;\r\n    address public tokenHART;                         // HashKey Pro ART\r\n    address public arkreenBuilder;\r\n    address public tokenNative;                         // The wrapped token of the Native token, such as WETH, WMATIC\r\n    mapping(uint256 => uint256) public brickIds;        // Green Id -> Owned brick id list, maximumly 21 bricks, 12 bits each\r\n    mapping(uint256 => uint256) public greenIdLoc;      // Brick Id -> Green Id\r\n    mapping(uint256 => uint256[]) public brickIdsMVP;   // Green Id -> bricks id more than 21 cells\r\n    uint256 public ESGBadgeLimit;                       // Limit of each level of ESG badge, one byte for one level, starting from low end\r\n    uint256 public ESGBadgeCount;                       // Count of each level of ESG badge, one byte for one level, starting from low end\r\n\r\n    // The total REC amount to greenize the BTC block mined at the same time of HashKey Pro opening ceremony\r\n    uint256 public maxRECToGreenBTC;\r\n\r\n    mapping(uint256 => uint256) public levelOrder;      // Green Id -> level + order in level\r\n    mapping(uint256 => string)  public cidBadge;        // Green Id -> cID\r\n\r\n    mapping(address => bool)  public whiteARTList;      // ART token -> true/false\r\n\r\n    // Events\r\n\r\n    // Modifiers\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'HSKESG: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize(address builder, address hArt, address native, uint256 numBlock) external virtual initializer {\r\n        __Ownable_init_unchained();\r\n        __UUPSUpgradeable_init();        \r\n        __ERC721_init_unchained(NAME, SYMBOL);\r\n\r\n        arkreenBuilder      = builder; \r\n        tokenHART           = hArt;\r\n        tokenNative         = native;\r\n        maxRECToGreenBTC    = numBlock;\r\n\r\n        baseURI = 'https://www.arkreen.com/ESGBTC/' ;\r\n    }   \r\n\r\n    function postUpdate(uint256[] calldata order) external onlyProxy onlyOwner {\r\n        for(uint256 index; index < order.length; index++) {\r\n            levelOrder[index+1] = order[index];\r\n        }\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner\r\n    {}\r\n\r\n    /** \r\n     * @dev Greenize BTC with Native token, such as MATIC.\r\n     * @param bricksToGreen The brick ID list in the format of IDn || ... || ID2 || ID1, each of which is 12 bits.\r\n     * @param deadline The deadline to cancel the transaction.\r\n     * @param badgeInfo The information to be included for climate badge.\r\n     */\r\n    function greenizeBTCNative(\r\n        uint256             bricksToGreen,      \r\n        uint256             deadline,\r\n        BadgeInfo calldata  badgeInfo\r\n    ) external payable ensure(deadline) {                       // Deadline will be checked by router, no need to check here. \r\n\r\n        address actorGreenBTC = _msgSender();\r\n        uint256 amountART = _mintESGBadge(actorGreenBTC, bricksToGreen);        \r\n        \r\n        // Wrap MATIC to WMATIC  \r\n        IWETH(tokenNative).deposit{value: msg.value}();\r\n\r\n        // actionBuilderBadge(address,address,uint256,uint256,uint256,uint256,(address,string,string,string)): 0x8D7FCEFD\r\n        uint256 modeAction = (bricksToGreen>>255)<<1;     \r\n        bytes memory callData = abi.encodeWithSelector(0x8D7FCEFD, tokenNative, tokenHART, msg.value,\r\n                                                        amountART, modeAction, deadline, badgeInfo);\r\n\r\n        _actionBuilderBadge(abi.encodePacked(callData, actorGreenBTC));     // Pay back to msg.sender already\r\n    }\r\n\r\n    function greenizeBTCNativeMVP(\r\n        uint256             bricksToGreen,   \r\n        uint256[] memory    bricksToGreenMVP,           \r\n        uint256             deadline,\r\n        BadgeInfo calldata  badgeInfo\r\n    ) external payable ensure(deadline) {                       // Deadline will be checked by router, no need to check here. \r\n\r\n        address actorGreenBTC = _msgSender();\r\n        uint256 amountART = _mintESGBadgeMVP(actorGreenBTC, bricksToGreen, bricksToGreenMVP);        \r\n        \r\n        // Wrap MATIC to WMATIC  \r\n        IWETH(tokenNative).deposit{value: msg.value}();\r\n\r\n        // actionBuilderBadge(address,address,uint256,uint256,uint256,uint256,(address,string,string,string)): 0x8D7FCEFD\r\n        uint256 modeAction = (bricksToGreen>>255)<<1;     \r\n        bytes memory callData = abi.encodeWithSelector(0x8D7FCEFD, tokenNative, tokenHART, msg.value,\r\n                                                        amountART, modeAction, deadline, badgeInfo);\r\n\r\n        _actionBuilderBadge(abi.encodePacked(callData, actorGreenBTC));     // Pay back to msg.sender already\r\n\r\n    }\r\n\r\n    /** \r\n     * @dev Greenize BTC with specified ART token\r\n     * @param tokenART Address of the ART token, which should be whitelisted in the accepted list.\r\n     * @param bricksToGreen The brick ID list in the format of IDn || ... || ID2 || ID1, each of which is 12 bits\r\n     * @param deadline The deadline to cancel the transaction\r\n     * @param badgeInfo The information to be included for climate badge\r\n     */\r\n    function greenizeBTCWithART(\r\n        address             tokenART,\r\n        uint256             bricksToGreen,   \r\n        uint256             deadline,        \r\n        BadgeInfo calldata  badgeInfo\r\n    ) external ensure(deadline) {\r\n\r\n        require(whiteARTList[tokenART], \"HSKESG: ART Not Accepted\"); \r\n\r\n        address actorGreenBTC = _msgSender();\r\n        uint256 amountART = _mintESGBadge(actorGreenBTC, bricksToGreen);\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(tokenART, actorGreenBTC, address(this), amountART);\r\n\r\n        // actionBuilderBadgeWithART(address,uint256,uint256,(address,string,string,string)): 0x6E556DF8\r\n        bytes memory callData = abi.encodeWithSelector(0x6E556DF8, tokenART, amountART, deadline, badgeInfo);\r\n\r\n        _actionBuilderBadge(abi.encodePacked(callData, actorGreenBTC));\r\n    }\r\n\r\n\r\n    /** \r\n     * @dev Greenize BTC with specified payment token\r\n     * @param tokenPay The token to pay for swapping ART token\r\n     * @param amountPay The maximum amount of tokenPay which will de paid\r\n     * @param bricksToGreen The brick ID list in the format of IDn || ... || ID2 || ID1, each of which is 12 bits\r\n     * @param deadline The deadline to cancel the transaction\r\n     * @param badgeInfo The information to be included for climate badge\r\n     */\r\n    function greenizeBTC(\r\n        address             tokenPay,\r\n        uint256             amountPay,\r\n        uint256             bricksToGreen,   \r\n        uint256             deadline,        \r\n        BadgeInfo calldata  badgeInfo\r\n    ) external ensure(deadline) {                               // Deadline will be checked by router, no need to check here.\r\n\r\n        address actorGreenBTC = _msgSender();\r\n        uint256 amountART = _mintESGBadge(actorGreenBTC, bricksToGreen);\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(tokenPay, actorGreenBTC, address(this), amountPay);\r\n        \r\n        // actionBuilderBadge(address,address,uint256,uint256,uint256,uint256,(address,string,string,string)): 0x8D7FCEFD\r\n        uint256 modeAction = (bricksToGreen>>255)<<1;\r\n        bytes memory callData = abi.encodeWithSelector(0x8D7FCEFD, tokenPay, tokenHART, amountPay,\r\n                                                        amountART, modeAction, deadline, badgeInfo);\r\n\r\n        _actionBuilderBadge(abi.encodePacked(callData, actorGreenBTC));\r\n    }\r\n\r\n    function greenizeBTCMVP(\r\n        address             tokenPay,\r\n        uint256             amountPay,\r\n        uint256             bricksToGreen,   \r\n        uint256[] memory    bricksToGreenMVP,\r\n        uint256             deadline,        \r\n        BadgeInfo calldata  badgeInfo\r\n    ) external ensure(deadline) {                               // Deadline will be checked by router, no need to check here.\r\n\r\n        address actorGreenBTC = _msgSender();\r\n        uint256 amountART = _mintESGBadgeMVP(actorGreenBTC, bricksToGreen, bricksToGreenMVP);\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(tokenPay, actorGreenBTC, address(this), amountPay);\r\n        \r\n        // actionBuilderBadge(address,address,uint256,uint256,uint256,uint256,(address,string,string,string)): 0x8D7FCEFD\r\n        uint256 modeAction = (bricksToGreen>>255)<<1;\r\n        bytes memory callData = abi.encodeWithSelector(0x8D7FCEFD, tokenPay, tokenHART, amountPay,\r\n                                                        amountART, modeAction, deadline, badgeInfo);\r\n\r\n        _actionBuilderBadge(abi.encodePacked(callData, actorGreenBTC));\r\n    }\r\n\r\n    /** \r\n     * @dev Greenize BTC with payment Approval.\r\n     * @param bricksToGreen The brick ID list in the format of IDn || ... || ID2 || ID1, each of which is 12 bits.\r\n     * @param badgeInfo The information to be included for climate badge.\r\n     * @param permitToPay The Permit information to approve the payment token to swap for ART token \r\n     */\r\n    function greenizeBTCPermit(\r\n        uint256             bricksToGreen,      \r\n        BadgeInfo calldata  badgeInfo,\r\n        Signature calldata  permitToPay\r\n    ) external ensure(permitToPay.deadline) {                     // Deadline will be checked by router, no need to check here. \r\n\r\n        address actorGreenBTC = _msgSender();\r\n        uint256 amountART = _mintESGBadge(actorGreenBTC, bricksToGreen);\r\n\r\n        // Permit payment token\r\n        IERC20Permit(permitToPay.token).permit(actorGreenBTC, address(this), \r\n                        permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(permitToPay.token, actorGreenBTC, address(this), permitToPay.value);\r\n\r\n        // actionBuilderBadge(address,address,uint256,uint256,uint256,uint256,(address,string,string,string)): 0x8D7FCEFD\r\n        uint256 modeAction = (bricksToGreen>>255)<<1;\r\n        bytes memory callData = abi.encodeWithSelector(0x8D7FCEFD, permitToPay.token, tokenHART, permitToPay.value,\r\n                                                        amountART, modeAction, permitToPay.deadline, badgeInfo);\r\n\r\n        _actionBuilderBadge(abi.encodePacked(callData, actorGreenBTC));\r\n    }\r\n\r\n    /** \r\n     * @dev Greenize BTC with payment Approval.\r\n     * @param bricksToGreen The brick ID list in the format of IDn || ... || ID2 || ID1, each of which is 12 bits.\r\n     * @param badgeInfo The information to be included for climate badge.\r\n     * @param permitToPay The Permit information to approve the payment token to swap for ART token \r\n     */\r\n    function greenizeBTCPermitMVP(\r\n        uint256             bricksToGreen,\r\n        uint256[] memory    bricksToGreenMVP,\r\n        BadgeInfo calldata  badgeInfo,\r\n        Signature calldata  permitToPay\r\n    ) external ensure(permitToPay.deadline) {                     // Deadline will be checked by router, no need to check here. \r\n\r\n        address actorGreenBTC = _msgSender();\r\n        uint256 amountART = _mintESGBadgeMVP(actorGreenBTC, bricksToGreen, bricksToGreenMVP);\r\n\r\n        // Permit payment token\r\n        IERC20Permit(permitToPay.token).permit(actorGreenBTC, address(this), \r\n                        permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(permitToPay.token, actorGreenBTC, address(this), permitToPay.value);\r\n\r\n        // actionBuilderBadge(address,address,uint256,uint256,uint256,uint256,(address,string,string,string)): 0x8D7FCEFD\r\n        uint256 modeAction = (bricksToGreen>>255)<<1;\r\n        bytes memory callData = abi.encodeWithSelector(0x8D7FCEFD, permitToPay.token, tokenHART, permitToPay.value,\r\n                                                        amountART, modeAction, permitToPay.deadline, badgeInfo);\r\n\r\n        _actionBuilderBadge(abi.encodePacked(callData, actorGreenBTC));\r\n    }\r\n\r\n\r\n    /** \r\n     * @dev mint ESGBadge to the greenActor\r\n     * @param actorGreenBTC The address of the actor\r\n     * @param bricksToGreen The brick ID list in the format of IDn || ... || ID2 || ID1, each of which is 12 bits\r\n     * @return uint256 The amount ART token to pay for the ESG badge\r\n     */\r\n    function _mintESGBadge(address actorGreenBTC, uint256 bricksToGreen) internal returns (uint256){\r\n        uint256 amountART;\r\n        uint256 brickID;\r\n\r\n        require( bricksToGreen > 0, \"HSKESG: Wrong IDs\");\r\n\r\n        bricksToGreen = (bricksToGreen<<4) >> 4;                            // clear 4 msb, uint252\r\n        uint256 greenId = totalSupply() + 1;\r\n        _safeMint(actorGreenBTC, greenId);\r\n        brickIds[greenId] = bricksToGreen;\r\n\r\n        while( (brickID = (bricksToGreen & MASK_ID)) != 0) {\r\n            amountART += 1;\r\n            setBrick(brickID, greenId);\r\n            bricksToGreen = bricksToGreen >> 12;\r\n        }\r\n\r\n        uint256 levelOffet = ((amountART-1)/3) * 8;\r\n        uint256 limit = (ESGBadgeLimit >> levelOffet) & 0xFF; \r\n        uint256 count = (ESGBadgeCount >> levelOffet) & 0xFF; \r\n\r\n        require( count < limit, \"HSKESG: Reach Limit\");\r\n        ESGBadgeCount += (1 << levelOffet);                     // Add count, no overflow happens here\r\n\r\n        levelOrder[greenId] = (((levelOffet/8) + 1) << 8) + (count + 1);\r\n\r\n        return amountART * 2 * (10**ART_DECIMAL);               // 1 Cell -> 2 ART token \r\n    }\r\n\r\n    /** \r\n     * @dev mint ESGBadge to the greenActor\r\n     * @param actorGreenBTC The address of the actor\r\n     * @param bricksToGreen The brick ID list in the format of IDn || ... || ID2 || ID1, each of which is 12 bits\r\n     * @return uint256 The amount ART token to pay for the ESG badge\r\n     */\r\n    function _mintESGBadgeMVP(address actorGreenBTC, uint256 bricksToGreen, uint256[] memory bricksToGreenMVP) internal returns (uint256) {\r\n        uint256 amountART;\r\n        uint256 brickID;\r\n\r\n        require( bricksToGreen > 0, \"HSKESG: Wrong IDs\");\r\n\r\n        bricksToGreen = (bricksToGreen<<4) >> 4;                            // clear 4 msb, uint252\r\n        uint256 greenId = totalSupply() + 1;\r\n        _safeMint(actorGreenBTC, greenId);\r\n\r\n        uint256 flagMVP = (bricksToGreenMVP.length > 0) ? (1<<255) : 0;\r\n        brickIds[greenId] = bricksToGreen | flagMVP;\r\n\r\n        while( (brickID = (bricksToGreen & MASK_ID)) != 0) {\r\n            amountART += 1;\r\n            setBrick(brickID, greenId);\r\n            bricksToGreen = bricksToGreen >> 12;\r\n        }\r\n        \r\n        if(bricksToGreenMVP.length > 0 ) {\r\n          require (amountART == 21, \"HSKESG: Not MVP\"); \r\n          brickIdsMVP[greenId] = bricksToGreenMVP;\r\n\r\n          for (uint256 index; index < bricksToGreenMVP.length; index++) {\r\n            bricksToGreen = (bricksToGreenMVP[index]<<4) >> 4;\r\n            while( (brickID = (bricksToGreen & MASK_ID)) != 0) {\r\n                amountART += 1;\r\n                setBrick(brickID, greenId);\r\n                bricksToGreen = bricksToGreen >> 12;\r\n            }\r\n          }\r\n        }\r\n\r\n        uint256 levelOffet = (amountART >= 22) ? 7*8 : ((amountART-1)/3) * 8;\r\n        uint256 limit = (ESGBadgeLimit >> levelOffet) & 0xFF; \r\n        uint256 count = (ESGBadgeCount >> levelOffet) & 0xFF; \r\n\r\n        require( count < limit, \"HSKESG: Reach Limit\");\r\n        ESGBadgeCount += (1 << levelOffet);                     // Add count, no overflow happens here     \r\n\r\n        levelOrder[greenId] =  (((levelOffet/8) + 1) << 8) + (count + 1);\r\n   \r\n        return amountART * 2 * (10**ART_DECIMAL);             // 1 Cell -> 2 ART token \r\n    }\r\n\r\n\r\n    /** \r\n     * @dev call actionBuilderBadge to buy ART token and mint the Arkreen cliamte badge.\r\n     * @param callData The calling data with actors address attached\r\n     */\r\n    function _actionBuilderBadge(bytes memory callData) internal {\r\n        (bool success, bytes memory returndata) = arkreenBuilder.call(callData);\r\n\r\n         if (!success) {\r\n            if (returndata.length > 0) {\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\"HSKESG: Error Call to actionBuilderBadge\");\r\n            }\r\n        }        \r\n    }\r\n\r\n    /** \r\n     * @dev set the greenId to the given brick\r\n     */\r\n    function setBrick(uint256 brickId, uint256 greenId) internal {                           //  brickId starts from 1\r\n        require((brickId != 0) || (brickId <= maxRECToGreenBTC), \"HSKESG: Wrong Brick ID\");\r\n        require( greenIdLoc[brickId] == 0,  \"HSKESG: Brick Occupied\");\r\n        greenIdLoc[brickId] = greenId;\r\n    }\r\n\r\n    /** \r\n     * @dev Return the given brick information: owner, greenId, and all sibbling bricks\r\n     */\r\n    function ownerBricks(uint256 brickId) external view returns (address owner, uint256 greenId, uint256 bricks) {\r\n        require((brickId != 0) || (brickId <= maxRECToGreenBTC), \"HSKESG: Wrong Brick ID\");\r\n        greenId = greenIdLoc[brickId];\r\n        owner = ownerOf(greenId);\r\n        bricks = brickIds[greenId];\r\n    }\r\n\r\n    /** \r\n     * @dev Check if the given brick occupied\r\n     */\r\n    function checkBrick(uint256 brickId) external view returns (bool) {         //  brickId starts from 1\r\n        require((brickId != 0) || (brickId <= maxRECToGreenBTC), \"HSKESG: Wrong Brick ID\");\r\n        return greenIdLoc[brickId] != 0;\r\n    }    \r\n\r\n\r\n    /** \r\n     * @dev Update the ESGBadgeLimit\r\n     */\r\n    function UpdateESGBadgeLimit(uint256 limit, uint256 count ) external onlyOwner {    \r\n        if(limit!=0)  ESGBadgeLimit = limit;\r\n        if(count!=0) ESGBadgeCount = count;\r\n    }    \r\n\r\n    /** \r\n     * @dev Get the all MVP blocks of the specified GreenID\r\n     */\r\n    function getMVPBlocks(uint256 greenId) external view returns (uint256[] memory bricksMVP) {         //  brickId starts from 1\r\n        return brickIdsMVP[greenId];\r\n    }       \r\n\r\n    /**\r\n     * @dev update the maximum REC number to green BTC block\r\n     * @param amountREC type of the managing account\r\n     */\r\n    function setRECAmount(uint256 amountREC) external onlyOwner {\r\n        maxRECToGreenBTC = amountREC;\r\n    }\r\n\r\n    /**\r\n     * @dev Approve the token that the  arkreenBuilder smart contract can transfer from this ESG smart contract\r\n     * @param tokens The token list\r\n     */\r\n    function approveBuilder(address[] calldata tokens) external onlyOwner {\r\n        require(arkreenBuilder != address(0), \"HSKESG: No Builder\");\r\n        for(uint256 i = 0; i < tokens.length; i++) {\r\n            TransferHelper.safeApprove(tokens[i], arkreenBuilder, type(uint256).max);\r\n        }\r\n    }       \r\n\r\n    /**\r\n     * @dev Add or remove the acceptable ART tokens\r\n     */\r\n    function mangeARTTokens(address[] calldata tokenARTList, bool addOrRemove) external onlyOwner {\r\n        for(uint256 i = 0; i < tokenARTList.length; i++) {\r\n            address tokenART = tokenARTList[i];\r\n\r\n            require(tokenART != address(0) && whiteARTList[tokenART] != addOrRemove, \"HSKESG: Wrong ART Status\");\r\n            whiteARTList[tokenART] = addOrRemove;\r\n        }\r\n    }      \r\n\r\n    /** \r\n     * @dev Change the BaseURI\r\n     */\r\n    function setBaseURI(string calldata newBaseURI) external virtual onlyOwner {\r\n        baseURI = newBaseURI;\r\n    }\r\n\r\n    function _baseURI() internal view virtual override returns (string memory) {\r\n        return baseURI;\r\n    }\r\n\r\n    /**\r\n     * @dev See {IERC721Metadata-tokenURI}.\r\n     */\r\n    function tokenURI(uint256 tokenId) public view virtual override returns (string memory) {\r\n        _requireMinted(tokenId);\r\n\r\n        string memory cid = cidBadge[levelOrder[tokenId]];\r\n        if( bytes(cid).length > 0) {\r\n            return string(abi.encodePacked(\"https://\", cid, \".ipfs.w3s.link\"));\r\n        } else {\r\n            return super.tokenURI(tokenId);\r\n        }\r\n    }    \r\n\r\n    function updateCID(uint256 level, uint256 limit, bytes calldata allCID) external virtual onlyOwner {\r\n        uint256 length = allCID.length;\r\n        uint256 offset = 0;\r\n        for(uint256 idxLevel = (level & 0xFF); idxLevel <= (level >> 8); idxLevel++) {\r\n            uint256 levelLimit = limit & 0xFF;\r\n            limit = limit >> 8;\r\n            for(uint256 idxLimit = 1; idxLimit <= levelLimit; idxLimit++ ) {\r\n                uint256 badgeID = (idxLevel<<8) + idxLimit;\r\n                require( (offset+59) <= length, \"ARB: Overflowed\");\r\n                cidBadge[badgeID] = string(abi.encodePacked(allCID[offset: offset + 59]));\r\n                offset += 59;\r\n            }\r\n        }\r\n    }        \r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer. Blocking transfer unless minting\r\n     */\r\n/*    \r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override (ERC721EnumerableUpgradeable) {\r\n        require(from == address(0), 'ARB: Transfer Not Allowed');\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n*/\r\n\r\n    /**\r\n     * @dev get all the brick IDs with in th scope specified by the paramters\r\n     * @param tokeIDStart the starting token ID, from which all brick IDs are returned\r\n     * @param tokeIDEnd the starting token ID, till which all brick IDs are retured\r\n     */\r\n    function getAllBrickIDs(uint256 tokeIDStart, uint256 tokeIDEnd) \r\n                external view returns (uint256 totalTokens, address[] memory owners, uint256[] memory allBricks) {\r\n\r\n        totalTokens = totalSupply();\r\n        if(tokeIDEnd == 0) tokeIDEnd = totalTokens;\r\n        require( (tokeIDStart >= 1) && (tokeIDStart <= tokeIDEnd) && (tokeIDEnd <= totalTokens), 'ARB: Wrong tokeID');\r\n\r\n        owners =  new address[](tokeIDEnd - tokeIDStart + 1);\r\n        allBricks = new uint256[](tokeIDEnd - tokeIDStart + 1);\r\n        uint256 offset;\r\n        for (uint256 index = tokeIDStart; index <= tokeIDEnd; index++ ) {\r\n            owners[offset] = ownerOf(index);\r\n            allBricks[offset] = brickIds[index];\r\n            offset += 1;\r\n        }\r\n    }\r\n\r\n    function locked(uint256 tokenId) external view returns (bool) {\r\n        require((tokenId > 0) && (tokenId <= totalSupply()), 'ARB: Wrong tokenId');\r\n        return true;  \r\n    }\r\n}\r\n"
    },
    "contracts/ArkreenBuilderTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nstruct twinPair {\r\n    address     poolAB;\r\n    address     poolBA;\r\n}\r\n\r\nstruct Signature {\r\n    address     token;\r\n    uint256     value;\r\n    uint256     deadline;  \r\n    uint8       v;\r\n    bytes32     r;\r\n    bytes32     s;              \r\n}\r\n\r\nstruct SigRegister {\r\n    uint8       v;\r\n    bytes32     r;\r\n    bytes32     s;              \r\n}\r\n\r\nstruct BadgeInfo {\r\n    address     beneficiary;\r\n    string      offsetEntityID;\r\n    string      beneficiaryID;\r\n    string      offsetMessage;\r\n}"
    },
    "contracts/interfaces/IWETH.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IWETH {\n    function deposit() external payable;\n    function transfer(address to, uint value) external returns (bool);\n    function withdraw(uint) external;\n}"
    },
    "contracts/interfaces/IERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20Permit {\n    /**\n     * @dev Sets `value` as th xe allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "contracts/types/ERC20Permit.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity >=0.8.4 <=0.8.14;\n\nimport \"../interfaces/IERC20Permit.sol\";\nimport \"./ERC20.sol\";\nimport \"../types/EIP712.sol\";\nimport \"../libraries/ECDSA.sol\";\nimport \"../libraries/Counters.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n */\nabstract contract ERC20Permit is ERC20, IERC20Permit, EIP712 {\n    using Counters for Counters.Counter;\n\n    mapping(address => Counters.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private immutable _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    constructor(string memory name) EIP712(name, \"1\") {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSA.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        Counters.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n}\n"
    },
    "contracts/types/ERC20.sol": {
      "content": "// SPDX-License-Identifier: AGPL-3.0-or-later\npragma solidity >=0.8.4 <=0.8.14;\n\nimport \"../libraries/SafeMath.sol\";\nimport \"../interfaces/IERC20.sol\";\n\nabstract contract ERC20 is IERC20 {\n    using SafeMath for uint256;\n\n    // TODO comment actual hash value.\n    bytes32 private constant ERC20TOKEN_ERC1820_INTERFACE_ID = keccak256(\"ERC20Token\");\n\n    mapping(address => uint256) internal _balances;\n\n    mapping(address => mapping(address => uint256)) internal _allowances;\n\n    uint256 internal _totalSupply;\n\n    string internal _name;\n\n    string internal _symbol;\n\n    uint8 internal immutable _decimals;\n\n    constructor(\n        string memory name_,\n        string memory symbol_,\n        uint8 decimals_\n    ) {\n        _name = name_;\n        _symbol = symbol_;\n        _decimals = decimals_;\n    }\n\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    function decimals() public view virtual returns (uint8) {\n        return _decimals;\n    }\n\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    function balanceOf(address account) public view virtual override returns (uint256) {\n        return _balances[account];\n    }\n\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(msg.sender, recipient, amount);\n        return true;\n    }\n\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(msg.sender, spender, amount);\n        return true;\n    }\n\n    function transferFrom(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(\n            sender,\n            msg.sender,\n            _allowances[sender][msg.sender].sub(amount, \"ERC20: transfer amount exceeds allowance\")\n        );\n        return true;\n    }\n\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(msg.sender, spender, _allowances[msg.sender][spender].add(addedValue));\n        return true;\n    }\n\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(\n            msg.sender,\n            spender,\n            _allowances[msg.sender][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\")\n        );\n        return true;\n    }\n\n    function _transfer(\n        address sender,\n        address recipient,\n        uint256 amount\n    ) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n        _beforeTokenTransfer(address(0), account, amount);\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    function _approve(\n        address owner,\n        address spender,\n        uint256 amount\n    ) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    function _beforeTokenTransfer(\n        address from_,\n        address to_,\n        uint256 amount_\n    ) internal virtual {}\n}\n"
    },
    "contracts/types/EIP712.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../libraries/ECDSA.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n */\nabstract contract EIP712 {\n    /* solhint-disable var-name-mixedcase */\n    // Cache the domain separator as an immutable value, but also store the chain id that it corresponds to, in order to\n    // invalidate the cached domain separator if the chain id changes.\n    bytes32 private immutable _CACHED_DOMAIN_SEPARATOR;\n    uint256 private immutable _CACHED_CHAIN_ID;\n\n    bytes32 private immutable _HASHED_NAME;\n    bytes32 private immutable _HASHED_VERSION;\n    bytes32 private immutable _TYPE_HASH;\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    constructor(string memory name, string memory version) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        bytes32 typeHash = keccak256(\n            \"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\"\n        );\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n        _CACHED_CHAIN_ID = chainID;\n        _CACHED_DOMAIN_SEPARATOR = _buildDomainSeparator(typeHash, hashedName, hashedVersion);\n        _TYPE_HASH = typeHash;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        if (chainID == _CACHED_CHAIN_ID) {\n            return _CACHED_DOMAIN_SEPARATOR;\n        } else {\n            return _buildDomainSeparator(_TYPE_HASH, _HASHED_NAME, _HASHED_VERSION);\n        }\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        uint256 chainID;\n        assembly {\n            chainID := chainid()\n        }\n\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, chainID, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSA.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n}\n"
    },
    "contracts/libraries/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "contracts/libraries/Counters.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./SafeMath.sol\";\n\nlibrary Counters {\n    using SafeMath for uint256;\n\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        // The {SafeMath} overflow check can be skipped here, see the comment at the top\n        counter._value += 1;\n    }\n\n    function decrement(Counter storage counter) internal {\n        counter._value = counter._value.sub(1);\n    }\n}\n"
    },
    "contracts/libraries/SafeMath.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nlibrary SafeMath {\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    function sub(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    function div(\n        uint256 a,\n        uint256 b,\n        string memory errorMessage\n    ) internal pure returns (uint256) {\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        assert(a == b * c + (a % b)); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    // Only used in the  BondingCalculator.sol\n    function sqrrt(uint256 a) internal pure returns (uint256 c) {\n        if (a > 3) {\n            c = a;\n            uint256 b = add(div(a, 2), 1);\n            while (b < c) {\n                c = b;\n                b = div(add(div(a, b), b), 2);\n            }\n        } else if (a != 0) {\n            c = 1;\n        }\n    }\n}\n"
    },
    "contracts/interfaces/IERC20.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `to`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address to, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `from` to `to` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(\n        address from,\n        address to,\n        uint256 amount\n    ) external returns (bool);\n}\n"
    },
    "contracts/interfaces/IERC20Metadata.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./IERC20.sol\";\n\ninterface IERC20Metadata is IERC20 {\n    function name() external view returns (string memory);\n\n    function symbol() external view returns (string memory);\n\n    function decimals() external view returns (uint8);\n}\n"
    },
    "contracts/ArkreenRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\r\n\r\nimport \"./interfaces/IMinerRegister.sol\";\r\nimport \"./interfaces/IArkreenRegistry.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\nimport \"./ArkreenRegistryStorage.sol\";\r\n\r\ncontract ArkreenRegistry is\r\n    OwnableUpgradeable,\r\n    PausableUpgradeable,\r\n    AccessControlUpgradeable,\r\n    UUPSUpgradeable,\r\n    ArkreenRegistryStorage\r\n{    \r\n    using AddressUpgradeable for address;\r\n\r\n    // Constants\r\n    bytes32 public constant PAUSER_ROLE = keccak256('PAUSER_ROLE');\r\n\r\n    modifier checkAddress(address addressToCheck) {\r\n        require(addressToCheck != address(0), 'Arkreen: Zero Address');\r\n        require(addressToCheck.isContract(), \"Arkreen: Wrong Contract Address\");\r\n        _;\r\n    }\r\n\r\n    /// @dev modifier that only lets the contract's owner and granted pausers pause the system\r\n    modifier onlyPausers() {\r\n        require(\r\n            hasRole(PAUSER_ROLE, msg.sender) || owner() == msg.sender,\r\n            'Arkreen: Caller Not Allowed'\r\n        );\r\n        _;\r\n    }\r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n  \r\n    function initialize() external virtual initializer {\r\n        __Ownable_init_unchained();\r\n        __Pausable_init_unchained();\r\n        __AccessControl_init_unchained();                \r\n        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation)\r\n        internal\r\n        virtual\r\n        override\r\n        onlyOwner\r\n    {}\r\n\r\n    /// @dev Emergency function to pause the system\r\n    function pause() external virtual onlyPausers {\r\n        _pause();\r\n    }\r\n\r\n    /// @dev unpause the system\r\n    function unpause() external virtual onlyPausers {\r\n        _unpause();\r\n    }\r\n\r\n    function addRECIssuer(address issuer, address tokenREC, string memory issuerId) external virtual onlyOwner {\r\n        require(issuer != address(0), 'Arkreen: Zero Address');\r\n        require(tokenREC.isContract(), 'Arkreen: Wrong Token Address');\r\n\r\n        require(recIssuers[issuer].addTime == uint64(0), 'Arkreen: Issuer Already Added');\r\n\r\n        unchecked { ++numIssuers; }\r\n        IssuerStatus memory issuerStatus = IssuerStatus(true, uint64(block.timestamp), uint64(0), tokenREC, issuerId);\r\n        recIssuers[issuer] = issuerStatus;\r\n        tokenRECs[tokenREC] = issuer;\r\n        allIssuers[numIssuers] = issuer;\r\n    }\r\n\r\n    function removeRECIssuer(address issuer) external virtual onlyOwner {\r\n        require(issuer != address(0), 'Arkreen: Zero Address');\r\n        require(recIssuers[issuer].added, 'Arkreen: Issuer Not Added');\r\n        recIssuers[issuer].added = false;\r\n        recIssuers[issuer].removeTime = uint64(block.timestamp);\r\n        // the mapping from tokenREC to recIssuers are kept\r\n    }\r\n\r\n    function isRECIssuer(address issuer) external view virtual returns(bool) {\r\n        return recIssuers[issuer].added;\r\n    }\r\n\r\n    function newAssetAREC(string calldata idAsset, address issuer, address tokenREC, address tokenPay,\r\n                        uint128 rateToIssue, uint16 rateToLiquidize, string calldata description) external virtual onlyOwner {\r\n        numAsset += 1;\r\n        tokenRECs[tokenREC] = issuer;\r\n        allAssets[numAsset] = AssetAREC(idAsset, issuer, tokenREC, tokenPay, rateToIssue, rateToLiquidize, true, description);\r\n    }\r\n\r\n    function manageAssetAREC( uint256 idxAsset, uint256 flag, uint128 rateToIssue, uint16 rateToLiquidize, bool bActive,\r\n                                string calldata description) external {\r\n\r\n        require( (msg.sender == allAssets[idxAsset].issuer) || (owner() == msg.sender), 'Arkreen: Not Allowed');                                 \r\n        if((flag & 0x01) != 0) {\r\n            allAssets[idxAsset].rateToIssue = rateToIssue;\r\n        }\r\n        if((flag & 0x02) != 0) {\r\n            require(rateToLiquidize < 10000, \"Arkreen: Wrong liquidize rate\");\r\n            allAssets[idxAsset].rateToLiquidize = rateToLiquidize;\r\n        }\r\n        if((flag & 0x04) != 0) {\r\n            allAssets[idxAsset].bActive = bActive;\r\n        }\r\n        if((flag & 0x08) != 0) {\r\n            allAssets[idxAsset].description = description;\r\n        }        \r\n    }\r\n\r\n    function manageAssetARECExt( uint256 idxAsset, uint256 flag, string calldata idAsset, address issuer, \r\n                                address tokenREC, address tokenPay) external virtual onlyOwner {\r\n        if((flag & 0x01) != 0) {\r\n            allAssets[idxAsset].idAsset = idAsset;\r\n        }\r\n        if((flag & 0x02) != 0) {\r\n            allAssets[idxAsset].issuer = issuer;\r\n        }\r\n        if((flag & 0x04) != 0) {\r\n            allAssets[idxAsset].tokenREC = tokenREC;\r\n        }\r\n        if((flag & 0x08) != 0) {\r\n            allAssets[idxAsset].tokenPay = tokenPay;\r\n        }        \r\n    }\r\n\r\n    function getAssetInfo(uint256 idAsset) public view returns (address issuer, address tokenREC,\r\n                                    address tokenPay, uint128 rateToIssue, uint16 rateToLiquidize) {\r\n        require(allAssets[idAsset].bActive, \"Arkreen: Wrong Asset\");\r\n        issuer = allAssets[idAsset].issuer;\r\n        tokenREC = allAssets[idAsset].tokenREC;\r\n        tokenPay = allAssets[idAsset].tokenPay;\r\n        rateToIssue = allAssets[idAsset].rateToIssue;      \r\n        rateToLiquidize = allAssets[idAsset].rateToLiquidize;      \r\n    }\r\n\r\n\r\n    function getRECToken(address issuer, uint256 idAsset) external view virtual returns(address tokenREC) {\r\n        if( idAsset == 0) {\r\n            require(recIssuers[issuer].added, 'Arkreen: Issuer Not Added');\r\n            tokenREC = recIssuers[issuer].tokenREC;\r\n        } else {\r\n            tokenREC = allAssets[idAsset].tokenREC;\r\n        }\r\n    }\r\n\r\n    function setArkreenRetirement(address arkRetirement) external virtual onlyOwner checkAddress(arkRetirement) {\r\n        arkreenRECRetirement = arkRetirement;\r\n    }\r\n\r\n    function getArkreenRetirement() external view virtual returns (address) {\r\n        require(arkreenRECRetirement != address(0), 'Arkreen: Zero Retirement Address');\r\n        return arkreenRECRetirement;\r\n    }  \r\n\r\n    function setArkreenMiner(address arkMiner) external virtual onlyOwner checkAddress(arkMiner) {\r\n        arkreenMiner = arkMiner;\r\n    }\r\n\r\n    function getArkreenMiner() external view virtual returns (address) {\r\n        require(arkreenMiner != address(0), 'Arkreen: Zero Miner Address');\r\n        return arkreenMiner;\r\n    }  \r\n\r\n    function setRECIssuance(address recIssuance) external virtual onlyOwner checkAddress(recIssuance) {\r\n        arkreenRECIssuance = recIssuance;\r\n    }\r\n\r\n    function getRECIssuance() external view virtual returns (address) {\r\n        require(arkreenRECIssuance != address(0), 'Arkreen: Zero Issuance Address');\r\n        return arkreenRECIssuance;\r\n    }    \r\n}"
    },
    "@openzeppelin/contracts-upgradeable/access/AccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (access/AccessControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/StringsUpgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module that allows children to implement role-based access\n * control mechanisms. This is a lightweight version that doesn't allow enumerating role\n * members except through off-chain means by accessing the contract event logs. Some\n * applications may benefit from on-chain enumerability, for those cases see\n * {AccessControlEnumerable}.\n *\n * Roles are referred to by their `bytes32` identifier. These should be exposed\n * in the external API and be unique. The best way to achieve this is by\n * using `public constant` hash digests:\n *\n * ```\n * bytes32 public constant MY_ROLE = keccak256(\"MY_ROLE\");\n * ```\n *\n * Roles can be used to represent a set of permissions. To restrict access to a\n * function call, use {hasRole}:\n *\n * ```\n * function foo() public {\n *     require(hasRole(MY_ROLE, msg.sender));\n *     ...\n * }\n * ```\n *\n * Roles can be granted and revoked dynamically via the {grantRole} and\n * {revokeRole} functions. Each role has an associated admin role, and only\n * accounts that have a role's admin role can call {grantRole} and {revokeRole}.\n *\n * By default, the admin role for all roles is `DEFAULT_ADMIN_ROLE`, which means\n * that only accounts with this role will be able to grant or revoke other\n * roles. More complex role relationships can be created by using\n * {_setRoleAdmin}.\n *\n * WARNING: The `DEFAULT_ADMIN_ROLE` is also its own admin: it has permission to\n * grant and revoke this role. Extra precautions should be taken to secure\n * accounts that have been granted it.\n */\nabstract contract AccessControlUpgradeable is Initializable, ContextUpgradeable, IAccessControlUpgradeable, ERC165Upgradeable {\n    function __AccessControl_init() internal onlyInitializing {\n    }\n\n    function __AccessControl_init_unchained() internal onlyInitializing {\n    }\n    struct RoleData {\n        mapping(address => bool) members;\n        bytes32 adminRole;\n    }\n\n    mapping(bytes32 => RoleData) private _roles;\n\n    bytes32 public constant DEFAULT_ADMIN_ROLE = 0x00;\n\n    /**\n     * @dev Modifier that checks that an account has a specific role. Reverts\n     * with a standardized message including the required role.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     *\n     * _Available since v4.1._\n     */\n    modifier onlyRole(bytes32 role) {\n        _checkRole(role);\n        _;\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override returns (bool) {\n        return interfaceId == type(IAccessControlUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) public view virtual override returns (bool) {\n        return _roles[role].members[account];\n    }\n\n    /**\n     * @dev Revert with a standard message if `_msgSender()` is missing `role`.\n     * Overriding this function changes the behavior of the {onlyRole} modifier.\n     *\n     * Format of the revert message is described in {_checkRole}.\n     *\n     * _Available since v4.6._\n     */\n    function _checkRole(bytes32 role) internal view virtual {\n        _checkRole(role, _msgSender());\n    }\n\n    /**\n     * @dev Revert with a standard message if `account` is missing `role`.\n     *\n     * The format of the revert reason is given by the following regular expression:\n     *\n     *  /^AccessControl: account (0x[0-9a-f]{40}) is missing role (0x[0-9a-f]{64})$/\n     */\n    function _checkRole(bytes32 role, address account) internal view virtual {\n        if (!hasRole(role, account)) {\n            revert(\n                string(\n                    abi.encodePacked(\n                        \"AccessControl: account \",\n                        StringsUpgradeable.toHexString(uint160(account), 20),\n                        \" is missing role \",\n                        StringsUpgradeable.toHexString(uint256(role), 32)\n                    )\n                )\n            );\n        }\n    }\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) public view virtual override returns (bytes32) {\n        return _roles[role].adminRole;\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function grantRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function revokeRole(bytes32 role, address account) public virtual override onlyRole(getRoleAdmin(role)) {\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been revoked `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function renounceRole(bytes32 role, address account) public virtual override {\n        require(account == _msgSender(), \"AccessControl: can only renounce roles for self\");\n\n        _revokeRole(role, account);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event. Note that unlike {grantRole}, this function doesn't perform any\n     * checks on the calling account.\n     *\n     * May emit a {RoleGranted} event.\n     *\n     * [WARNING]\n     * ====\n     * This function should only be called from the constructor when setting\n     * up the initial roles for the system.\n     *\n     * Using this function in any other way is effectively circumventing the admin\n     * system imposed by {AccessControl}.\n     * ====\n     *\n     * NOTE: This function is deprecated in favor of {_grantRole}.\n     */\n    function _setupRole(bytes32 role, address account) internal virtual {\n        _grantRole(role, account);\n    }\n\n    /**\n     * @dev Sets `adminRole` as ``role``'s admin role.\n     *\n     * Emits a {RoleAdminChanged} event.\n     */\n    function _setRoleAdmin(bytes32 role, bytes32 adminRole) internal virtual {\n        bytes32 previousAdminRole = getRoleAdmin(role);\n        _roles[role].adminRole = adminRole;\n        emit RoleAdminChanged(role, previousAdminRole, adminRole);\n    }\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleGranted} event.\n     */\n    function _grantRole(bytes32 role, address account) internal virtual {\n        if (!hasRole(role, account)) {\n            _roles[role].members[account] = true;\n            emit RoleGranted(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * Internal function without access restriction.\n     *\n     * May emit a {RoleRevoked} event.\n     */\n    function _revokeRole(bytes32 role, address account) internal virtual {\n        if (hasRole(role, account)) {\n            _roles[role].members[account] = false;\n            emit RoleRevoked(role, account, _msgSender());\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (security/Pausable.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which allows children to implement an emergency stop\n * mechanism that can be triggered by an authorized account.\n *\n * This module is used through inheritance. It will make available the\n * modifiers `whenNotPaused` and `whenPaused`, which can be applied to\n * the functions of your contract. Note that they will not be pausable by\n * simply including this module, only once the modifiers are put in place.\n */\nabstract contract PausableUpgradeable is Initializable, ContextUpgradeable {\n    /**\n     * @dev Emitted when the pause is triggered by `account`.\n     */\n    event Paused(address account);\n\n    /**\n     * @dev Emitted when the pause is lifted by `account`.\n     */\n    event Unpaused(address account);\n\n    bool private _paused;\n\n    /**\n     * @dev Initializes the contract in unpaused state.\n     */\n    function __Pausable_init() internal onlyInitializing {\n        __Pausable_init_unchained();\n    }\n\n    function __Pausable_init_unchained() internal onlyInitializing {\n        _paused = false;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is not paused.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    modifier whenNotPaused() {\n        _requireNotPaused();\n        _;\n    }\n\n    /**\n     * @dev Modifier to make a function callable only when the contract is paused.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    modifier whenPaused() {\n        _requirePaused();\n        _;\n    }\n\n    /**\n     * @dev Returns true if the contract is paused, and false otherwise.\n     */\n    function paused() public view virtual returns (bool) {\n        return _paused;\n    }\n\n    /**\n     * @dev Throws if the contract is paused.\n     */\n    function _requireNotPaused() internal view virtual {\n        require(!paused(), \"Pausable: paused\");\n    }\n\n    /**\n     * @dev Throws if the contract is not paused.\n     */\n    function _requirePaused() internal view virtual {\n        require(paused(), \"Pausable: not paused\");\n    }\n\n    /**\n     * @dev Triggers stopped state.\n     *\n     * Requirements:\n     *\n     * - The contract must not be paused.\n     */\n    function _pause() internal virtual whenNotPaused {\n        _paused = true;\n        emit Paused(_msgSender());\n    }\n\n    /**\n     * @dev Returns to normal state.\n     *\n     * Requirements:\n     *\n     * - The contract must be paused.\n     */\n    function _unpause() internal virtual whenPaused {\n        _paused = false;\n        emit Unpaused(_msgSender());\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/interfaces/IMinerRegister.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IMinerRegister {\n    function isOwner(address owner) external returns (bool);\n}\n"
    },
    "contracts/ArkreenRegistryStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\n/// @dev  ArkreenRegistryStorage is to store system critical information\r\ncontract ArkreenRegistryStorage {\r\n\r\n    struct IssuerStatus {\r\n        bool      added;\r\n        uint64    addTime;\r\n        uint64    removeTime;\r\n        address   tokenREC;\r\n        string    issuerId;\r\n    }\r\n\r\n    struct AssetAREC {\r\n        string      idAsset;        \r\n        address     issuer;        \r\n        address     tokenREC;\r\n        address     tokenPay;\r\n        uint128     rateToIssue;                // Calculated based on 1 AREC, 10**9\r\n        uint16      rateToLiquidize;            // Calculated based on 10000\r\n        bool        bActive;\r\n        string      description;\r\n    }\r\n\r\n    // Arkreen Miner Contact Address\r\n    address internal arkreenMiner;\r\n\r\n    // Arkreen REC Issuance Contact Address\r\n    address internal arkreenRECIssuance;\r\n\r\n    // Arkreen REC Retirement Contract Address\r\n    address internal arkreenRECRetirement;\r\n    \r\n    // REC issuers\r\n    uint256 public numIssuers;\r\n    mapping(address => IssuerStatus) public recIssuers;     // REC issuer -> IssuerStatus\r\n    mapping(address => address) public tokenRECs;           // mapping token to issuer\r\n    mapping(uint256 => address) public allIssuers;          // All Issuers\r\n    uint256 public numAsset;\r\n    mapping(uint256 => AssetAREC) public allAssets;          // All assets\r\n}\r\n"
    },
    "@openzeppelin/contracts-upgradeable/access/IAccessControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControlUpgradeable {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "contracts/ArkreenRECIssuanceExt.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\r\n\r\nimport \"./interfaces/IMinerRegister.sol\";\r\nimport \"./interfaces/IArkreenRegistry.sol\";\r\nimport \"./interfaces/IArkreenMiner.sol\";\r\nimport \"./interfaces/IArkreenBadge.sol\";\r\n\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./libraries/TransferHelper.sol\";\r\nimport \"./interfaces/IERC20Permit.sol\";\r\nimport \"./ArkreenRECIssuanceStorage.sol\";\r\nimport \"./interfaces/IPausable.sol\";\r\n\r\n// Import this file to use console.log\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract ArkreenRECIssuanceExt is\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    ERC721EnumerableUpgradeable,\r\n    ArkreenRECIssuanceStorage\r\n{\r\n    // using SafeMath for uint256;    // seems not necessary\r\n    using AddressUpgradeable for address;\r\n\r\n    // Public variables\r\n    string public constant NAME = 'Arkreen RE Certificate';\r\n    string public constant SYMBOL = 'AREC';\r\n\r\n    // Events\r\n    event RECRequested(address owner, uint256 tokenId);\r\n    event RECRejected(uint256 tokenId);\r\n    event RECDataUpdated(address owner, uint256 tokenId);\r\n    event RECCertified(address issuer, uint256 tokenId);\r\n    event RECCanceled(address owner, uint256 tokenId);    \r\n    event RECLiquidized(address owner, uint256 tokenId, uint256 amountREC);\r\n    event RedeemFinished(address redeemEntity, uint256 tokenId, uint256 offsetActionId);\r\n    event ESGBatchMinted(address owner, uint256 tokenId);\r\n    event ESGBatchDataUpdated(address owner, uint256 tokenId);\r\n\r\n    // Modifiers\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'RECIssuance: EXPIRED');\r\n        _;\r\n    }\r\n\r\n    modifier whenNotPaused() {\r\n        require(!IPausable(arkreenRegistry).paused(), 'AREC: Paused');\r\n        _;\r\n    }    \r\n  \r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize(address _tokenAKRE, address arkRegistry) external virtual initializer {\r\n        __Ownable_init_unchained();\r\n        __UUPSUpgradeable_init();\r\n        __ERC721_init_unchained(NAME, SYMBOL);\r\n        tokenAKRE = _tokenAKRE;\r\n        arkreenRegistry = arkRegistry;\r\n        baseURI = 'https://www.arkreen.com/AREC/' ;\r\n    }\r\n\r\n    function postUpdate() external onlyProxy onlyOwner \r\n    {}\r\n\r\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner\r\n    {}    \r\n\r\n    /**\r\n     * @dev To mint the empty AREC NFT as as ESG batch, which must be updated later to be successfully confirmed.\r\n     * @param idAssetType The type of the AREC asset to issue\r\n     * @param amountREC The amount if the AREC asset target to issue.\r\n     * permitToPay Payment info to mint the AREC NFT\r\n     */\r\n    function mintESGBatch(\r\n        uint256   idAssetType,\r\n        uint256   amountREC,\r\n        Signature calldata permitToPay\r\n    ) external ensure(permitToPay.deadline) whenNotPaused returns (uint256 tokenId) {\r\n\r\n        // Check the caller be the MVP enity\r\n        address sender = _msgSender();\r\n        require( AllMVPEntity[sender], \"AREC: Not Allowed\");\r\n\r\n        // Check and get asset information\r\n        (address issuer, , address tokenPay, uint128 rateToIssue, ) \r\n                                                = IArkreenRegistry(arkreenRegistry).getAssetInfo(idAssetType);\r\n\r\n        // Check payment appoval\r\n        require( permitToPay.token == tokenPay, \"AREC: Wrong Payment Token\");\r\n\r\n        uint256 valuePayment = amountREC * rateToIssue / ( 10**9);              // Rate is caluated based 10**9\r\n\r\n        if(permitToPay.value != 0) {\r\n          require( permitToPay.value >= valuePayment, \"AREC: Low Payment Value\");\r\n\r\n          IERC20Permit(permitToPay.token).permit(sender, address(this), \r\n                          permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\r\n        }\r\n\r\n        tokenId = totalSupply() + 1;\r\n        _safeMint(sender, tokenId);\r\n\r\n        // Prepare REC data\r\n        RECData memory recData;\r\n        recData.issuer =  issuer;\r\n        recData.minter = sender;\r\n        recData.amountREC =  uint128(amountREC);\r\n        recData.status = uint8(RECStatus.Pending);\r\n        recData.idAsset = uint16(idAssetType);\r\n\r\n        allRECData[tokenId] = recData;\r\n\r\n        PayInfo memory payInfo = PayInfo({token: permitToPay.token, value: valuePayment});\r\n        allPayInfo[tokenId] = payInfo;\r\n\r\n        emit ESGBatchMinted(sender, tokenId);\r\n\r\n        // Transfer the REC mint fee\r\n        if(valuePayment != 0) {\r\n            TransferHelper.safeTransferFrom(permitToPay.token, _msgSender(), address(this), valuePayment);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev To update the REC NFT mint info while it is rejected by the the issuer.\r\n     * tokenId The ID of the REC NFT to update\r\n     */\r\n    function updateRECDataExt(\r\n        uint256         tokenID,\r\n        uint32          startTime,\r\n        uint32          endTime,\r\n        string calldata cID,\r\n        string calldata region,\r\n        string calldata url,\r\n        string calldata memo) external whenNotPaused\r\n    {\r\n        // Check the caller be the MVP enity\r\n        address sender = _msgSender();\r\n        require( AllMVPEntity[sender], \"AREC: Not Allowed\");\r\n\r\n        // Only ESG_AREC owner allowed to change the REC data\r\n        require(ownerOf(tokenID) == _msgSender(), 'AREC: Not Owner');     // owner should be the minter also\r\n\r\n        // Only Pending and Rejected ESG_AREC can be updated\r\n        RECData storage recData = allRECData[tokenID];\r\n        require(recData.status <= uint8(RECStatus.Rejected), 'AREC: Wrong Status');\r\n\r\n        if(startTime != 0) recData.startTime = startTime;\r\n        if(endTime != 0) recData.endTime = endTime;\r\n        if(bytes(cID).length != 0) recData.cID = cID;\r\n        if(bytes(region).length != 0) recData.region = region;\r\n        if(bytes(url).length != 0) recData.url = url;\r\n        if(bytes(memo).length != 0) recData.memo = memo;\r\n\r\n        recData.status =  uint8(RECStatus.Pending);\r\n        emit ESGBatchDataUpdated(_msgSender(), tokenID);\r\n    }\r\n\r\n    /**\r\n     * @dev To cancel the REC NFT mint request,only can be called the NFT owner.\r\n     * REC NFT mint fee is refund to the owner after the transaction.\r\n     * tokenId The ID of the REC NFT to update\r\n     */\r\n    function cancelRECRequest(uint256 tokenID) external whenNotPaused {\r\n\r\n        // Only REC owner allowed to cancel the request\r\n        require(ownerOf(tokenID) == _msgSender(), 'AREC: Not Owner');\r\n\r\n        // Only pending REC can be cancelled\r\n        require(allRECData[tokenID].status == uint8(RECStatus.Rejected), 'AREC: Wrong Status');  \r\n\r\n        allRECData[tokenID].status = uint8(RECStatus.Cancelled);\r\n\r\n        // Refund the request fee\r\n        TransferHelper.safeTransfer(allPayInfo[tokenID].token, _msgSender(), allPayInfo[tokenID].value);\r\n\r\n        // delete the payment info to save storage\r\n        delete allPayInfo[tokenID];\r\n        emit RECCanceled(_msgSender(), tokenID);\r\n    }\r\n\r\n    /// @dev return all the AREC issaunce token/price list\r\n    function allARECMintPrice() external view virtual returns (RECMintPrice[] memory) {\r\n        uint256 sizePrice = paymentTokens.length;\r\n        RECMintPrice[] memory ARECMintPrice = new RECMintPrice[](sizePrice);\r\n\r\n        for(uint256 index; index < sizePrice; index++) {\r\n          address token = paymentTokens[index];\r\n          ARECMintPrice[index].token = paymentTokens[index];\r\n          ARECMintPrice[index].value = paymentTokenPrice[token];\r\n        }\r\n        return ARECMintPrice;\r\n    }\r\n\r\n    /**\r\n     * @dev Add or remove the MVP addresses \r\n     * @param op The operation of MVP address, =true, add MVP; =false, remove MVP \r\n     * @param listMVP The list of the MVP addresses\r\n     */\r\n    function manageMVPAddress(bool op, address[] calldata listMVP) public whenNotPaused onlyOwner {\r\n        for(uint256 index; index < listMVP.length; index++) {\r\n            require( AllMVPEntity[listMVP[index]] != op, \"AREC: Wrong Status\" );\r\n            AllMVPEntity[listMVP[index]] = op;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Hook that is called before any token transfer.\r\n     */\r\n    function _beforeTokenTransfer(\r\n        address from,\r\n        address to,\r\n        uint256 tokenId\r\n    ) internal virtual override (ERC721EnumerableUpgradeable) {\r\n\r\n        // Only certified REC can be transferred\r\n        if(from != address(0)) {\r\n            RECData storage recData = allRECData[tokenId];\r\n            if(recData.status == uint8(RECStatus.Liquidized)) {\r\n                address issuerREC = recData.issuer;\r\n                address tokenREC = IArkreenRegistry(arkreenRegistry).getRECToken(issuerREC, recData.idAsset);\r\n                address arkreenBadge = IArkreenRegistry(arkreenRegistry).getArkreenRetirement();\r\n\r\n                // Only the ART contract can restore the AREC\r\n                require(msg.sender == tokenREC, 'AREC: Not Allowed');\r\n\r\n                if(to == arkreenBadge) {\r\n                    recData.status = uint8(RECStatus.Retired);\r\n                } else {\r\n                    uint256 amountREC = recData.amountREC;\r\n\r\n                    // Modified the Liquidized REC amount\r\n                    allRECLiquidized -= amountREC;\r\n\r\n                    // Set the AREC status to be Liquidized\r\n                    recData.status = uint8(RECStatus.Certified);\r\n                }\r\n            }\r\n            else {\r\n                require(recData.status == uint8(RECStatus.Certified), 'AREC: Wrong Status');\r\n            }\r\n        }\r\n        super._beforeTokenTransfer(from, to, tokenId);\r\n    }\r\n}"
    },
    "contracts/interfaces/IArkreenMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IArkreenMiner {\n    function getArkreenMinerContact() external view returns (address);\n    function isOwner(address owner) external view returns (bool);\n}\n"
    },
    "contracts/ArkreenRECIssuanceStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./ArkreenRECIssuanceType.sol\";  \nimport \"./interfaces/IArkreenRECIssuanceImage.sol\";\n\ncontract ArkreenRECIssuanceStorage {\n    address public tokenAKRE;                           // token adddress of AKRE\n    address public arkreenRegistry;                     // contracts storing all miner's ownership    \n    string  public baseURI;\n\n    mapping(uint256 => RECData) internal allRECData;    // save size\n    mapping(uint256 => PayInfo) public allPayInfo;      \n\n    uint256 public allRECIssued;                        // total AREC amount issued by minting AREC NFT\n    uint256 public allRECRedeemed;                      // total AREC amount redeemed by retiring AREC NFT\n    uint256 public allRECLiquidized;                    // total AREC amount Liquidized by Liquidizing to AREC ERC20 token\n\n    // The REC amount issued by specific issuer\n    mapping(address => uint256) public allRECByIssuer;\n\n    // The total payment paid to specific issuer with specific payment token\n    mapping(address => mapping(address => uint256)) public paymentByIssuer;\n\n    // All payment tokens acceptable and their price\n    // AREC mint/issance price, payment token amount per AREC (Decimal = 9)\n    // Ex: 1AREC -> 0.2USDT,  ARECMintPrice = 0.2 * 10**6    \n    mapping(address => uint256) public paymentTokenPrice;\n    address[] public paymentTokens;\n\n    mapping(address => bool) public AllMVPEntity;\n\n    IArkreenRECIssuanceImage arkreenRECImage;\n\n    // keccak256(\"RECIssuance(address owner,uint256 startTime,uint256 endTime,\n    //                        uint256 amountREC,uint256 merkelRoot,string url,\n    //                        uint256 nonce,uint256 feeREC,uint256 deadline)\");\n    bytes32 public constant PERMIT_TYPEHASH = 0xEB053433B86341259C91DE8E051FF855E4AEF3CABE1825EE9F5D9A80315FB700; \n\n    // This is the keccak-256 hash of \"AREC.proxy.ESG\" subtracted by 1\n    bytes32 internal constant _ESG_EXT_SLOT = 0x6C14EAC8C066761328A8B25C5852066ED51A1332CB48C81DA799E3C09C620C9D;\n}"
    },
    "contracts/interfaces/IArkreenRECIssuanceImage.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '../ArkreenRECIssuanceType.sol';\r\n\r\ninterface IArkreenRECIssuanceImage {\r\n    function getARECSVG(\r\n        uint256 tokenId,\r\n        address owner,\r\n        RECData memory offsetRecord\r\n    ) external view returns(string memory);                       \r\n}"
    },
    "@openzeppelin/contracts/utils/StorageSlot.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/StorageSlot.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Library for reading and writing primitive types to specific storage slots.\n *\n * Storage slots are often used to avoid storage conflict when dealing with upgradeable contracts.\n * This library helps with reading and writing to such slots without the need for inline assembly.\n *\n * The functions in this library return Slot structs that contain a `value` member that can be used to read or write.\n *\n * Example usage to set ERC1967 implementation slot:\n * ```\n * contract ERC1967 {\n *     bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n *\n *     function _getImplementation() internal view returns (address) {\n *         return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n *     }\n *\n *     function _setImplementation(address newImplementation) internal {\n *         require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n *         StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n *     }\n * }\n * ```\n *\n * _Available since v4.1 for `address`, `bool`, `bytes32`, and `uint256`._\n */\nlibrary StorageSlot {\n    struct AddressSlot {\n        address value;\n    }\n\n    struct BooleanSlot {\n        bool value;\n    }\n\n    struct Bytes32Slot {\n        bytes32 value;\n    }\n\n    struct Uint256Slot {\n        uint256 value;\n    }\n\n    /**\n     * @dev Returns an `AddressSlot` with member `value` located at `slot`.\n     */\n    function getAddressSlot(bytes32 slot) internal pure returns (AddressSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `BooleanSlot` with member `value` located at `slot`.\n     */\n    function getBooleanSlot(bytes32 slot) internal pure returns (BooleanSlot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Bytes32Slot` with member `value` located at `slot`.\n     */\n    function getBytes32Slot(bytes32 slot) internal pure returns (Bytes32Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n\n    /**\n     * @dev Returns an `Uint256Slot` with member `value` located at `slot`.\n     */\n    function getUint256Slot(bytes32 slot) internal pure returns (Uint256Slot storage r) {\n        /// @solidity memory-safe-assembly\n        assembly {\n            r.slot := slot\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Upgrade.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (proxy/ERC1967/ERC1967Upgrade.sol)\n\npragma solidity ^0.8.2;\n\nimport \"../beacon/IBeacon.sol\";\nimport \"../../interfaces/draft-IERC1822.sol\";\nimport \"../../utils/Address.sol\";\nimport \"../../utils/StorageSlot.sol\";\n\n/**\n * @dev This abstract contract provides getters and event emitting update functions for\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967] slots.\n *\n * _Available since v4.1._\n *\n * @custom:oz-upgrades-unsafe-allow delegatecall\n */\nabstract contract ERC1967Upgrade {\n    // This is the keccak-256 hash of \"eip1967.proxy.rollback\" subtracted by 1\n    bytes32 private constant _ROLLBACK_SLOT = 0x4910fdfa16fed3260ed0e7147f7cc6da11a60208b5b9406d12a635614ffd9143;\n\n    /**\n     * @dev Storage slot with the address of the current implementation.\n     * This is the keccak-256 hash of \"eip1967.proxy.implementation\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _IMPLEMENTATION_SLOT = 0x360894a13ba1a3210667c828492db98dca3e2076cc3735a920a3ca505d382bbc;\n\n    /**\n     * @dev Emitted when the implementation is upgraded.\n     */\n    event Upgraded(address indexed implementation);\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _getImplementation() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 implementation slot.\n     */\n    function _setImplementation(address newImplementation) private {\n        require(Address.isContract(newImplementation), \"ERC1967: new implementation is not a contract\");\n        StorageSlot.getAddressSlot(_IMPLEMENTATION_SLOT).value = newImplementation;\n    }\n\n    /**\n     * @dev Perform implementation upgrade\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeTo(address newImplementation) internal {\n        _setImplementation(newImplementation);\n        emit Upgraded(newImplementation);\n    }\n\n    /**\n     * @dev Perform implementation upgrade with additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCall(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _upgradeTo(newImplementation);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(newImplementation, data);\n        }\n    }\n\n    /**\n     * @dev Perform implementation upgrade with security checks for UUPS proxies, and additional setup call.\n     *\n     * Emits an {Upgraded} event.\n     */\n    function _upgradeToAndCallUUPS(\n        address newImplementation,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        // Upgrades from old implementations will perform a rollback test. This test requires the new\n        // implementation to upgrade back to the old, non-ERC1822 compliant, implementation. Removing\n        // this special case will break upgrade paths from old UUPS implementation to new ones.\n        if (StorageSlot.getBooleanSlot(_ROLLBACK_SLOT).value) {\n            _setImplementation(newImplementation);\n        } else {\n            try IERC1822Proxiable(newImplementation).proxiableUUID() returns (bytes32 slot) {\n                require(slot == _IMPLEMENTATION_SLOT, \"ERC1967Upgrade: unsupported proxiableUUID\");\n            } catch {\n                revert(\"ERC1967Upgrade: new implementation is not UUPS\");\n            }\n            _upgradeToAndCall(newImplementation, data, forceCall);\n        }\n    }\n\n    /**\n     * @dev Storage slot with the admin of the contract.\n     * This is the keccak-256 hash of \"eip1967.proxy.admin\" subtracted by 1, and is\n     * validated in the constructor.\n     */\n    bytes32 internal constant _ADMIN_SLOT = 0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103;\n\n    /**\n     * @dev Emitted when the admin account has changed.\n     */\n    event AdminChanged(address previousAdmin, address newAdmin);\n\n    /**\n     * @dev Returns the current admin.\n     */\n    function _getAdmin() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_ADMIN_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new address in the EIP1967 admin slot.\n     */\n    function _setAdmin(address newAdmin) private {\n        require(newAdmin != address(0), \"ERC1967: new admin is the zero address\");\n        StorageSlot.getAddressSlot(_ADMIN_SLOT).value = newAdmin;\n    }\n\n    /**\n     * @dev Changes the admin of the proxy.\n     *\n     * Emits an {AdminChanged} event.\n     */\n    function _changeAdmin(address newAdmin) internal {\n        emit AdminChanged(_getAdmin(), newAdmin);\n        _setAdmin(newAdmin);\n    }\n\n    /**\n     * @dev The storage slot of the UpgradeableBeacon contract which defines the implementation for this proxy.\n     * This is bytes32(uint256(keccak256('eip1967.proxy.beacon')) - 1)) and is validated in the constructor.\n     */\n    bytes32 internal constant _BEACON_SLOT = 0xa3f0ad74e5423aebfd80d3ef4346578335a9a72aeaee59ff6cb3582b35133d50;\n\n    /**\n     * @dev Emitted when the beacon is upgraded.\n     */\n    event BeaconUpgraded(address indexed beacon);\n\n    /**\n     * @dev Returns the current beacon.\n     */\n    function _getBeacon() internal view returns (address) {\n        return StorageSlot.getAddressSlot(_BEACON_SLOT).value;\n    }\n\n    /**\n     * @dev Stores a new beacon in the EIP1967 beacon slot.\n     */\n    function _setBeacon(address newBeacon) private {\n        require(Address.isContract(newBeacon), \"ERC1967: new beacon is not a contract\");\n        require(\n            Address.isContract(IBeacon(newBeacon).implementation()),\n            \"ERC1967: beacon implementation is not a contract\"\n        );\n        StorageSlot.getAddressSlot(_BEACON_SLOT).value = newBeacon;\n    }\n\n    /**\n     * @dev Perform beacon upgrade with additional setup call. Note: This upgrades the address of the beacon, it does\n     * not upgrade the implementation contained in the beacon (see {UpgradeableBeacon-_setImplementation} for that).\n     *\n     * Emits a {BeaconUpgraded} event.\n     */\n    function _upgradeBeaconToAndCall(\n        address newBeacon,\n        bytes memory data,\n        bool forceCall\n    ) internal {\n        _setBeacon(newBeacon);\n        emit BeaconUpgraded(newBeacon);\n        if (data.length > 0 || forceCall) {\n            Address.functionDelegateCall(IBeacon(newBeacon).implementation(), data);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/beacon/IBeacon.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (proxy/beacon/IBeacon.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This is the interface that {BeaconProxy} expects of its beacon.\n */\ninterface IBeacon {\n    /**\n     * @dev Must return an address that can be used as a delegate call target.\n     *\n     * {BeaconProxy} will check that this address is a contract.\n     */\n    function implementation() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/interfaces/draft-IERC1822.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (interfaces/draft-IERC1822.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev ERC1822: Universal Upgradeable Proxy Standard (UUPS) documents a method for upgradeability through a simplified\n * proxy whose upgrades are fully controlled by the current implementation.\n */\ninterface IERC1822Proxiable {\n    /**\n     * @dev Returns the storage slot that the proxiable contract assumes is being used to store the implementation\n     * address.\n     *\n     * IMPORTANT: A proxy pointing at a proxiable contract should not be considered proxiable itself, because this risks\n     * bricking a proxy that upgrades to it, by delegating to itself until out of gas. Thus it is critical that this\n     * function revert if invoked through a proxy.\n     */\n    function proxiableUUID() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (proxy/ERC1967/ERC1967Proxy.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Proxy.sol\";\nimport \"./ERC1967Upgrade.sol\";\n\n/**\n * @dev This contract implements an upgradeable proxy. It is upgradeable because calls are delegated to an\n * implementation address that can be changed. This address is stored in storage in the location specified by\n * https://eips.ethereum.org/EIPS/eip-1967[EIP1967], so that it doesn't conflict with the storage layout of the\n * implementation behind the proxy.\n */\ncontract ERC1967Proxy is Proxy, ERC1967Upgrade {\n    /**\n     * @dev Initializes the upgradeable proxy with an initial implementation specified by `_logic`.\n     *\n     * If `_data` is nonempty, it's used as data in a delegate call to `_logic`. This will typically be an encoded\n     * function call, and allows initializing the storage of the proxy like a Solidity constructor.\n     */\n    constructor(address _logic, bytes memory _data) payable {\n        _upgradeToAndCall(_logic, _data, false);\n    }\n\n    /**\n     * @dev Returns the current implementation address.\n     */\n    function _implementation() internal view virtual override returns (address impl) {\n        return ERC1967Upgrade._getImplementation();\n    }\n}\n"
    },
    "@openzeppelin/contracts/proxy/Proxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (proxy/Proxy.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev This abstract contract provides a fallback function that delegates all calls to another contract using the EVM\n * instruction `delegatecall`. We refer to the second contract as the _implementation_ behind the proxy, and it has to\n * be specified by overriding the virtual {_implementation} function.\n *\n * Additionally, delegation to the implementation can be triggered manually through the {_fallback} function, or to a\n * different contract through the {_delegate} function.\n *\n * The success and return data of the delegated call will be returned back to the caller of the proxy.\n */\nabstract contract Proxy {\n    /**\n     * @dev Delegates the current call to `implementation`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _delegate(address implementation) internal virtual {\n        assembly {\n            // Copy msg.data. We take full control of memory in this inline assembly\n            // block because it will not return to Solidity code. We overwrite the\n            // Solidity scratch pad at memory position 0.\n            calldatacopy(0, 0, calldatasize())\n\n            // Call the implementation.\n            // out and outsize are 0 because we don't know the size yet.\n            let result := delegatecall(gas(), implementation, 0, calldatasize(), 0, 0)\n\n            // Copy the returned data.\n            returndatacopy(0, 0, returndatasize())\n\n            switch result\n            // delegatecall returns 0 on error.\n            case 0 {\n                revert(0, returndatasize())\n            }\n            default {\n                return(0, returndatasize())\n            }\n        }\n    }\n\n    /**\n     * @dev This is a virtual function that should be overridden so it returns the address to which the fallback function\n     * and {_fallback} should delegate.\n     */\n    function _implementation() internal view virtual returns (address);\n\n    /**\n     * @dev Delegates the current call to the address returned by `_implementation()`.\n     *\n     * This function does not return to its internal call site, it will return directly to the external caller.\n     */\n    function _fallback() internal virtual {\n        _beforeFallback();\n        _delegate(_implementation());\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if no other\n     * function in the contract matches the call data.\n     */\n    fallback() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Fallback function that delegates calls to the address returned by `_implementation()`. Will run if call data\n     * is empty.\n     */\n    receive() external payable virtual {\n        _fallback();\n    }\n\n    /**\n     * @dev Hook that is called before falling back to the implementation. Can happen as part of a manual `_fallback`\n     * call, or as part of the Solidity `fallback` or `receive` functions.\n     *\n     * If overridden should call `super._beforeFallback()`.\n     */\n    function _beforeFallback() internal virtual {}\n}\n"
    },
    "contracts/UUPSProxy.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts/proxy/ERC1967/ERC1967Proxy.sol';\n\n/// @dev Kept for backwards compatibility with older versions of Hardhat and Truffle plugins.\ncontract UUPSProxy is ERC1967Proxy {\n    constructor(\n        address _logic,\n        address, // This is completely unused by the uups proxy, required to remain compatible with hardhat deploy: https://github.com/wighawag/hardhat-deploy/issues/146\n        bytes memory _data\n    ) payable ERC1967Proxy(_logic, _data) {}\n}\n"
    },
    "contracts/ArkreenRECBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\r\n\r\nimport \"./libraries/TransferHelper.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IERC20Permit.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\n// Import this file to use console.log\r\n//import \"hardhat/console.sol\";\r\n\r\nstruct IncomeInfo {\r\n    uint128     priceForSale;           // 1 ART -> X Payment token\r\n    uint128     amountReceived;         // Amount of payment token received\r\n}\r\n\r\nstruct SaleInfo {\r\n    address     controller;             // Address of the ART token controller\r\n    address     fundReceiver;           // Address of the receiver while withdrawing the sale income  \r\n    uint128     amountDeposited;        // The amount of ART deposited to this bank contract\r\n    uint128     amountSold;             // The amount of ART already sold out\r\n}\r\n\r\nstruct Signature {\r\n    address     token;\r\n    uint256     value;\r\n    uint256     deadline;  \r\n    uint8       v;\r\n    bytes32     r;\r\n    bytes32     s;              \r\n}\r\n\r\ncontract ArkreenRECBank is\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable\r\n{\r\n    // Public variables\r\n    address public tokenNative;                                             // The wrapped token of the Native token, such as WETH, WMATIC\r\n    mapping(address => bool) public forwarders;                             // All forwarders acceptable\r\n    mapping(address => mapping(address => IncomeInfo)) public saleIncome;   // Mapping X-ART -> Payment Token -> SaleInfo, price zero means not-supported\r\n    mapping(address => SaleInfo) public artSaleInfo;                        // All ART deposit and sale info. If deposit is zero, it means not-supported\r\n\r\n    // Events\r\n    event ARTSold(address indexed artToken, address indexed payToken, uint256 artAmount, uint256 payAmount);\r\n    event ARTPriceChanged(address indexed artToken, address indexed payToken, uint256 newPrice);   \r\n    event Deposit(address indexed artToken, uint256 amountDeposit);    \r\n    event Withdraw(address indexed artToken, address indexed payToken, uint256 balance);   \r\n\r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize(address native) external virtual initializer {\r\n        __Ownable_init_unchained();\r\n        __UUPSUpgradeable_init(); \r\n        tokenNative = native;       \r\n    }\r\n\r\n    function postUpdate() external onlyProxy onlyOwner \r\n    {}\r\n\r\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner\r\n    {}    \r\n\r\n    receive() external payable {\r\n        assert(msg.sender == tokenNative); // only accept WMATIC via fallback from the WMATIC contract\r\n    }\r\n\r\n    function buyART(\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        bool                isExactPay\r\n    ) external {\r\n        _buyART (msg.sender, _msgSender(), tokenPay, tokenART, amountPay, amountART, isExactPay);\r\n    }\r\n\r\n    /** \r\n     * @dev Buy the ART token, then offset the bought ART and mint a cliamte badge.\r\n     * @param tokenART The address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountART The amount of the ART token.\r\n     *                  if isExactPay is true, amountART means the minumum ART token to receive, which may be zero for no checking.\r\n     *                  if isExactPay is false, amountART is the amount of ART token to receive.\r\n     * @param isExactPay Which amount is the exact amount\r\n     *                  = true,  msg.value is the exact amount of the payment token to pay.\r\n     *                  = false, amountART is the exact amount of the ART token to receive.\r\n     */\r\n    function buyARTNative(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        bool                isExactPay\r\n    ) external payable {\r\n\r\n        uint256 priceSale = saleIncome[tokenART][tokenNative].priceForSale;\r\n        require (priceSale !=0, 'ARBK: Payment token not allowed');\r\n        \r\n        uint256 amountPay =  msg.value;\r\n        address receiver = _msgSender();\r\n        if(isExactPay) {\r\n            uint256 amountARTReal = amountPay * (10**9) / priceSale;                    // ART decimal is always 9, so hardcoded here\r\n            require (amountARTReal >= amountART, 'ARBK: Get Less');\r\n\r\n            saleIncome[tokenART][tokenNative].amountReceived += uint128(amountPay);     // Native Token already received\r\n\r\n            TransferHelper.safeTransfer(tokenART, receiver, amountARTReal);\r\n            artSaleInfo[tokenART].amountSold += uint128(amountARTReal);\r\n\r\n            emit ARTSold(tokenART, tokenNative, amountARTReal, amountPay);\r\n        } else {\r\n            uint256 amountPayReal = (amountART * priceSale + (10**9) -1) / (10**9);       // ART decimal is always 9, so hardcoded here\r\n            require (amountPay >= amountPayReal, 'ARBK: Pay Less');                       // amountPay plays as the maximum to pay\r\n\r\n            saleIncome[tokenART][tokenNative].amountReceived += uint128(amountPayReal);\r\n\r\n            TransferHelper.safeTransfer(tokenART, receiver, amountART);\r\n            artSaleInfo[tokenART].amountSold += uint128(amountART);\r\n\r\n            if(amountPay > amountPayReal) TransferHelper.safeTransferETH(msg.sender, amountPay - amountPayReal);\r\n\r\n            emit ARTSold(tokenART, tokenNative, amountART, amountPayReal);\r\n        }\r\n    }\r\n\r\n    function buyARTWithPermit(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        bool                isExactPay,\r\n        Signature calldata  permitToPay\r\n    ) external  {                       // Deadline will be checked by router, no need to check here.\r\n        // Permit payment token\r\n        address payer = _msgSender();\r\n        IERC20Permit(permitToPay.token).permit(payer, address(this), \r\n                        permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\r\n\r\n        // Transfer payement \r\n        _buyART(payer, payer, permitToPay.token, tokenART, permitToPay.value, amountART, isExactPay);\r\n    }\r\n\r\n    function _buyART(\r\n        address             payer,\r\n        address             receiver,\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        bool                isExactPay\r\n    ) internal {\r\n\r\n        // priceSale: 1 ART = priceSale (Payment Tokens), for example:\r\n        // 1 ART = 5 USDC, priceSale = 5 000 000\r\n        // 1 ART = 8 MATIC, priceSale = 8 * (10**18), as decial of MATIC is 18 \r\n        uint256 priceSale = saleIncome[tokenART][tokenPay].priceForSale;\r\n        require (priceSale != 0, 'ARBK: Payment token not allowed');\r\n        \r\n        if(isExactPay) {\r\n            uint256 amountARTReal = amountPay * (10**9) / priceSale;          // ART decimal is always 9, so hardcoded here\r\n            require (amountARTReal >= amountART, 'ARBK: Get Less');           // amountART is the minimum ART desired to receive\r\n\r\n            TransferHelper.safeTransferFrom(tokenPay, payer, address(this), amountPay);\r\n            saleIncome[tokenART][tokenPay].amountReceived += uint128(amountPay);    // Assmume never overflow, as it is big as (3.4 *10**20)\r\n\r\n            TransferHelper.safeTransfer(tokenART, receiver, amountARTReal);\r\n            artSaleInfo[tokenART].amountSold += uint128(amountARTReal);\r\n\r\n            emit ARTSold(tokenART, tokenPay, amountARTReal, amountPay);\r\n        } else {\r\n            // The minimum payment is 1 (Payment Token) to avoid attack buying very small amount of ART tokens\r\n            uint256 amountPayReal = (amountART * priceSale + (10**9) -1 ) / (10**9);    // ART decimal is always 9, so hardcoded here            \r\n            require (amountPayReal <= amountPay, 'ARBK: Pay Less');                     // amountPay is the maximum payment \r\n\r\n            TransferHelper.safeTransferFrom(tokenPay, payer, address(this), amountPayReal);\r\n            saleIncome[tokenART][tokenPay].amountReceived += uint128(amountPayReal);    // Assmume never overflow\r\n\r\n            TransferHelper.safeTransfer(tokenART, receiver, amountART);\r\n            artSaleInfo[tokenART].amountSold += uint128(amountART);\r\n\r\n            emit ARTSold(tokenART, tokenPay, amountART, amountPayReal);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @dev Change the ART sale price based on the buyInToken. Price-zero means not-supporting\r\n     * @param artToken Address of the ART token to sell. The bank contract support multiple ART tokens.\r\n     * @param buyInToken Address of the payment token used to buy ART. \r\n     * @param price Price of the ART token priced in payment token, 1 ART = X payment token.  \r\n    */\r\n    function changeSalePrice(address artToken, address buyInToken, uint256 price ) external {\r\n        require (msg.sender == artSaleInfo[artToken].controller, \"ARBK: Not allowed\");\r\n        saleIncome[artToken][buyInToken].priceForSale = uint128(price);\r\n        emit ARTPriceChanged(artToken, buyInToken, price);    \r\n    }  \r\n\r\n    /**\r\n     * @dev Add new type of ART token and the controller, only can be called by the owner\r\n     * @param artToken Token address of the ART to add\r\n     * @param controller Address of the controller of the ART token\r\n     */\r\n    function addNewART(address artToken, address controller) external onlyOwner {\r\n        require (controller != address(0), \"ARBK: Zero Address\");\r\n        require (artSaleInfo[artToken].controller == address(0), \"ARBK: Already Added\");\r\n        artSaleInfo[artToken].controller = controller;\r\n    }  \r\n\r\n    /**\r\n     * @dev Change/shift the controller of the ART token\r\n     * @param artToken Address of the ART token to change controller\r\n     * @param newController Address of the new controller\r\n     */\r\n    function changeARTOwner(address artToken, address newController) external {\r\n        address caller = msg.sender;\r\n        require( caller ==  owner() || caller == artSaleInfo[artToken].controller, \"ARBK: Not allowed\");\r\n        require (newController != address(0), \"ARBK: Zero Address\");\r\n\r\n        artSaleInfo[artToken].controller = newController;\r\n    }  \r\n\r\n    /**\r\n     * @dev Deposit various ART token to the bank, only callable by the controller.\r\n     * @param artToken Token address of the ART to deposit. \r\n     * @param amountDeposit Amount of the ART to deposit.\r\n     */\r\n    function depositART(address artToken, uint256 amountDeposit) external {\r\n        require (msg.sender == artSaleInfo[artToken].controller, \"ARBK: Not allowed\");\r\n\r\n        uint256 amount = artSaleInfo[artToken].amountDeposited;\r\n        require ((amount = (amount + amountDeposit)) < type(uint128).max, \"ARBK: Deposit overflowed\" );\r\n\r\n        TransferHelper.safeTransferFrom(artToken, msg.sender, address(this), amountDeposit);\r\n        artSaleInfo[artToken].amountDeposited = uint128(amount);\r\n        emit Deposit(artToken, amountDeposit);\r\n    }  \r\n\r\n    /**\r\n     * @dev Withdraw all the sales income\r\n     * @param artToken Address of the ART token to withdraw\r\n     * @param payToken Address of the payment token to withdraw\r\n     */\r\n    function withdraw(address artToken, address payToken) external {\r\n        require (msg.sender == artSaleInfo[artToken].controller, \"ARBK: Not allowed\");\r\n\r\n        address receiver = artSaleInfo[artToken].fundReceiver;\r\n        if (receiver == address(0)) receiver = msg.sender;\r\n\r\n        uint256 balance = saleIncome[artToken][payToken].amountReceived;\r\n        if (payToken == tokenNative) {\r\n            uint256 amountNative=  IERC20(tokenNative).balanceOf(address(this));\r\n            IWETH(tokenNative).withdraw(amountNative);\r\n            TransferHelper.safeTransferETH(receiver, balance);\r\n        }    \r\n        else {\r\n            TransferHelper.safeTransfer(payToken, receiver, balance);\r\n        }\r\n        emit Withdraw(artToken, payToken, balance);    \r\n    }\r\n\r\n    /**\r\n     * @dev Set the income receiver address\r\n     * @param artToken Address of the ART token to set receiver\r\n     * @param receiver Address of the receiver\r\n     */\r\n    function setFundReceiver(address artToken, address receiver) external {\r\n        require (msg.sender == artSaleInfo[artToken].controller, \"ARBK: Not allowed\");\r\n        artSaleInfo[artToken].fundReceiver = receiver;\r\n    } \r\n\r\n    function _msgSender() internal override view returns (address sender) {\r\n        sender = msg.sender;\r\n        if (msg.data.length >= 20 && forwarders[sender]) {\r\n            assembly {\r\n                sender := shr(96,calldataload(sub(calldatasize(),20)))\r\n            }\r\n        }    \r\n    }\r\n\r\n    function setForwarder(address forwarder, bool active) external onlyOwner {\r\n        forwarders[forwarder] = active;\r\n    }\r\n\r\n}"
    },
    "contracts/ArkreenBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/utils/StringsUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\r\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\r\n\r\nimport './ArkreenBuilderStorage.sol';\r\nimport \"./interfaces/IPausable.sol\";\r\n\r\nimport \"./libraries/TransferHelper.sol\";\r\nimport \"./interfaces/IERC20.sol\";\r\nimport \"./interfaces/IWETH.sol\";\r\n\r\nimport \"./interfaces/IERC20Permit.sol\";\r\nimport \"./ArkreenBuilderTypes.sol\";\r\nimport \"./interfaces/IArkreenRECBank.sol\";\r\nimport \"./interfaces/IFeSwapRouter.sol\";\r\nimport \"./interfaces/ISwapRouter.sol\";\r\nimport \"./interfaces/IArkreenRECToken.sol\";\r\n\r\n// Import this file to use console.log\r\n// import \"hardhat/console.sol\";\r\n\r\ncontract ArkreenBuilder is\r\n    OwnableUpgradeable,\r\n    UUPSUpgradeable,\r\n    ArkreenBuilderStorage\r\n{\r\n    using AddressUpgradeable for address;\r\n\r\n    // Public variables\r\n    string public constant NAME = 'Arkreen Climate Actor';\r\n\r\n    // Events\r\n\r\n    // Modifiers\r\n    modifier ensure(uint deadline) {\r\n        require(deadline >= block.timestamp, 'ARB: EXPIRED');\r\n        _;\r\n    }\r\n  \r\n    /// @custom:oz-upgrades-unsafe-allow constructor\r\n    constructor() {\r\n        _disableInitializers();\r\n    }\r\n\r\n    function initialize(address router, address sales, address native) external virtual initializer {\r\n        __Ownable_init_unchained();\r\n        __UUPSUpgradeable_init();     \r\n        routerSwap = router;\r\n        artBank = sales;\r\n        tokenNative = native;\r\n    }   \r\n\r\n    function postUpdate(address sales) external onlyProxy onlyOwner {\r\n        artBank = sales;\r\n    }\r\n\r\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner\r\n    {}\r\n\r\n    receive() external payable {\r\n        assert(msg.sender == tokenNative); // only accept WMATIC via fallback from the WMATIC contract\r\n    }  \r\n\r\n    /** \r\n     * @dev Offset the specified amount of ART tokens to create a climate action.\r\n     * @param tokenART Address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountART Amount of the ART token to offset.\r\n     * @param deadline Deadline to handle the transaction.\r\n     */\r\n    function actionBuilderWithART(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        uint256             deadline\r\n    ) external ensure(deadline) {\r\n\r\n        // Transfer payement: bytes4(keccak256(bytes('transferFrom(address from ,address to ,uint256 amount)')));\r\n        bytes memory data1 = abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), amountART);\r\n        (bool success, bytes memory data) = tokenART.call(abi.encodePacked(data1, address(this)));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n\r\n        // commitOffset(uint256 amount): 0xe8fef571\r\n        bytes memory callData = abi.encodeWithSelector(0xe8fef571, amountART);\r\n\r\n        _offsetART(tokenART, abi.encodePacked(callData, _msgSender()));\r\n    }\r\n   \r\n\r\n    /** \r\n     * @dev Buy the ART token with specified token, then offset the bought ART to create a climate action.\r\n     * @param tokenPay The address of the token to pay for the ART token.\r\n     * @param tokenART The address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountPay The amount of the payment token. \r\n     *                  if modeAction bit0 is true, amountPay should be paid to swap tokenART.\r\n     *                  if modeAction bit0 is false, amountPay means the maximum amount to pay. \r\n     * @param amountART The amount of the ART token.\r\n     *                  if modeAction bit0 is true, amountART means the minumum ART token to receive, which may be zero for no checking.\r\n     *                  if modeAction bit0 is false, amountART is the amount of ART token to receive.\r\n     * @param modeAction Which amount is the exact amount, and which source to get ART\r\n     *                  bit0 = 1, amountPay is the exact amount of the payment token to pay.\r\n     *                  bit0 = 0, amountART is the exact amount of the ART token to receive.\r\n     *                  bit1 = 0, Swap ART from Dex\r\n     *                  bit1 = 1, But ART from art sales bank\r\n     *                  bit2 = 0, re-pay to _msgSender()\r\n     *                  bit2 = 1, re-pay to msg.sender\r\n     *                  bit3 = 0, Use Uniswap V2 liquidity pool\r\n     *                  bit3 = 1, Use Uniswap V3 liquidity pool    \r\n     *                  Byte4-Byte23, sqrtPriceLimitX96 for Uniswap V3, uint160\r\n     */\r\n    function actionBuilder(\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        uint256             deadline\r\n    ) external {               // Deadline will be checked by router, no need to check here. //ensure(permitToPay.deadline)\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(tokenPay, msg.sender, address(this), amountPay);\r\n        _actionBuilder (tokenPay, tokenART, amountPay, amountART, modeAction, deadline);\r\n    }\r\n\r\n    /** \r\n     * @dev Buy the ART token with Native token, then offset the bought ART.\r\n     * @param tokenART The address of the ART token. There may be serveral different ART tokens in the AREC ecosystem.\r\n     * @param amountART The amount of the ART token.\r\n     *                  if modeAction bit0 is true, amountART means the minumum ART token to receive, which may be zero for no checking.\r\n     *                  if modeAction bit0 is false, amountART is the amount of ART token to receive.\r\n     * @param modeAction Which amount is the exact amount, and which source to get ART\r\n     *                  bit0 = 1, amountPay is the exact amount of the payment token to pay.\r\n     *                  bit0 = 0, amountART is the exact amount of the ART token to receive.\r\n     *                  bit1 = 0, Swap ART from Dex\r\n     *                  bit1 = 1, But ART from art sales bank\r\n     *                  bit2 = 0, re-pay to _msgSender()\r\n     *                  bit2 = 1, re-pay to msg.sender\r\n     *                  bit3 = 0, Use Uniswap V2 liquidity pool\r\n     *                  bit3 = 1, Use Uniswap V3 liquidity pool    \r\n     *                  Byte4-Byte23, sqrtPriceLimitX96 for Uniswap V3, uint160\r\n     */\r\n    function actionBuilderNative(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        uint256             deadline\r\n    ) external payable {               // Deadline will be checked by router, no need to check here.\r\n\r\n        // Wrap MATIC to WMATIC  \r\n        IWETH(tokenNative).deposit{value: msg.value}();\r\n        _actionBuilder(tokenNative, tokenART, msg.value, amountART, modeAction, deadline);\r\n    }   \r\n\r\n   /** \r\n     * @dev Buy the ART token with specified token, then offset the bought ART.\r\n     * @param tokenART The address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountART The amount of the ART token.\r\n     *                  if modeAction bit0 is true, amountART means the minumum ART token to receive, which may be zero for no checking.\r\n     *                  if modeAction bit0 is false, amountART is the amount of ART token to receive.\r\n     * @param modeAction Which amount is the exact amount, and which source to get ART\r\n     *                  bit0 = 1, amountPay is the exact amount of the payment token to pay.\r\n     *                  bit0 = 0, amountART is the exact amount of the ART token to receive.\r\n     *                  bit1 = 0, Swap ART from Dex\r\n     *                  bit1 = 1, But ART from art sales bank\r\n     *                  bit2 = 0, re-pay to _msgSender()\r\n     *                  bit2 = 1, re-pay to msg.sender\r\n     *                  bit3 = 0, Use Uniswap V2 liquidity pool\r\n     *                  bit3 = 1, Use Uniswap V3 liquidity pool    \r\n     *                  Byte4-Byte23, sqrtPriceLimitX96 for Uniswap V3, uint160   \r\n     * @param permitToPay The permit information to approve the payment token to swap for ART token \r\n     */\r\n    function actionBuilderWithPermit(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        Signature calldata  permitToPay\r\n    ) external  {                       // Deadline will be checked by router, no need to check here.\r\n        // Permit payment token\r\n        address payer = msg.sender;\r\n        IERC20Permit(permitToPay.token).permit(payer, address(this), \r\n                        permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(permitToPay.token, payer, address(this), permitToPay.value);\r\n        _actionBuilder(permitToPay.token, tokenART, permitToPay.value, amountART, modeAction, permitToPay.deadline);\r\n    }\r\n\r\n    /** \r\n     * @dev Offset the specified amount of ART tokens to create a climate action.\r\n     * @param tokenART Address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountART Amount of the ART token to offset.\r\n     * @param deadline Deadline to handle the transaction.\r\n     * @param badgeInfo The information to be included for climate badge.\r\n     */\r\n    function actionBuilderBadgeWithART(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        uint256             deadline,\r\n        BadgeInfo calldata  badgeInfo\r\n    ) external ensure(deadline) {\r\n\r\n        // Transfer payement: bytes4(keccak256(bytes('transferFrom(address,address,uint256)')));\r\n        bytes memory data1 = abi.encodeWithSelector(0x23b872dd, msg.sender, address(this), amountART);\r\n        (bool success, bytes memory data) = tokenART.call(abi.encodePacked(data1, address(this)));\r\n        require(success && (data.length == 0 || abi.decode(data, (bool))), 'TransferHelper: TRANSFER_FROM_FAILED');\r\n\r\n        // offsetAndMintCertificate(address beneficiary,string offsetEntityID,string beneficiaryID,string offsetMessage,uint256 amount)\r\n        // offsetAndMintCertificate(address,string,string,string,uint256): signature = 0x0fba6a8d\r\n        bytes memory callData = abi.encodeWithSelector(0x0fba6a8d, badgeInfo.beneficiary, badgeInfo.offsetEntityID, \r\n                                            badgeInfo.beneficiaryID, badgeInfo.offsetMessage, amountART);\r\n\r\n        _offsetART(tokenART, abi.encodePacked(callData, _msgSender()));\r\n    }    \r\n\r\n    /** \r\n     * @dev Buy the ART token, then offset the bought ART and mint a cliamte badge.\r\n     * @param tokenPay The address of the token to pay for the ART token.\r\n     * @param tokenART The address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountPay The amount of the payment token. \r\n     *                  if modeAction bit0 is true, amountPay should be same as the value in permitToPay.\r\n     *                  if modeAction bit0 is false, amountPay means the maximum amount available to pay, if it not zero. \r\n     * @param amountART The amount of the ART token.\r\n     *                  if modeAction bit0 is true, amountART means the minumum ART token to receive, which may be zero for no checking.\r\n     *                  if modeAction bit0 is false, amountART is the amount of ART token to receive.\r\n     * @param modeAction Which amount is the exact amount, and which source to get ART\r\n     *                  bit0 = 1, amountPay is the exact amount of the payment token to pay.\r\n     *                  bit0 = 0, amountART is the exact amount of the ART token to receive.\r\n     *                  bit1 = 0, Swap ART from Dex\r\n     *                  bit1 = 1, But ART from art sales bank     \r\n     *                  bit2 = 0, re-pay to _msgSender()\r\n     *                  bit2 = 1, re-pay to msg.sender\r\n     *                  bit3 = 0, Use Uniswap V2 liquidity pool\r\n     *                  bit3 = 1, Use Uniswap V3 liquidity pool    \r\n     *                  Byte4-Byte23, sqrtPriceLimitX96 for Uniswap V3, uint160\r\n     * @param badgeInfo The information to be included for climate badge.\r\n     */\r\n    function actionBuilderBadge(\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        uint256             deadline,\r\n        BadgeInfo calldata  badgeInfo\r\n    ) external {               // Deadline will be checked by router, no need to check here. //ensure(permitToPay.deadline)\r\n\r\n        // Transfer payement\r\n        TransferHelper.safeTransferFrom(tokenPay, msg.sender, address(this), amountPay);\r\n\r\n        _actionBuilderBadge (tokenPay, tokenART, amountPay, amountART, modeAction, deadline, badgeInfo);\r\n    }\r\n\r\n    /** \r\n     * @dev Buy the ART token, then offset the bought ART and mint a cliamte badge.\r\n     * @param tokenART The address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountART The amount of the ART token.\r\n     *                  if modeAction bit0 is true, amountART means the minumum ART token to receive, which may be zero for no checking.\r\n     *                  if modeAction bit0 is false, amountART is the amount of ART token to receive.\r\n     * @param modeAction Which amount is the exact amount, and which source to get ART\r\n     *                  bit0 = 1, amountPay is the exact amount of the payment token to pay.\r\n     *                  bit0 = 0, amountART is the exact amount of the ART token to receive.\r\n     *                  bit1 = 0, Swap ART from Dex\r\n     *                  bit1 = 1, But ART from art sales bank\r\n     *                  bit2 = 0, re-pay to _msgSender()\r\n     *                  bit2 = 1, re-pay to msg.sender\r\n     *                  bit3 = 0, Use Uniswap V2 liquidity pool\r\n     *                  bit3 = 1, Use Uniswap V3 liquidity pool    \r\n     *                  Byte4-Byte23, sqrtPriceLimitX96 for Uniswap V3, uint160        \r\n     * @param badgeInfo The information to be included for climate badge.\r\n     */\r\n    function actionBuilderBadgeNative(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        uint256             deadline,\r\n        BadgeInfo calldata  badgeInfo\r\n    ) external payable {               // Deadline will be checked by router, no need to check here. //ensure(permitToPay.deadline)\r\n\r\n        // Wrap MATIC to WMATIC  \r\n        IWETH(tokenNative).deposit{value: msg.value}();\r\n        _actionBuilderBadge(tokenNative, tokenART, msg.value, amountART, modeAction, deadline, badgeInfo);\r\n    }\r\n\r\n   /** \r\n     * @dev Buy the ART token, then offset the bought ART and mint a cliamte badge.\r\n     * @param tokenART The address of the ART token. There may be serveral different ART tokens in AREC ecosystem.\r\n     * @param amountART The amount of the ART token.\r\n     *                  if modeAction bit0 is true, amountART means the minumum ART token to receive, which may be zero for no checking.\r\n     *                  if modeAction bit0 is false, amountART is the amount of ART token to receive.\r\n     * @param modeAction Which amount is the exact amount, and which source to get ART\r\n     *                  bit0 = 1, amountPay is the exact amount of the payment token to pay.\r\n     *                  bit0 = 0, amountART is the exact amount of the ART token to receive.\r\n     *                  bit1 = 0, Swap ART from Dex\r\n     *                  bit1 = 1, But ART from art sales bank   \r\n     * @param badgeInfo The information to be included for climate badge.\r\n     * @param permitToPay The permit information to approve the payment token to swap for ART token \r\n     */\r\n    function actionBuilderBadgeWithPermit(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        BadgeInfo calldata  badgeInfo,\r\n        Signature calldata  permitToPay\r\n    ) external  {               // Deadline will be checked by router, no need to check here. //ensure(permitToPay.deadline)\r\n\r\n        // Permit payment token\r\n        address payer = msg.sender;\r\n        IERC20Permit(permitToPay.token).permit(payer, address(this), \r\n                        permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\r\n\r\n        // Transfer payement \r\n        TransferHelper.safeTransferFrom(permitToPay.token, payer, address(this), permitToPay.value);\r\n        _actionBuilderBadge(permitToPay.token, tokenART, permitToPay.value, amountART, modeAction, permitToPay.deadline, badgeInfo);\r\n    }\r\n\r\n    function _swapARTToken(\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        uint256             deadline\r\n    ) internal returns (uint256) {\r\n\r\n        bool isExactIn = (modeAction&0x01) == 0x01;\r\n        if(modeAction & 0x02 != 0x00) {\r\n            IArkreenRECBank(artBank).buyART(tokenPay, tokenART, amountPay, amountART, isExactIn);\r\n        } else {\r\n            if(modeAction & 0x08 == 0x00) {                   // Check UniV2/UniV3 Pool\r\n                address[] memory swapPath = new address[](2);\r\n                swapPath[0] = tokenPay;\r\n                swapPath[1] = tokenART;\r\n\r\n                if(isExactIn) {\r\n                    IFeSwapRouter(routerSwap).swapExactTokensForTokens(amountPay, amountART, swapPath, address(this), deadline);\r\n                } else {\r\n                    IFeSwapRouter(routerSwap).swapTokensForExactTokens(amountART, amountPay, swapPath, address(this), deadline);\r\n                }\r\n            } else {\r\n                if(isExactIn) {\r\n                    ISwapRouter.ExactInputSingleParams memory exactInputParams = \r\n                        ISwapRouter.ExactInputSingleParams({\r\n                            tokenIn:            tokenPay,\r\n                            tokenOut:           tokenART,\r\n                            fee:                3000,\r\n                            recipient:          address(this),\r\n                            deadline:           deadline,\r\n                            amountIn:           amountPay,\r\n                            amountOutMinimum:   amountART,\r\n                            sqrtPriceLimitX96:  uint160(modeAction >> 32)\r\n                        });\r\n                    ISwapRouter(routerSwap).exactInputSingle(exactInputParams);\r\n                } else { \r\n                    ISwapRouter.ExactOutputSingleParams memory ExactOutputParam = \r\n                        ISwapRouter.ExactOutputSingleParams({\r\n                            tokenIn:            tokenPay,\r\n                            tokenOut:           tokenART,\r\n                            fee:                3000,\r\n                            recipient:          address(this),\r\n                            deadline:           deadline,\r\n                            amountOut:          amountART,\r\n                            amountInMaximum:    amountPay,\r\n                            sqrtPriceLimitX96:  uint160(modeAction >> 32)\r\n                    });\r\n                    ISwapRouter(routerSwap).exactOutputSingle(ExactOutputParam);\r\n                }\r\n            }\r\n        }\r\n\r\n        return isExactIn ? IERC20(tokenART).balanceOf(address(this)) : amountART;\r\n    }\r\n\r\n    function _actionBuilder(\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        uint256             deadline\r\n    ) internal {\r\n\r\n        uint256 amountOffset = _swapARTToken(tokenPay, tokenART, amountPay, amountART, modeAction, deadline);  \r\n \r\n        // commitOffset(uint256 amount): 0xe8fef571\r\n        bytes memory callData = abi.encodeWithSelector(0xe8fef571, amountOffset);\r\n\r\n        address payer = _msgSender();\r\n        _offsetART(tokenART, abi.encodePacked(callData, payer));\r\n \r\n        // Repay more payment back  \r\n        _payBackOverPayment(tokenPay, payer, modeAction);\r\n    }\r\n\r\n    function _actionBuilderBadge(\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        uint256             modeAction,\r\n        uint256             deadline,\r\n        BadgeInfo calldata  badgeInfo\r\n    ) internal {\r\n\r\n        uint256 amountOffset = _swapARTToken(tokenPay, tokenART, amountPay, amountART, modeAction, deadline);       \r\n\r\n        // offsetAndMintCertificate(address beneficiary,string offsetEntityID,string beneficiaryID,string offsetMessage,uint256 amount)\r\n        // offsetAndMintCertificate(address,string,string,string,uint256): signature = 0x0fba6a8d\r\n        bytes memory callData = abi.encodeWithSelector(0x0fba6a8d, badgeInfo.beneficiary, badgeInfo.offsetEntityID, \r\n                                            badgeInfo.beneficiaryID, badgeInfo.offsetMessage, amountOffset);\r\n\r\n        address payer = _msgSender();\r\n        _offsetART(tokenART, abi.encodePacked(callData, payer));\r\n  \r\n        // Repay more payment back  \r\n        _payBackOverPayment(tokenPay, payer, modeAction);\r\n    }\r\n\r\n    function _payBackOverPayment(\r\n        address tokenPay,\r\n        address msgSender,\r\n        uint256 modeAction\r\n    ) internal {\r\n        if(modeAction & 0x01 == 0x00) {      \r\n            address repayTo = (modeAction & 0x04 != 0x00) ? msg.sender : msgSender;\r\n\r\n            uint256 amountPayLeft = IERC20(tokenPay).balanceOf(address(this));\r\n            if(amountPayLeft > 0) {\r\n                if((tokenPay == tokenNative) && !address(repayTo).isContract()) {\r\n                    IWETH(tokenNative).withdraw(amountPayLeft);\r\n                    TransferHelper.safeTransferETH(repayTo, amountPayLeft);\r\n                } else {\r\n                    TransferHelper.safeTransfer(tokenPay, repayTo, amountPayLeft);\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /** \r\n     * @dev Call ART token contract to offset the ART token, and optoinally mint the climate badge according to calldata.\r\n     * @param tokenART Address of the ART token contract. \r\n     * @param callData Calldata to call ART token.\r\n     */\r\n    function _offsetART(\r\n        address         tokenART,\r\n        bytes   memory  callData\r\n    ) internal {\r\n\r\n        (bool success, bytes memory returndata) = tokenART.call(abi.encodePacked(callData, _msgSender()));\r\n\r\n        if (!success) {\r\n            if (returndata.length > 0) {\r\n                // solhint-disable-next-line no-inline-assembly\r\n                assembly {\r\n                    let returndata_size := mload(returndata)\r\n                    revert(add(32, returndata), returndata_size)\r\n                }\r\n            } else {\r\n                revert(\"BLD: Error Call to offsetAndMintCertificate\");\r\n            }\r\n        }\r\n    }\r\n\r\n    function _msgSender() internal override view returns (address signer) {\r\n        signer = msg.sender;\r\n        if (msg.data.length>=20 && trustedForwarders[signer]) {\r\n            assembly {\r\n                signer := shr(96,calldataload(sub(calldatasize(),20)))\r\n            }\r\n        }    \r\n    }    \r\n\r\n    function mangeTrustedForwarder(address forwarder, bool addOrRemove) external onlyOwner {\r\n        require(forwarder != address(0), \"BLD: Zero Forwarder\");\r\n        trustedForwarders[forwarder] = addOrRemove;\r\n    }      \r\n \r\n    function approveRouter(address[] memory tokens) external onlyOwner {\r\n        require(routerSwap != address(0), \"BLD: No Router\");\r\n        for(uint256 i = 0; i < tokens.length; i++) {\r\n            TransferHelper.safeApprove(tokens[i], routerSwap, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    function approveArtBank(address[] memory tokens) external onlyOwner {\r\n        require(artBank != address(0), \"BLD: No Banker\");\r\n        for(uint256 i = 0; i < tokens.length; i++) {\r\n            TransferHelper.safeApprove(tokens[i], artBank, type(uint256).max);\r\n        }\r\n    }\r\n\r\n    function getVersion() external pure virtual returns (string memory) {\r\n        return \"0.2.0\";\r\n    }\r\n}\r\n"
    },
    "contracts/ArkreenBuilderStorage.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"./ArkreenBuilderTypes.sol\";  \n\nabstract contract ArkreenBuilderStorage {\n\n    address public routerSwap;            // Address of the DEX router\n    address public tokenNative;           // The wrapped token of the Native token, such as WETH, WMATIC\n\n    mapping(address => bool) public trustedForwarders;         // List of trusted Forwarders\n    address public artBank;               // Address of the ART sales bank contract\n\n//  mapping(address => mapping(address => twinPair)) public pools;             // ART token => (pair token => two LP pools) \n\n}"
    },
    "contracts/interfaces/IArkreenRECBank.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\ninterface IArkreenRECBank {\r\n\r\n    struct Signature {\r\n        address     token;\r\n        uint256     value;\r\n        uint256     deadline;  \r\n        uint8       v;\r\n        bytes32     r;\r\n        bytes32     s;              \r\n    }\r\n\r\n    function buyART(\r\n        address             tokenPay,\r\n        address             tokenART,\r\n        uint256             amountPay,\r\n        uint256             amountART,\r\n        bool                isExactPay\r\n    ) external;\r\n\r\n    function buyARTNative(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        bool                isExactPay\r\n    ) external payable; \r\n\r\n\r\n    function buyARTWithPermit(\r\n        address             tokenART,\r\n        uint256             amountART,\r\n        bool                isExactPay,\r\n        Signature calldata  permitToPay\r\n    ) external;\r\n\r\n    function saleIncome(\r\n        address             tokenART,\r\n        address             tokenPay     \r\n    ) external view returns (uint128 priceForSale, uint128 amountReceived);\r\n}\r\n"
    },
    "contracts/interfaces/IFeSwapRouter.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\npragma experimental ABIEncoderV2;\n\ninterface IFeSwapRouter {\n\n    struct AddLiquidityParams {\n        address tokenA;\n        address tokenB;\n        uint    amountADesired;\n        uint    amountBDesired;\n        uint    amountAMin;\n        uint    amountBMin;\n        uint    ratio;\n    }\n\n    struct AddLiquidityETHParams {\n        address token;\n        uint    amountTokenDesired;\n        uint    amountTokenMin;\n        uint    amountETHMin;\n        uint    ratio;\n    }\n\n    struct RemoveLiquidityParams {\n        address tokenA;\n        address tokenB;\n        uint    liquidityAAB;\n        uint    liquidityABB;        \n        uint    amountAMin;\n        uint    amountBMin;\n    }\n\n    struct Signature {\n        uint8       v;\n        bytes32     r;\n        bytes32     s;\n    }\n\n    function factory() external pure returns (address);\n    function WETH() external pure returns (address);\n\n    function addLiquidity(\n        AddLiquidityParams calldata addParams,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB, uint liquidityAAB, uint liquidityABB);\n\n    function addLiquidityETH(\n        AddLiquidityETHParams calldata addParams,\n        address to,\n        uint deadline\n    ) external payable returns (uint amountToken, uint amountETH, uint liquidityTTE, uint liquidityTEE);\n\n    function removeLiquidity(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline\n    ) external returns (uint amountA, uint amountB);\n\n    function removeLiquidityETH(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityWithPermit(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline,\n        bool approveMax, \n        Signature   calldata sigAAB,\n        Signature   calldata sigABB\n    ) external returns (uint amountA, uint amountB);        \n\n    function removeLiquidityETHWithPermit(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline,\n        bool approveMax, \n        Signature   calldata sigTTE,\n        Signature   calldata sigTEE\n    ) external returns (uint amountToken, uint amountETH);\n\n    function removeLiquidityETHFeeOnTransfer(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline\n    ) external returns (uint amountETH);\n\n    function removeLiquidityETHWithPermitFeeOnTransfer(\n        RemoveLiquidityParams calldata removeParams,\n        address to,\n        uint deadline,\n        bool approveMax, \n        Signature   calldata sigTTE,\n        Signature   calldata sigTEE\n    ) external returns (uint amountETH);\n\n    function swapExactTokensForTokens(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapTokensForExactTokens(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactETHForTokens(\n        uint amountOutMin, \n        address[] calldata path, \n        address to, \n        uint deadline\n    ) external payable returns (uint[] memory amounts);\n\n    function swapTokensForExactETH(\n        uint amountOut,\n        uint amountInMax,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapExactTokensForETH(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external returns (uint[] memory amounts);\n\n    function swapETHForExactTokens(\n        uint amountOut,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable returns (uint[] memory amounts);     \n\n    function swapExactTokensForTokensFeeOnTransfer(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n\n    function swapExactETHForTokensFeeOnTransfer(\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external payable;\n\n    function swapExactTokensForETHFeeOnTransfer(\n        uint amountIn,\n        uint amountOutMin,\n        address[] calldata path,\n        address to,\n        uint deadline\n    ) external;\n    \n    function quote(uint amountA, uint reserveA, uint reserveB) external pure returns (uint amountB);\n    function getAmountOut(uint amountIn, uint reserveIn, uint reserveOut) external pure returns (uint amountOut);\n    function getAmountIn(uint amountOut, uint reserveIn, uint reserveOut) external pure returns (uint amountIn);\n    function estimateAmountsOut(uint amountIn, address[] calldata path) external view returns (uint[] memory amounts);\n    function estimateAmountsIn(uint amountOut, address[] calldata path) external view returns (uint[] memory amounts);\n}"
    },
    "contracts/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/interfaces/IArkreenRECToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\ninterface IArkreenRECToken {\n    function commitOffset(uint256) external returns (uint256); \n    function commitOffsetFrom(address, uint256) external returns (uint256);     \n    function offsetAndMintCertificate(  address beneficiary, string calldata offsetEntityID,\n                                        string calldata beneficiaryID, string calldata offsetMessage, uint256 amount) external;\n}"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#swap\n/// @notice Any contract that calls IUniswapV3PoolActions#swap must implement this interface\ninterface IUniswapV3SwapCallback {\n    /// @notice Called to `msg.sender` after executing a swap via IUniswapV3Pool#swap.\n    /// @dev In the implementation you must pay the pool tokens owed for the swap.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// amount0Delta and amount1Delta can both be 0 if no tokens were swapped.\n    /// @param amount0Delta The amount of token0 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token0 to the pool.\n    /// @param amount1Delta The amount of token1 that was sent (negative) or must be received (positive) by the pool by\n    /// the end of the swap. If positive, the callback must send that amount of token1 to the pool.\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#swap call\n    function uniswapV3SwapCallback(\n        int256 amount0Delta,\n        int256 amount1Delta,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Pool.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nimport './pool/IUniswapV3PoolImmutables.sol';\nimport './pool/IUniswapV3PoolState.sol';\nimport './pool/IUniswapV3PoolDerivedState.sol';\nimport './pool/IUniswapV3PoolActions.sol';\nimport './pool/IUniswapV3PoolOwnerActions.sol';\nimport './pool/IUniswapV3PoolEvents.sol';\n\n/// @title The interface for a Uniswap V3 Pool\n/// @notice A Uniswap pool facilitates swapping and automated market making between any two assets that strictly conform\n/// to the ERC20 specification\n/// @dev The pool interface is broken up into many smaller pieces\ninterface IUniswapV3Pool is\n    IUniswapV3PoolImmutables,\n    IUniswapV3PoolState,\n    IUniswapV3PoolDerivedState,\n    IUniswapV3PoolActions,\n    IUniswapV3PoolOwnerActions,\n    IUniswapV3PoolEvents\n{\n\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolImmutables.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that never changes\n/// @notice These parameters are fixed for a pool forever, i.e., the methods will always return the same values\ninterface IUniswapV3PoolImmutables {\n    /// @notice The contract that deployed the pool, which must adhere to the IUniswapV3Factory interface\n    /// @return The contract address\n    function factory() external view returns (address);\n\n    /// @notice The first of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token0() external view returns (address);\n\n    /// @notice The second of the two tokens of the pool, sorted by address\n    /// @return The token contract address\n    function token1() external view returns (address);\n\n    /// @notice The pool's fee in hundredths of a bip, i.e. 1e-6\n    /// @return The fee\n    function fee() external view returns (uint24);\n\n    /// @notice The pool tick spacing\n    /// @dev Ticks can only be used at multiples of this value, minimum of 1 and always positive\n    /// e.g.: a tickSpacing of 3 means ticks can be initialized every 3rd tick, i.e., ..., -6, -3, 0, 3, 6, ...\n    /// This value is an int24 to avoid casting even though it is always positive.\n    /// @return The tick spacing\n    function tickSpacing() external view returns (int24);\n\n    /// @notice The maximum amount of position liquidity that can use any tick in the range\n    /// @dev This parameter is enforced per tick to prevent liquidity from overflowing a uint128 at any point, and\n    /// also prevents out-of-range liquidity from being used to prevent adding in-range liquidity to a pool\n    /// @return The max amount of liquidity per tick\n    function maxLiquidityPerTick() external view returns (uint128);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that can change\n/// @notice These methods compose the pool's state, and can change with any frequency including multiple times\n/// per transaction\ninterface IUniswapV3PoolState {\n    /// @notice The 0th storage slot in the pool stores many values, and is exposed as a single method to save gas\n    /// when accessed externally.\n    /// @return sqrtPriceX96 The current price of the pool as a sqrt(token1/token0) Q64.96 value\n    /// tick The current tick of the pool, i.e. according to the last tick transition that was run.\n    /// This value may not always be equal to SqrtTickMath.getTickAtSqrtRatio(sqrtPriceX96) if the price is on a tick\n    /// boundary.\n    /// observationIndex The index of the last oracle observation that was written,\n    /// observationCardinality The current maximum number of observations stored in the pool,\n    /// observationCardinalityNext The next maximum number of observations, to be updated when the observation.\n    /// feeProtocol The protocol fee for both tokens of the pool.\n    /// Encoded as two 4 bit values, where the protocol fee of token1 is shifted 4 bits and the protocol fee of token0\n    /// is the lower 4 bits. Used as the denominator of a fraction of the swap fee, e.g. 4 means 1/4th of the swap fee.\n    /// unlocked Whether the pool is currently locked to reentrancy\n    function slot0()\n        external\n        view\n        returns (\n            uint160 sqrtPriceX96,\n            int24 tick,\n            uint16 observationIndex,\n            uint16 observationCardinality,\n            uint16 observationCardinalityNext,\n            uint8 feeProtocol,\n            bool unlocked\n        );\n\n    /// @notice The fee growth as a Q128.128 fees of token0 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal0X128() external view returns (uint256);\n\n    /// @notice The fee growth as a Q128.128 fees of token1 collected per unit of liquidity for the entire life of the pool\n    /// @dev This value can overflow the uint256\n    function feeGrowthGlobal1X128() external view returns (uint256);\n\n    /// @notice The amounts of token0 and token1 that are owed to the protocol\n    /// @dev Protocol fees will never exceed uint128 max in either token\n    function protocolFees() external view returns (uint128 token0, uint128 token1);\n\n    /// @notice The currently in range liquidity available to the pool\n    /// @dev This value has no relationship to the total liquidity across all ticks\n    function liquidity() external view returns (uint128);\n\n    /// @notice Look up information about a specific tick in the pool\n    /// @param tick The tick to look up\n    /// @return liquidityGross the total amount of position liquidity that uses the pool either as tick lower or\n    /// tick upper,\n    /// liquidityNet how much liquidity changes when the pool price crosses the tick,\n    /// feeGrowthOutside0X128 the fee growth on the other side of the tick from the current tick in token0,\n    /// feeGrowthOutside1X128 the fee growth on the other side of the tick from the current tick in token1,\n    /// tickCumulativeOutside the cumulative tick value on the other side of the tick from the current tick\n    /// secondsPerLiquidityOutsideX128 the seconds spent per liquidity on the other side of the tick from the current tick,\n    /// secondsOutside the seconds spent on the other side of the tick from the current tick,\n    /// initialized Set to true if the tick is initialized, i.e. liquidityGross is greater than 0, otherwise equal to false.\n    /// Outside values can only be used if the tick is initialized, i.e. if liquidityGross is greater than 0.\n    /// In addition, these values are only relative and must be used only in comparison to previous snapshots for\n    /// a specific position.\n    function ticks(int24 tick)\n        external\n        view\n        returns (\n            uint128 liquidityGross,\n            int128 liquidityNet,\n            uint256 feeGrowthOutside0X128,\n            uint256 feeGrowthOutside1X128,\n            int56 tickCumulativeOutside,\n            uint160 secondsPerLiquidityOutsideX128,\n            uint32 secondsOutside,\n            bool initialized\n        );\n\n    /// @notice Returns 256 packed tick initialized boolean values. See TickBitmap for more information\n    function tickBitmap(int16 wordPosition) external view returns (uint256);\n\n    /// @notice Returns the information about a position by the position's key\n    /// @param key The position's key is a hash of a preimage composed by the owner, tickLower and tickUpper\n    /// @return _liquidity The amount of liquidity in the position,\n    /// Returns feeGrowthInside0LastX128 fee growth of token0 inside the tick range as of the last mint/burn/poke,\n    /// Returns feeGrowthInside1LastX128 fee growth of token1 inside the tick range as of the last mint/burn/poke,\n    /// Returns tokensOwed0 the computed amount of token0 owed to the position as of the last mint/burn/poke,\n    /// Returns tokensOwed1 the computed amount of token1 owed to the position as of the last mint/burn/poke\n    function positions(bytes32 key)\n        external\n        view\n        returns (\n            uint128 _liquidity,\n            uint256 feeGrowthInside0LastX128,\n            uint256 feeGrowthInside1LastX128,\n            uint128 tokensOwed0,\n            uint128 tokensOwed1\n        );\n\n    /// @notice Returns data about a specific observation index\n    /// @param index The element of the observations array to fetch\n    /// @dev You most likely want to use #observe() instead of this method to get an observation as of some amount of time\n    /// ago, rather than at a specific index in the array.\n    /// @return blockTimestamp The timestamp of the observation,\n    /// Returns tickCumulative the tick multiplied by seconds elapsed for the life of the pool as of the observation timestamp,\n    /// Returns secondsPerLiquidityCumulativeX128 the seconds per in range liquidity for the life of the pool as of the observation timestamp,\n    /// Returns initialized whether the observation has been initialized and the values are safe to use\n    function observations(uint256 index)\n        external\n        view\n        returns (\n            uint32 blockTimestamp,\n            int56 tickCumulative,\n            uint160 secondsPerLiquidityCumulativeX128,\n            bool initialized\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolDerivedState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Pool state that is not stored\n/// @notice Contains view functions to provide information about the pool that is computed rather than stored on the\n/// blockchain. The functions here may have variable gas costs.\ninterface IUniswapV3PoolDerivedState {\n    /// @notice Returns the cumulative tick and liquidity as of each timestamp `secondsAgo` from the current block timestamp\n    /// @dev To get a time weighted average tick or liquidity-in-range, you must call this with two values, one representing\n    /// the beginning of the period and another for the end of the period. E.g., to get the last hour time-weighted average tick,\n    /// you must call it with secondsAgos = [3600, 0].\n    /// @dev The time weighted average tick represents the geometric time weighted average price of the pool, in\n    /// log base sqrt(1.0001) of token1 / token0. The TickMath library can be used to go from a tick value to a ratio.\n    /// @param secondsAgos From how long ago each cumulative tick and liquidity value should be returned\n    /// @return tickCumulatives Cumulative tick values as of each `secondsAgos` from the current block timestamp\n    /// @return secondsPerLiquidityCumulativeX128s Cumulative seconds per liquidity-in-range value as of each `secondsAgos` from the current block\n    /// timestamp\n    function observe(uint32[] calldata secondsAgos)\n        external\n        view\n        returns (int56[] memory tickCumulatives, uint160[] memory secondsPerLiquidityCumulativeX128s);\n\n    /// @notice Returns a snapshot of the tick cumulative, seconds per liquidity and seconds inside a tick range\n    /// @dev Snapshots must only be compared to other snapshots, taken over a period for which a position existed.\n    /// I.e., snapshots cannot be compared if a position is not held for the entire period between when the first\n    /// snapshot is taken and the second snapshot is taken.\n    /// @param tickLower The lower tick of the range\n    /// @param tickUpper The upper tick of the range\n    /// @return tickCumulativeInside The snapshot of the tick accumulator for the range\n    /// @return secondsPerLiquidityInsideX128 The snapshot of seconds per liquidity for the range\n    /// @return secondsInside The snapshot of seconds per liquidity for the range\n    function snapshotCumulativesInside(int24 tickLower, int24 tickUpper)\n        external\n        view\n        returns (\n            int56 tickCumulativeInside,\n            uint160 secondsPerLiquidityInsideX128,\n            uint32 secondsInside\n        );\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissionless pool actions\n/// @notice Contains pool methods that can be called by anyone\ninterface IUniswapV3PoolActions {\n    /// @notice Sets the initial price for the pool\n    /// @dev Price is represented as a sqrt(amountToken1/amountToken0) Q64.96 value\n    /// @param sqrtPriceX96 the initial sqrt price of the pool as a Q64.96\n    function initialize(uint160 sqrtPriceX96) external;\n\n    /// @notice Adds liquidity for the given recipient/tickLower/tickUpper position\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3MintCallback#uniswapV3MintCallback\n    /// in which they must pay any token0 or token1 owed for the liquidity. The amount of token0/token1 due depends\n    /// on tickLower, tickUpper, the amount of liquidity, and the current price.\n    /// @param recipient The address for which the liquidity will be created\n    /// @param tickLower The lower tick of the position in which to add liquidity\n    /// @param tickUpper The upper tick of the position in which to add liquidity\n    /// @param amount The amount of liquidity to mint\n    /// @param data Any data that should be passed through to the callback\n    /// @return amount0 The amount of token0 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    /// @return amount1 The amount of token1 that was paid to mint the given amount of liquidity. Matches the value in the callback\n    function mint(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount,\n        bytes calldata data\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Collects tokens owed to a position\n    /// @dev Does not recompute fees earned, which must be done either via mint or burn of any amount of liquidity.\n    /// Collect must be called by the position owner. To withdraw only token0 or only token1, amount0Requested or\n    /// amount1Requested may be set to zero. To withdraw all tokens owed, caller may pass any value greater than the\n    /// actual tokens owed, e.g. type(uint128).max. Tokens owed may be from accumulated swap fees or burned liquidity.\n    /// @param recipient The address which should receive the fees collected\n    /// @param tickLower The lower tick of the position for which to collect fees\n    /// @param tickUpper The upper tick of the position for which to collect fees\n    /// @param amount0Requested How much token0 should be withdrawn from the fees owed\n    /// @param amount1Requested How much token1 should be withdrawn from the fees owed\n    /// @return amount0 The amount of fees collected in token0\n    /// @return amount1 The amount of fees collected in token1\n    function collect(\n        address recipient,\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n\n    /// @notice Burn liquidity from the sender and account tokens owed for the liquidity to the position\n    /// @dev Can be used to trigger a recalculation of fees owed to a position by calling with an amount of 0\n    /// @dev Fees must be collected separately via a call to #collect\n    /// @param tickLower The lower tick of the position for which to burn liquidity\n    /// @param tickUpper The upper tick of the position for which to burn liquidity\n    /// @param amount How much liquidity to burn\n    /// @return amount0 The amount of token0 sent to the recipient\n    /// @return amount1 The amount of token1 sent to the recipient\n    function burn(\n        int24 tickLower,\n        int24 tickUpper,\n        uint128 amount\n    ) external returns (uint256 amount0, uint256 amount1);\n\n    /// @notice Swap token0 for token1, or token1 for token0\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3SwapCallback#uniswapV3SwapCallback\n    /// @param recipient The address to receive the output of the swap\n    /// @param zeroForOne The direction of the swap, true for token0 to token1, false for token1 to token0\n    /// @param amountSpecified The amount of the swap, which implicitly configures the swap as exact input (positive), or exact output (negative)\n    /// @param sqrtPriceLimitX96 The Q64.96 sqrt price limit. If zero for one, the price cannot be less than this\n    /// value after the swap. If one for zero, the price cannot be greater than this value after the swap\n    /// @param data Any data to be passed through to the callback\n    /// @return amount0 The delta of the balance of token0 of the pool, exact when negative, minimum when positive\n    /// @return amount1 The delta of the balance of token1 of the pool, exact when negative, minimum when positive\n    function swap(\n        address recipient,\n        bool zeroForOne,\n        int256 amountSpecified,\n        uint160 sqrtPriceLimitX96,\n        bytes calldata data\n    ) external returns (int256 amount0, int256 amount1);\n\n    /// @notice Receive token0 and/or token1 and pay it back, plus a fee, in the callback\n    /// @dev The caller of this method receives a callback in the form of IUniswapV3FlashCallback#uniswapV3FlashCallback\n    /// @dev Can be used to donate underlying tokens pro-rata to currently in-range liquidity providers by calling\n    /// with 0 amount{0,1} and sending the donation amount(s) from the callback\n    /// @param recipient The address which will receive the token0 and token1 amounts\n    /// @param amount0 The amount of token0 to send\n    /// @param amount1 The amount of token1 to send\n    /// @param data Any data to be passed through to the callback\n    function flash(\n        address recipient,\n        uint256 amount0,\n        uint256 amount1,\n        bytes calldata data\n    ) external;\n\n    /// @notice Increase the maximum number of price and liquidity observations that this pool will store\n    /// @dev This method is no-op if the pool already has an observationCardinalityNext greater than or equal to\n    /// the input observationCardinalityNext.\n    /// @param observationCardinalityNext The desired minimum number of observations for the pool to store\n    function increaseObservationCardinalityNext(uint16 observationCardinalityNext) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolOwnerActions.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Permissioned pool actions\n/// @notice Contains pool methods that may only be called by the factory owner\ninterface IUniswapV3PoolOwnerActions {\n    /// @notice Set the denominator of the protocol's % share of the fees\n    /// @param feeProtocol0 new protocol fee for token0 of the pool\n    /// @param feeProtocol1 new protocol fee for token1 of the pool\n    function setFeeProtocol(uint8 feeProtocol0, uint8 feeProtocol1) external;\n\n    /// @notice Collect the protocol fee accrued to the pool\n    /// @param recipient The address to which collected protocol fees should be sent\n    /// @param amount0Requested The maximum amount of token0 to send, can be 0 to collect fees in only token1\n    /// @param amount1Requested The maximum amount of token1 to send, can be 0 to collect fees in only token0\n    /// @return amount0 The protocol fee collected in token0\n    /// @return amount1 The protocol fee collected in token1\n    function collectProtocol(\n        address recipient,\n        uint128 amount0Requested,\n        uint128 amount1Requested\n    ) external returns (uint128 amount0, uint128 amount1);\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/pool/IUniswapV3PoolEvents.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Events emitted by a pool\n/// @notice Contains all events emitted by the pool\ninterface IUniswapV3PoolEvents {\n    /// @notice Emitted exactly once by a pool when #initialize is first called on the pool\n    /// @dev Mint/Burn/Swap cannot be emitted by the pool before Initialize\n    /// @param sqrtPriceX96 The initial sqrt price of the pool, as a Q64.96\n    /// @param tick The initial tick of the pool, i.e. log base 1.0001 of the starting price of the pool\n    event Initialize(uint160 sqrtPriceX96, int24 tick);\n\n    /// @notice Emitted when liquidity is minted for a given position\n    /// @param sender The address that minted the liquidity\n    /// @param owner The owner of the position and recipient of any minted liquidity\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity minted to the position range\n    /// @param amount0 How much token0 was required for the minted liquidity\n    /// @param amount1 How much token1 was required for the minted liquidity\n    event Mint(\n        address sender,\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted when fees are collected by the owner of a position\n    /// @dev Collect events may be emitted with zero amount0 and amount1 when the caller chooses not to collect fees\n    /// @param owner The owner of the position for which fees are collected\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount0 The amount of token0 fees collected\n    /// @param amount1 The amount of token1 fees collected\n    event Collect(\n        address indexed owner,\n        address recipient,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount0,\n        uint128 amount1\n    );\n\n    /// @notice Emitted when a position's liquidity is removed\n    /// @dev Does not withdraw any fees earned by the liquidity position, which must be withdrawn via #collect\n    /// @param owner The owner of the position for which liquidity is removed\n    /// @param tickLower The lower tick of the position\n    /// @param tickUpper The upper tick of the position\n    /// @param amount The amount of liquidity to remove\n    /// @param amount0 The amount of token0 withdrawn\n    /// @param amount1 The amount of token1 withdrawn\n    event Burn(\n        address indexed owner,\n        int24 indexed tickLower,\n        int24 indexed tickUpper,\n        uint128 amount,\n        uint256 amount0,\n        uint256 amount1\n    );\n\n    /// @notice Emitted by the pool for any swaps between token0 and token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the output of the swap\n    /// @param amount0 The delta of the token0 balance of the pool\n    /// @param amount1 The delta of the token1 balance of the pool\n    /// @param sqrtPriceX96 The sqrt(price) of the pool after the swap, as a Q64.96\n    /// @param liquidity The liquidity of the pool after the swap\n    /// @param tick The log base 1.0001 of price of the pool after the swap\n    event Swap(\n        address indexed sender,\n        address indexed recipient,\n        int256 amount0,\n        int256 amount1,\n        uint160 sqrtPriceX96,\n        uint128 liquidity,\n        int24 tick\n    );\n\n    /// @notice Emitted by the pool for any flashes of token0/token1\n    /// @param sender The address that initiated the swap call, and that received the callback\n    /// @param recipient The address that received the tokens from flash\n    /// @param amount0 The amount of token0 that was flashed\n    /// @param amount1 The amount of token1 that was flashed\n    /// @param paid0 The amount of token0 paid for the flash, which can exceed the amount0 plus the fee\n    /// @param paid1 The amount of token1 paid for the flash, which can exceed the amount1 plus the fee\n    event Flash(\n        address indexed sender,\n        address indexed recipient,\n        uint256 amount0,\n        uint256 amount1,\n        uint256 paid0,\n        uint256 paid1\n    );\n\n    /// @notice Emitted by the pool for increases to the number of observations that can be stored\n    /// @dev observationCardinalityNext is not the observation cardinality until an observation is written at the index\n    /// just before a mint/swap/burn.\n    /// @param observationCardinalityNextOld The previous value of the next observation cardinality\n    /// @param observationCardinalityNextNew The updated value of the next observation cardinality\n    event IncreaseObservationCardinalityNext(\n        uint16 observationCardinalityNextOld,\n        uint16 observationCardinalityNextNew\n    );\n\n    /// @notice Emitted when the protocol fee is changed by the pool\n    /// @param feeProtocol0Old The previous value of the token0 protocol fee\n    /// @param feeProtocol1Old The previous value of the token1 protocol fee\n    /// @param feeProtocol0New The updated value of the token0 protocol fee\n    /// @param feeProtocol1New The updated value of the token1 protocol fee\n    event SetFeeProtocol(uint8 feeProtocol0Old, uint8 feeProtocol1Old, uint8 feeProtocol0New, uint8 feeProtocol1New);\n\n    /// @notice Emitted when the collected protocol fees are withdrawn by the factory owner\n    /// @param sender The address that collects the protocol fees\n    /// @param recipient The address that receives the collected protocol fees\n    /// @param amount0 The amount of token0 protocol fees that is withdrawn\n    /// @param amount0 The amount of token1 protocol fees that is withdrawn\n    event CollectProtocol(address indexed sender, address indexed recipient, uint128 amount0, uint128 amount1);\n}\n"
    },
    "contracts/test/UniV3/interfaces/external/IERC20PermitAllowed.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Interface for permit\n/// @notice Interface used by DAI/CHAI for permit\ninterface IERC20PermitAllowed {\n    /// @notice Approve the spender to spend some tokens via the holder signature\n    /// @dev This is the permit interface used by DAI and CHAI\n    /// @param holder The address of the token holder, the token owner\n    /// @param spender The address of the token spender\n    /// @param nonce The holder's nonce, increases at each call to permit\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param allowed Boolean that sets approval amount, true for type(uint256).max and false for 0\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function permit(\n        address holder,\n        address spender,\n        uint256 nonce,\n        uint256 expiry,\n        bool allowed,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/test/UniV3/interfaces/ISelfPermit.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Self Permit\n/// @notice Functionality to call permit on any EIP-2612-compliant token for use in the route\ninterface ISelfPermit {\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermit(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend a given token from `msg.sender`\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this).\n    /// Can be used instead of #selfPermit to prevent calls from failing due to a frontrun of a call to #selfPermit\n    /// @param token The address of the token spent\n    /// @param value The amount that can be spent of token\n    /// @param deadline A timestamp, the current blocktime must be less than or equal to this timestamp\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitIfNecessary(\n        address token,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowed(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n\n    /// @notice Permits this contract to spend the sender's tokens for permit signatures that have the `allowed` parameter\n    /// @dev The `owner` is always msg.sender and the `spender` is always address(this)\n    /// Can be used instead of #selfPermitAllowed to prevent calls from failing due to a frontrun of a call to #selfPermitAllowed.\n    /// @param token The address of the token spent\n    /// @param nonce The current nonce of the owner\n    /// @param expiry The timestamp at which the permit is no longer valid\n    /// @param v Must produce valid secp256k1 signature from the holder along with `r` and `s`\n    /// @param r Must produce valid secp256k1 signature from the holder along with `v` and `s`\n    /// @param s Must produce valid secp256k1 signature from the holder along with `r` and `v`\n    function selfPermitAllowedIfNecessary(\n        address token,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external payable;\n}\n"
    },
    "contracts/test/UniV3/interfaces/IV3Migrator.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport './IMulticall.sol';\nimport './ISelfPermit.sol';\nimport './IPoolInitializer.sol';\n\n/// @title V3 Migrator\n/// @notice Enables migration of liqudity from Uniswap v2-compatible pairs into Uniswap v3 pools\ninterface IV3Migrator is IMulticall, ISelfPermit, IPoolInitializer {\n    struct MigrateParams {\n        address pair; // the Uniswap v2-compatible pair\n        uint256 liquidityToMigrate; // expected to be balanceOf(msg.sender)\n        uint8 percentageToMigrate; // represented as a numerator over 100\n        address token0;\n        address token1;\n        uint24 fee;\n        int24 tickLower;\n        int24 tickUpper;\n        uint256 amount0Min; // must be discounted by percentageToMigrate\n        uint256 amount1Min; // must be discounted by percentageToMigrate\n        address recipient;\n        uint256 deadline;\n        bool refundAsETH;\n    }\n\n    /// @notice Migrates liquidity to v3 by burning v2 liquidity and minting a new position for v3\n    /// @dev Slippage protection is enforced via `amount{0,1}Min`, which should be a discount of the expected values of\n    /// the maximum amount of v3 liquidity that the v2 liquidity can get. For the special case of migrating to an\n    /// out-of-range position, `amount{0,1}Min` may be set to 0, enforcing that the position remains out of range\n    /// @param params The params necessary to migrate v2 liquidity, encoded as `MigrateParams` in calldata\n    function migrate(MigrateParams calldata params) external;\n}\n"
    },
    "contracts/test/UniV3/interfaces/IMulticall.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Multicall interface\n/// @notice Enables calling multiple methods in a single call to the contract\ninterface IMulticall {\n    /// @notice Call multiple functions in the current contract and return the data from all of them if they all succeed\n    /// @dev The `msg.value` should not be trusted for any method callable from multicall.\n    /// @param data The encoded function data for each of the calls to make to this contract\n    /// @return results The results from each of the calls passed in via data\n    function multicall(bytes[] calldata data) external payable returns (bytes[] memory results);\n}\n"
    },
    "contracts/test/UniV3/interfaces/IPoolInitializer.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Creates and initializes V3 Pools\n/// @notice Provides a method for creating and initializing a pool, if necessary, for bundling with other methods that\n/// require the pool to exist.\ninterface IPoolInitializer {\n    /// @notice Creates a new pool if it does not exist, then initializes if not initialized\n    /// @dev This method can be bundled with others via IMulticall for the first action (e.g. mint) performed against a pool\n    /// @param token0 The contract address of token0 of the pool\n    /// @param token1 The contract address of token1 of the pool\n    /// @param fee The fee amount of the v3 pool for the specified token pair\n    /// @param sqrtPriceX96 The initial square root price of the pool as a Q64.96 value\n    /// @return pool Returns the pool address based on the pair of tokens and fee, will return the newly created pool address if necessary\n    function createAndInitializePoolIfNecessary(\n        address token0,\n        address token1,\n        uint24 fee,\n        uint160 sqrtPriceX96\n    ) external payable returns (address pool);\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/BitMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title BitMath\n/// @dev This library provides functionality for computing bit properties of an unsigned integer\nlibrary BitMath {\n    /// @notice Returns the index of the most significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     x >= 2**mostSignificantBit(x) and x < 2**(mostSignificantBit(x)+1)\n    /// @param x the value for which to compute the most significant bit, must be greater than 0\n    /// @return r the index of the most significant bit\n    function mostSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        if (x >= 0x100000000000000000000000000000000) {\n            x >>= 128;\n            r += 128;\n        }\n        if (x >= 0x10000000000000000) {\n            x >>= 64;\n            r += 64;\n        }\n        if (x >= 0x100000000) {\n            x >>= 32;\n            r += 32;\n        }\n        if (x >= 0x10000) {\n            x >>= 16;\n            r += 16;\n        }\n        if (x >= 0x100) {\n            x >>= 8;\n            r += 8;\n        }\n        if (x >= 0x10) {\n            x >>= 4;\n            r += 4;\n        }\n        if (x >= 0x4) {\n            x >>= 2;\n            r += 2;\n        }\n        if (x >= 0x2) r += 1;\n    }\n\n    /// @notice Returns the index of the least significant bit of the number,\n    ///     where the least significant bit is at index 0 and the most significant bit is at index 255\n    /// @dev The function satisfies the property:\n    ///     (x & 2**leastSignificantBit(x)) != 0 and (x & (2**(leastSignificantBit(x)) - 1)) == 0)\n    /// @param x the value for which to compute the least significant bit, must be greater than 0\n    /// @return r the index of the least significant bit\n    function leastSignificantBit(uint256 x) internal pure returns (uint8 r) {\n        require(x > 0);\n\n        r = 255;\n        if (x & type(uint128).max > 0) {\n            r -= 128;\n        } else {\n            x >>= 128;\n        }\n        if (x & type(uint64).max > 0) {\n            r -= 64;\n        } else {\n            x >>= 64;\n        }\n        if (x & type(uint32).max > 0) {\n            r -= 32;\n        } else {\n            x >>= 32;\n        }\n        if (x & type(uint16).max > 0) {\n            r -= 16;\n        } else {\n            x >>= 16;\n        }\n        if (x & type(uint8).max > 0) {\n            r -= 8;\n        } else {\n            x >>= 8;\n        }\n        if (x & 0xf > 0) {\n            r -= 4;\n        } else {\n            x >>= 4;\n        }\n        if (x & 0x3 > 0) {\n            r -= 2;\n        } else {\n            x >>= 2;\n        }\n        if (x & 0x1 > 0) r -= 1;\n    }\n}\n"
    },
    "contracts/test/UniV3/interfaces/external/IERC1271.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Interface for verifying contract-based account signatures\n/// @notice Interface that verifies provided signature for the data\n/// @dev Interface defined by EIP-1271\ninterface IERC1271 {\n    /// @notice Returns whether the provided signature is valid for the provided data\n    /// @dev MUST return the bytes4 magic value 0x1626ba7e when function passes.\n    /// MUST NOT modify state (using STATICCALL for solc < 0.5, view modifier for solc > 0.5).\n    /// MUST allow external calls.\n    /// @param hash Hash of the data to be signed\n    /// @param signature Signature byte array associated with _data\n    /// @return magicValue The bytes4 magic value 0x1626ba7e\n    function isValidSignature(bytes32 hash, bytes memory signature) external view returns (bytes4 magicValue);\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FixedPoint96.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint96\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\n/// @dev Used in SqrtPriceMath.sol\nlibrary FixedPoint96 {\n    uint8 internal constant RESOLUTION = 96;\n    uint256 internal constant Q96 = 0x1000000000000000000000000;\n}\n"
    },
    "contracts/test/UniV3/libraries/PositionKey.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\nlibrary PositionKey {\n    /// @dev Returns the key of the position in the core library\n    function compute(\n        address owner,\n        int24 tickLower,\n        int24 tickUpper\n    ) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(owner, tickLower, tickUpper));\n    }\n}\n"
    },
    "contracts/test/UniV3/interfaces/IPeripheryImmutableState.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Immutable state\n/// @notice Functions that return immutable state of the router\ninterface IPeripheryImmutableState {\n    /// @return Returns the address of the Uniswap V3 factory\n    function factory() external view returns (address);\n\n    /// @return Returns the address of WETH9\n    function WETH9() external view returns (address);\n}\n"
    },
    "contracts/test/UniV3/interfaces/IPeripheryPaymentsWithFee.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\nimport './IPeripheryPayments.sol';\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPaymentsWithFee is IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH, with a percentage between\n    /// 0 (exclusive), and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    function unwrapWETH9WithFee(\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    ) external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient, with a percentage between\n    /// 0 (exclusive) and 1 (inclusive) going to feeRecipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    function sweepTokenWithFee(\n        address token,\n        uint256 amountMinimum,\n        address recipient,\n        uint256 feeBips,\n        address feeRecipient\n    ) external payable;\n}\n"
    },
    "contracts/test/UniV3/interfaces/IPeripheryPayments.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\n\n/// @title Periphery Payments\n/// @notice Functions to ease deposits and withdrawals of ETH\ninterface IPeripheryPayments {\n    /// @notice Unwraps the contract's WETH9 balance and sends it to recipient as ETH.\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing WETH9 from users.\n    /// @param amountMinimum The minimum amount of WETH9 to unwrap\n    /// @param recipient The address receiving ETH\n    function unwrapWETH9(uint256 amountMinimum, address recipient) external payable;\n\n    /// @notice Refunds any ETH balance held by this contract to the `msg.sender`\n    /// @dev Useful for bundling with mint or increase liquidity that uses ether, or exact output swaps\n    /// that use ether for the input amount\n    function refundETH() external payable;\n\n    /// @notice Transfers the full amount of a token held by this contract to recipient\n    /// @dev The amountMinimum parameter prevents malicious contracts from stealing the token from users\n    /// @param token The contract address of the token which will be transferred to `recipient`\n    /// @param amountMinimum The minimum amount of token required for a transfer\n    /// @param recipient The destination address of the token\n    function sweepToken(\n        address token,\n        uint256 amountMinimum,\n        address recipient\n    ) external payable;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LowGasSafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.0;\n\n/// @title Optimized overflow and underflow safe math operations\n/// @notice Contains methods for doing math operations that revert on overflow or underflow for minimal gas cost\nlibrary LowGasSafeMath {\n    /// @notice Returns x + y, reverts if sum overflows uint256\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x + y) >= x);\n    }\n\n    /// @notice Returns x - y, reverts if underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require((z = x - y) <= x);\n    }\n\n    /// @notice Returns x * y, reverts if overflows\n    /// @param x The multiplicand\n    /// @param y The multiplier\n    /// @return z The product of x and y\n    function mul(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        require(x == 0 || (z = x * y) / x == y);\n    }\n\n    /// @notice Returns x + y, reverts if overflows or underflows\n    /// @param x The augend\n    /// @param y The addend\n    /// @return z The sum of x and y\n    function add(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x + y) >= x == (y >= 0));\n    }\n\n    /// @notice Returns x - y, reverts if overflows or underflows\n    /// @param x The minuend\n    /// @param y The subtrahend\n    /// @return z The difference of x and y\n    function sub(int256 x, int256 y) internal pure returns (int256 z) {\n        require((z = x - y) <= x == (y >= 0));\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/LiquidityMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math library for liquidity\nlibrary LiquidityMath {\n    /// @notice Add a signed liquidity delta to liquidity and revert if it overflows or underflows\n    /// @param x The liquidity before change\n    /// @param y The delta by which liquidity should be changed\n    /// @return z The liquidity delta\n    function addDelta(uint128 x, int128 y) internal pure returns (uint128 z) {\n        if (y < 0) {\n            require((z = x - uint128(-y)) < x, 'LS');\n        } else {\n            require((z = x + uint128(y)) >= x, 'LA');\n        }\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/SafeCast.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Safe casting methods\n/// @notice Contains methods for safely casting between types\nlibrary SafeCast {\n    /// @notice Cast a uint256 to a uint160, revert on overflow\n    /// @param y The uint256 to be downcasted\n    /// @return z The downcasted integer, now type uint160\n    function toUint160(uint256 y) internal pure returns (uint160 z) {\n        require((z = uint160(y)) == y);\n    }\n\n    /// @notice Cast a int256 to a int128, revert on overflow or underflow\n    /// @param y The int256 to be downcasted\n    /// @return z The downcasted integer, now type int128\n    function toInt128(int256 y) internal pure returns (int128 z) {\n        require((z = int128(y)) == y);\n    }\n\n    /// @notice Cast a uint256 to a int256, revert on overflow\n    /// @param y The uint256 to be casted\n    /// @return z The casted integer, now type int256\n    function toInt256(uint256 y) internal pure returns (int256 z) {\n        require(y < 2**255);\n        z = int256(y);\n    }\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3MintCallback.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Callback for IUniswapV3PoolActions#mint\n/// @notice Any contract that calls IUniswapV3PoolActions#mint must implement this interface\ninterface IUniswapV3MintCallback {\n    /// @notice Called to `msg.sender` after minting liquidity to a position from IUniswapV3Pool#mint.\n    /// @dev In the implementation you must pay the pool tokens owed for the minted liquidity.\n    /// The caller of this method must be checked to be a UniswapV3Pool deployed by the canonical UniswapV3Factory.\n    /// @param amount0Owed The amount of token0 due to the pool for the minted liquidity\n    /// @param amount1Owed The amount of token1 due to the pool for the minted liquidity\n    /// @param data Any data passed through by the caller via the IUniswapV3PoolActions#mint call\n    function uniswapV3MintCallback(\n        uint256 amount0Owed,\n        uint256 amount1Owed,\n        bytes calldata data\n    ) external;\n}\n"
    },
    "@uniswap/v3-core/contracts/interfaces/IUniswapV3Factory.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title The interface for the Uniswap V3 Factory\n/// @notice The Uniswap V3 Factory facilitates creation of Uniswap V3 pools and control over the protocol fees\ninterface IUniswapV3Factory {\n    /// @notice Emitted when the owner of the factory is changed\n    /// @param oldOwner The owner before the owner was changed\n    /// @param newOwner The owner after the owner was changed\n    event OwnerChanged(address indexed oldOwner, address indexed newOwner);\n\n    /// @notice Emitted when a pool is created\n    /// @param token0 The first token of the pool by address sort order\n    /// @param token1 The second token of the pool by address sort order\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks\n    /// @param pool The address of the created pool\n    event PoolCreated(\n        address indexed token0,\n        address indexed token1,\n        uint24 indexed fee,\n        int24 tickSpacing,\n        address pool\n    );\n\n    /// @notice Emitted when a new fee amount is enabled for pool creation via the factory\n    /// @param fee The enabled fee, denominated in hundredths of a bip\n    /// @param tickSpacing The minimum number of ticks between initialized ticks for pools created with the given fee\n    event FeeAmountEnabled(uint24 indexed fee, int24 indexed tickSpacing);\n\n    /// @notice Returns the current owner of the factory\n    /// @dev Can be changed by the current owner via setOwner\n    /// @return The address of the factory owner\n    function owner() external view returns (address);\n\n    /// @notice Returns the tick spacing for a given fee amount, if enabled, or 0 if not enabled\n    /// @dev A fee amount can never be removed, so this value should be hard coded or cached in the calling context\n    /// @param fee The enabled fee, denominated in hundredths of a bip. Returns 0 in case of unenabled fee\n    /// @return The tick spacing\n    function feeAmountTickSpacing(uint24 fee) external view returns (int24);\n\n    /// @notice Returns the pool address for a given pair of tokens and a fee, or address 0 if it does not exist\n    /// @dev tokenA and tokenB may be passed in either token0/token1 or token1/token0 order\n    /// @param tokenA The contract address of either token0 or token1\n    /// @param tokenB The contract address of the other token\n    /// @param fee The fee collected upon every swap in the pool, denominated in hundredths of a bip\n    /// @return pool The pool address\n    function getPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external view returns (address pool);\n\n    /// @notice Creates a pool for the given two tokens and fee\n    /// @param tokenA One of the two tokens in the desired pool\n    /// @param tokenB The other of the two tokens in the desired pool\n    /// @param fee The desired fee for the pool\n    /// @dev tokenA and tokenB may be passed in either order: token0/token1 or token1/token0. tickSpacing is retrieved\n    /// from the fee. The call will revert if the pool already exists, the fee is invalid, or the token arguments\n    /// are invalid.\n    /// @return pool The address of the newly created pool\n    function createPool(\n        address tokenA,\n        address tokenB,\n        uint24 fee\n    ) external returns (address pool);\n\n    /// @notice Updates the owner of the factory\n    /// @dev Must be called by the current owner\n    /// @param _owner The new owner of the factory\n    function setOwner(address _owner) external;\n\n    /// @notice Enables a fee amount with the given tickSpacing\n    /// @dev Fee amounts may never be removed once enabled\n    /// @param fee The fee amount to enable, denominated in hundredths of a bip (i.e. 1e-6)\n    /// @param tickSpacing The spacing between ticks to be enforced for all pools created with the given fee amount\n    function enableFeeAmount(uint24 fee, int24 tickSpacing) external;\n}\n"
    },
    "contracts/test/UniV3/interfaces/IQuoter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Quoter Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoter {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    function quoteExactInput(bytes memory path, uint256 amountIn) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountIn The desired input amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    function quoteExactInputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountIn,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountOut);\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    function quoteExactOutput(bytes memory path, uint256 amountOut) external returns (uint256 amountIn);\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param tokenIn The token being swapped in\n    /// @param tokenOut The token being swapped out\n    /// @param fee The fee of the token pool to consider for the pair\n    /// @param amountOut The desired output amount\n    /// @param sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    function quoteExactOutputSingle(\n        address tokenIn,\n        address tokenOut,\n        uint24 fee,\n        uint256 amountOut,\n        uint160 sqrtPriceLimitX96\n    ) external returns (uint256 amountIn);\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/FixedPoint128.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.4.0;\n\n/// @title FixedPoint128\n/// @notice A library for handling binary fixed point numbers, see https://en.wikipedia.org/wiki/Q_(number_format)\nlibrary FixedPoint128 {\n    uint256 internal constant Q128 = 0x100000000000000000000000000000000;\n}\n"
    },
    "@uniswap/v3-core/contracts/libraries/UnsafeMath.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.5.0;\n\n/// @title Math functions that do not check inputs or outputs\n/// @notice Contains methods that perform common math functions but do not do any overflow or underflow checks\nlibrary UnsafeMath {\n    /// @notice Returns ceil(x / y)\n    /// @dev division by 0 has unspecified behavior, and must be checked externally\n    /// @param x The dividend\n    /// @param y The divisor\n    /// @return z The quotient, ceil(x / y)\n    function divRoundingUp(uint256 x, uint256 y) internal pure returns (uint256 z) {\n        assembly {\n            z := add(div(x, y), gt(mod(x, y), 0))\n        }\n    }\n}\n"
    },
    "contracts/test/UniV3/interfaces/ISwapRouter.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\nimport '@uniswap/v3-core/contracts/interfaces/callback/IUniswapV3SwapCallback.sol';\n\n/// @title Router token swapping functionality\n/// @notice Functions for swapping tokens via Uniswap V3\ninterface ISwapRouter is IUniswapV3SwapCallback {\n    struct ExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactInputSingleParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInputSingle(ExactInputSingleParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactInputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountIn;\n        uint256 amountOutMinimum;\n    }\n\n    /// @notice Swaps `amountIn` of one token for as much as possible of another along the specified path\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactInputParams` in calldata\n    /// @return amountOut The amount of the received token\n    function exactInput(ExactInputParams calldata params) external payable returns (uint256 amountOut);\n\n    struct ExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint24 fee;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another token\n    /// @param params The parameters necessary for the swap, encoded as `ExactOutputSingleParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutputSingle(ExactOutputSingleParams calldata params) external payable returns (uint256 amountIn);\n\n    struct ExactOutputParams {\n        bytes path;\n        address recipient;\n        uint256 deadline;\n        uint256 amountOut;\n        uint256 amountInMaximum;\n    }\n\n    /// @notice Swaps as little as possible of one token for `amountOut` of another along the specified path (reversed)\n    /// @param params The parameters necessary for the multi-hop swap, encoded as `ExactOutputParams` in calldata\n    /// @return amountIn The amount of the input token\n    function exactOutput(ExactOutputParams calldata params) external payable returns (uint256 amountIn);\n}\n"
    },
    "contracts/test/UniV3/interfaces/ITickLens.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title Tick Lens\n/// @notice Provides functions for fetching chunks of tick data for a pool\n/// @dev This avoids the waterfall of fetching the tick bitmap, parsing the bitmap to know which ticks to fetch, and\n/// then sending additional multicalls to fetch the tick data\ninterface ITickLens {\n    struct PopulatedTick {\n        int24 tick;\n        int128 liquidityNet;\n        uint128 liquidityGross;\n    }\n\n    /// @notice Get all the tick data for the populated ticks from a word of the tick bitmap of a pool\n    /// @param pool The address of the pool for which to fetch populated tick data\n    /// @param tickBitmapIndex The index of the word in the tick bitmap for which to parse the bitmap and\n    /// fetch all the populated ticks\n    /// @return populatedTicks An array of tick data for the given word in the tick bitmap\n    function getPopulatedTicksInWord(address pool, int16 tickBitmapIndex)\n        external\n        view\n        returns (PopulatedTick[] memory populatedTicks);\n}\n"
    },
    "contracts/test/UniV3/interfaces/IQuoterV2.sol": {
      "content": "// SPDX-License-Identifier: GPL-2.0-or-later\npragma solidity >=0.7.5;\npragma abicoder v2;\n\n/// @title QuoterV2 Interface\n/// @notice Supports quoting the calculated amounts from exact input or exact output swaps.\n/// @notice For each pool also tells you the number of initialized ticks crossed and the sqrt price of the pool after the swap.\n/// @dev These functions are not marked view because they rely on calling non-view functions and reverting\n/// to compute the result. They are also not gas efficient and should not be called on-chain.\ninterface IQuoterV2 {\n    /// @notice Returns the amount out received for a given exact input swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee\n    /// @param amountIn The amount of the first token to swap\n    /// @return amountOut The amount of the last token that would be received\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInput(bytes memory path, uint256 amountIn)\n        external\n        returns (\n            uint256 amountOut,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactInputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amountIn;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount out received for a given exact input but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactInputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// fee The fee of the token pool to consider for the pair\n    /// amountIn The desired input amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountOut The amount of `tokenOut` that would be received\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactInputSingle(QuoteExactInputSingleParams memory params)\n        external\n        returns (\n            uint256 amountOut,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n\n    /// @notice Returns the amount in required for a given exact output swap without executing the swap\n    /// @param path The path of the swap, i.e. each token pair and the pool fee. Path must be provided in reverse order\n    /// @param amountOut The amount of the last token to receive\n    /// @return amountIn The amount of first token required to be paid\n    /// @return sqrtPriceX96AfterList List of the sqrt price after the swap for each pool in the path\n    /// @return initializedTicksCrossedList List of the initialized ticks that the swap crossed for each pool in the path\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutput(bytes memory path, uint256 amountOut)\n        external\n        returns (\n            uint256 amountIn,\n            uint160[] memory sqrtPriceX96AfterList,\n            uint32[] memory initializedTicksCrossedList,\n            uint256 gasEstimate\n        );\n\n    struct QuoteExactOutputSingleParams {\n        address tokenIn;\n        address tokenOut;\n        uint256 amount;\n        uint24 fee;\n        uint160 sqrtPriceLimitX96;\n    }\n\n    /// @notice Returns the amount in required to receive the given exact output amount but for a swap of a single pool\n    /// @param params The params for the quote, encoded as `QuoteExactOutputSingleParams`\n    /// tokenIn The token being swapped in\n    /// tokenOut The token being swapped out\n    /// fee The fee of the token pool to consider for the pair\n    /// amountOut The desired output amount\n    /// sqrtPriceLimitX96 The price limit of the pool that cannot be exceeded by the swap\n    /// @return amountIn The amount required as the input for the swap in order to receive `amountOut`\n    /// @return sqrtPriceX96After The sqrt price of the pool after the swap\n    /// @return initializedTicksCrossed The number of initialized ticks that the swap crossed\n    /// @return gasEstimate The estimate of the gas that the swap consumes\n    function quoteExactOutputSingle(QuoteExactOutputSingleParams memory params)\n        external\n        returns (\n            uint256 amountIn,\n            uint160 sqrtPriceX96After,\n            uint32 initializedTicksCrossed,\n            uint256 gasEstimate\n        );\n}\n"
    },
    "contracts/ArkreenMiner.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/token/ERC721/extensions/ERC721EnumerableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\n\nimport \"./libraries/TransferHelper.sol\";\nimport \"./interfaces/IERC20.sol\";\nimport \"./interfaces/IERC20Permit.sol\";\nimport \"./ArkreenMinerTypes.sol\";\n\ncontract ArkreenMiner is \n    OwnableUpgradeable,\n    UUPSUpgradeable,\n    ERC721EnumerableUpgradeable\n{\n    using AddressUpgradeable for address;\n\n    // Constants\n    string public constant NAME = 'Arkreen Miner';\n    string public constant SYMBOL = 'AKREM';\n\n    // keccak256(\"RemoteMinerOnboard(address owner,address miners,address token,uint256 price,uint256 deadline)\");\n    bytes32 public constant REMOTE_MINER_TYPEHASH = 0xE397EAA556C649D10F65393AC1D09D5AA50D72547C850822C207516865E89E32;  \n\n    // keccak256(\"RemoteMinerOnboardBatch(address owner,uint256 quantity,address token,uint256 value,uint256 deadline)\");\n    bytes32 public constant REMOTE_MINER_BATCH_TYPEHASH = 0x9E7E2F63BB8D2E99F3FA05B76080E528E9CA50746A4383CDF2803D633AFF18A6;  \n\n    // keccak256(\"StandardMinerOnboard(address owner,address miner,uint256 deadline)\");\n    bytes32 public constant STANDARD_MINER_TYPEHASH = 0x73F94559854A7E6267266A158D1576CBCAFFD8AE930E61FB632F9EC576D2BB37;  \n\n    uint256 public constant MAX_BATCH_SALE = 50;\n\n    // Public variables\n    bytes32 public DOMAIN_SEPARATOR;\n    uint256 public totalStandardMiner;                  // Total amount of standard miner\n    string public baseURI;\n    address public tokenAKRE;                           // Token adddress of AKRE\n    address public tokenNative;                         // The wrapped token of the Native token, such as WETH, WMATIC\n\n    // All registered miner manufactures\n    mapping(address => bool) public AllManufactures;\n\n    // All miner infos\n    mapping(uint256 => Miner) public AllMinerInfo;\n\n    // All managers with various privilege\n    mapping(uint256 => address) public AllManagers;\n\n    // Mapping from miner address to the respective token ID\n    mapping(address => uint256) public AllMinersToken;\n\n    // Miner white list mapping from miner address to miner type\n    mapping(address => uint8) public whiteListMiner;\n\n    uint256 public totalSocketMiner;                  // Total amount of socket miner\n\n    // Miner white list for sales in batch, mapping from index to miner address\n    mapping(uint256 => address) private whiteListMinerBatch;\n    uint256 private whiteListBatchIndexHead;\n    uint256 private whiteListBatchIndexTail;\n\n    // Events\n    event MinerOnboarded(address indexed owner, address indexed miner);\n    event MinerOnboardedBatch(address indexed owner, address[] minersBatch);\n    event StandardMinerOnboarded(address indexed owner, address indexed miner);\n    event RemoteMinersInBatch(address[] owners, address[] miners);\n    event SocketMinerOnboarded(address indexed owner, address indexed miner);\n    \n    modifier ensure(uint256 deadline) {\n        require(block.timestamp <= deadline, 'Arkreen Miner: EXPIRED');\n        _;\n    }\n\n    modifier onlyMinerManager() {\n        require(_msgSender() == AllManagers[uint256(MinerManagerType.Miner_Manager)], 'Arkreen Miner: Not Miner Manager');\n        _;\n    }    \n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address _tokenAKRE, address _tokenNative, address _minerManager, address _minerAuthority)\n        external\n        virtual\n        initializer\n    {\n        __Ownable_init_unchained();\n        __UUPSUpgradeable_init();\n        __ERC721_init_unchained(NAME, SYMBOL);\n        tokenAKRE = _tokenAKRE;\n        tokenNative = _tokenNative;\n        AllManagers[uint256(MinerManagerType.Miner_Manager)] = _minerManager;\n        AllManagers[uint256(MinerManagerType.Register_Authority)] = _minerAuthority;\n        baseURI = 'https://www.arkreen.com/miners/';\n\n        DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(\"Arkreen Miner\")),\n                keccak256(bytes('1')),\n                block.chainid,\n                address(this)\n            )\n        );  \n    }\n\n    function postUpdate() external onlyProxy onlyOwner \n    {}\n\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        virtual\n        override\n        onlyOwner\n    {}\n\n    /**\n     * @dev Onboarding a remote Miner paid with Native token (MATIC)\n     * @param owner address receiving the remote miner\n     * @param miner address of the remote miner onboarding\n     * @param permitMiner signature of the miner register authority to confirm the miner address and price.  \n     */\n    function RemoteMinerOnboardNative(\n        address     owner,\n        address     miner,\n        Signature   memory  permitMiner\n    ) external payable ensure(permitMiner.deadline) {\n\n        // Check payment value\n        require( (tokenNative != address(0)) && (tokenNative == permitMiner.token) && \n                  (msg.value == permitMiner.value), \"Arkreen Miner: Payment error\");\n\n        // Check for minting remote miner  \n        _mintRemoteMinerCheck(owner, miner, permitMiner);\n\n        // mint new remote miner\n        _mintRemoteMiner(owner, miner);\n        emit MinerOnboarded(owner, miner);\n    }    \n\n    /**\n     * @dev Onboarding remote miners in batch, orderly fetched from the batch whitelist, paid with Native token (MATIC)\n     * @param owner address receiving the remote miners\n     * @param numMiners number of remote miners desired to purchase\n     * @param permitMiner signature of the miner register authority to confirm the owner and sales price.  \n     */\n\n    function RemoteMinerOnboardNativeBatch(\n        address     owner,\n        uint8       numMiners,\n        Signature   memory  permitMiner\n    ) external payable ensure(permitMiner.deadline) {\n\n        require((numMiners != 0) && (numMiners <= numberOfWhiteListBatch()), \"Arkreen Miner: Wrong Miner Number\");\n\n        // Check payment value\n        require( (tokenNative != address(0)) && (tokenNative == permitMiner.token) && \n                  (msg.value == permitMiner.value), \"Arkreen Miner: Payment error\");\n\n        // Check for remote miner minting price  \n        _mintBatchCheckPrice(owner, numMiners, permitMiner);\n\n        // mint new remote miners in batch\n        address[] memory minersBatch = _mintRemoteMinerBatch(owner, numMiners);\n        emit MinerOnboardedBatch(owner, minersBatch);\n    }    \n\n    /**\n     * @dev Onboarding a remote miner while the payment has been approved\n     * @param owner address receiving the remote miner\n     * @param miner address of the remote miner onboarding\n     * @param permitMiner signature of miner register authority to confirm the miner address and price.  \n     */\n    function RemoteMinerOnboardApproved(\n        address     owner,\n        address     miner,\n        Signature   memory  permitMiner\n    ) external ensure(permitMiner.deadline) {\n\n        // Check for minting remote miner  \n        _mintRemoteMinerCheck(owner, miner, permitMiner);\n\n        // mint new remote miner\n        _mintRemoteMiner(owner, miner);\n\n        // Transfer onboarding fee\n        address sender = _msgSender();\n        TransferHelper.safeTransferFrom(permitMiner.token, sender, address(this), permitMiner.value);\n\n        emit MinerOnboarded(owner, miner);\n    }\n\n    /**\n     * @dev Onboarding a remote miner while the payment has been approved\n     * @param owner address receiving the remote miner\n     * @param numMiners number of remote miners desired to purchase\n     * @param permitMiner signature of miner register authority to confirm the miner address and price.  \n     */\n    function RemoteMinerOnboardApprovedBatch(\n        address     owner,\n        uint8       numMiners,\n        Signature   memory  permitMiner\n    ) external ensure(permitMiner.deadline) {\n\n        // Check for minting remote miner  \n        _mintBatchCheckPrice(owner, numMiners, permitMiner);\n\n        // mint new remote miner\n        address[] memory minersBatch = _mintRemoteMinerBatch(owner, numMiners);\n\n        // Transfer onboarding fee\n        address sender = _msgSender();\n        TransferHelper.safeTransferFrom(permitMiner.token, sender, address(this), permitMiner.value);\n\n        emit MinerOnboardedBatch(owner, minersBatch);\n    }\n\n    /**\n     * @dev Check for minting a remote Miner\n     * @param owner address receiving the remote miner\n     * @param miner address of the remote miner onboarding\n     * @param permitMiner signature of miner register authority to confirm the miner address and price.  \n     */\n    function _mintRemoteMinerCheck( \n        address     owner,\n        address     miner,\n        Signature   memory  permitMiner\n    ) view internal {\n\n        // Check miner is white listed  \n        require(whiteListMiner[miner] == uint8(MinerType.RemoteMiner), 'Arkreen Miner: Wrong Miner');\n        require(AllMinersToken[miner] == 0, \"Arkreen Miner: Miner Repeated\");\n\n        // Check signature\n        // keccak256(\"RemoteMinerOnboard(address owner,address miners,address token,uint256 price,uint256 deadline)\");\n        bytes32 hashRegister = keccak256(abi.encode(REMOTE_MINER_TYPEHASH, owner, miner, \n                                          permitMiner.token, permitMiner.value, permitMiner.deadline));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, hashRegister));\n        address recoveredAddress = ecrecover(digest, permitMiner.v, permitMiner.r, permitMiner.s);\n  \n        require(recoveredAddress != address(0) && \n                recoveredAddress == AllManagers[uint256(MinerManagerType.Register_Authority)], 'Arkreen Miner: INVALID_SIGNATURE');\n    }\n\n    /**\n     * @dev Check the remote miner minting authorization, including owner, quantity and sale value\n     * @param owner address receiving the remote miners in batch\n     * @param quantity quantity of remote miner for batch sale\n     * @param permitMiner signature of miner register authority to confirm the owner address and value.  \n     */\n    function _mintBatchCheckPrice( \n        address     owner,\n        uint8       quantity,\n        Signature   memory  permitMiner\n    ) view internal {\n\n        require((quantity != 0) && (quantity <= numberOfWhiteListBatch()), \"Arkreen Miner: Wrong Miner Number\");\n        require( quantity <= MAX_BATCH_SALE, 'Arkreen Miner: Quantity Too More');\n\n        // Check signature\n        // keccak256(\"RemoteMinerOnboardBatch(address owner,uint256 quantity,address token,uint256 value,uint256 deadline)\");\n        bytes32 hashRegister = keccak256(abi.encode(REMOTE_MINER_BATCH_TYPEHASH, owner, uint256(quantity),\n                                          permitMiner.token, permitMiner.value, permitMiner.deadline));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, hashRegister));\n        address recoveredAddress = ecrecover(digest, permitMiner.v, permitMiner.r, permitMiner.s);\n  \n        require(recoveredAddress != address(0) && \n                recoveredAddress == AllManagers[uint256(MinerManagerType.Register_Authority)], 'Arkreen Miner: INVALID_SIGNATURE');\n    }\n\n    /**\n     * @dev mint a remote Miner\n     * @param owner address receiving the remote miner\n     * @param miner address of the remote miner onboarding\n     */\n    function _mintRemoteMiner( address owner, address miner) internal {\n\n        // Prepare to mint new remote miner\n        Miner memory newMiner;\n        newMiner.mAddress = miner;\n        newMiner.mType = MinerType.RemoteMiner;\n        newMiner.mStatus = MinerStatus.Normal;\n        newMiner.timestamp = uint32(block.timestamp);    \n\n        // mint new remote miner\n        uint256 realMinerID = totalSupply() + 1;\n        _safeMint(owner, realMinerID);\n        AllMinersToken[miner] = realMinerID;\n        AllMinerInfo[realMinerID] = newMiner;\n\n        delete whiteListMiner[miner];\n    }\n\n    /**\n     * @dev mint a remote Miner\n     * @param owner address receiving the remote miner\n     * @param numMiners number of remote miners needed to mint\n     */\n    function _mintRemoteMinerBatch(address owner, uint8 numMiners) internal returns (address[] memory minerList) {\n\n        // Prepare to mint new remote miners\n        Miner memory newMiner;\n        minerList = new address[](numMiners);\n\n        newMiner.mType = MinerType.RemoteMiner;\n        newMiner.mStatus = MinerStatus.Normal;\n        newMiner.timestamp = uint32(block.timestamp);   \n\n        uint256 listHead = whiteListBatchIndexHead;\n\n        for(uint8 index; index < numMiners; index++) {\n            address miner = whiteListMinerBatch[listHead +index];\n            minerList[index] = miner;\n\n            // Check miner is not repeated\n            require(AllMinersToken[miner] == 0, \"Arkreen Miner: Miner Repeated\");\n\n            // mint new remote miner\n            uint256 realMinerID = totalSupply() + 1;\n            _safeMint(owner, realMinerID);\n            AllMinersToken[miner] = realMinerID;\n            newMiner.mAddress = miner;\n            AllMinerInfo[realMinerID] = newMiner;\n            delete whiteListMinerBatch[listHead +index];\n        }\n        whiteListBatchIndexHead += numMiners;\n    }\n\n    /**\n     * @dev Onboarding a remote Miner\n     * @param owner address receiving the remote miner\n     * @param miner address of the remote miner onboarding\n     * @param permitMiner signature of miner register authority to confirm the miner address and price.  \n     * @param permitToPay signature of payer to pay the onboarding fee\n     */\n    function RemoteMinerOnboard(\n        address     owner,\n        address     miner,\n        Sig       memory  permitMiner,\n        Signature memory  permitToPay\n    ) external ensure(permitToPay.deadline) {\n\n        // Check miner is white listed  \n        Signature memory fullPermitMiner = Signature(permitToPay.token, permitToPay.value, permitToPay.deadline,\n                                            permitMiner.v, permitMiner.r, permitMiner.s);\n \n        _mintRemoteMinerCheck(owner, miner, fullPermitMiner);\n\n        // Permit payment\n        address sender = _msgSender();\n        IERC20Permit(permitToPay.token).permit(sender, address(this), \n                                        permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\n\n        // mint new remote miner\n        _mintRemoteMiner(owner, miner);\n\n        // Transfer onboarding fee\n        TransferHelper.safeTransferFrom(permitToPay.token, sender, address(this), permitToPay.value);\n\n        emit MinerOnboarded(owner, miner);\n    }\n\n\n        /**\n     * @dev Onboarding remote miners in batch mode\n     * @param owner address receiving the remote miner\n     * @param numMiners number of remote miners desired to purchase\n     * @param permitMiner signature of miner register authority to confirm the miner address and price.  \n     * @param permitToPay signature of payer to pay the onboarding fee\n     */\n    function RemoteMinerOnboardBatch(\n        address     owner,\n        uint8       numMiners,\n        Sig       memory  permitMiner,\n        Signature memory  permitToPay\n    ) external ensure(permitToPay.deadline) {\n\n        // Check miner is white listed  \n        Signature memory fullPermitMiner = Signature(permitToPay.token, permitToPay.value , permitToPay.deadline,\n                                            permitMiner.v, permitMiner.r, permitMiner.s);\n \n        _mintBatchCheckPrice(owner, numMiners, fullPermitMiner);\n\n        // Permit payment\n        address sender = _msgSender();\n        IERC20Permit(permitToPay.token).permit(sender, address(this), \n                                        permitToPay.value, permitToPay.deadline, permitToPay.v, permitToPay.r, permitToPay.s);\n\n        // mint new remote miner\n        address[] memory minersBatch = _mintRemoteMinerBatch(owner, numMiners);\n\n        // Transfer onboarding fee\n        TransferHelper.safeTransferFrom(permitToPay.token, sender, address(this), permitToPay.value);\n\n        emit MinerOnboardedBatch(owner, minersBatch);\n    }\n\n    /**\n     * @dev Onboarding standard miner\n     * @param owner address receiving the standard miner\n     * @param miner address of the standard miner onboarding\n     * @param permitMiner signature of onboarding manager to approve the onboarding\n     */\n    function StandardMinerOnboard(\n        address owner,\n        address miner,\n        uint256 deadline,\n        Sig     calldata permitMiner\n    ) external ensure(deadline) {\n\n        // Check the starndard address\n        require(!miner.isContract(), 'Arkreen Miner: Not EOA Address');\n        require(AllMinersToken[miner] == 0, \"Arkreen Miner: Miner Repeated\");\n        MinerType minerType = MinerType(whiteListMiner[miner]);\n        require((minerType == MinerType.StandardMiner) || (minerType == MinerType.SocketMiner), 'Arkreen Miner: Wrong Miner');        \n\n        // Check signature\n        bytes32 hashRegister = keccak256(abi.encode(STANDARD_MINER_TYPEHASH, owner, miner, deadline));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', DOMAIN_SEPARATOR, hashRegister));\n        address recoveredAddress = ecrecover(digest, permitMiner.v, permitMiner.r, permitMiner.s);\n  \n        require(recoveredAddress != address(0) && \n                recoveredAddress == AllManagers[uint256(MinerManagerType.Register_Authority)], 'Arkreen Miner: INVALID_SIGNATURE');\n\n        Miner memory tmpMiner;\n        tmpMiner.mAddress = miner;\n        tmpMiner.mType = minerType;\n        tmpMiner.mStatus = MinerStatus.Normal;\n        tmpMiner.timestamp = uint32(block.timestamp);        \n\n        // Mint a new standard miner\n        uint256 minerID = totalSupply() + 1;\n        _safeMint(owner, minerID);\n        AllMinersToken[miner] = minerID;\n        AllMinerInfo[minerID] = tmpMiner;\n\n        // Increase the counter of total standard/socket miner \n        if(minerType == MinerType.StandardMiner) { \n          totalStandardMiner += 1;\n          emit StandardMinerOnboarded(owner,  miner);   // emit onboarding event\n        } else {\n          totalSocketMiner += 1;\n          emit SocketMinerOnboarded(owner,  miner);\n        }\n\n        delete whiteListMiner[miner]; \n    }\n\n    /**\n     * @dev Onboarding remote miners in batch\n     * @param owners addresses receiving the remote miners\n     * @param miners addresses of the remote miners onboarding\n     */\n    function RemoteMinerOnboardInBatch(\n        address[]  calldata   owners,\n        address[]  calldata   miners\n    ) external onlyMinerManager {\n\n        require(owners.length == miners.length, 'Arkreen Miner: Wrong Address List');\n\n        // Prepare to mint new remote miners, only remote miners\n        Miner memory newMiner;\n        newMiner.mType = MinerType.RemoteMiner;\n        newMiner.mStatus = MinerStatus.Normal;\n        newMiner.timestamp = uint32(block.timestamp);\n\n        for(uint256 index; index < owners.length; index++) {\n            // Mint new remote miners one by one\n            uint256 remoteMinerID = totalSupply() + 1;\n            newMiner.mAddress = miners[index];\n            _safeMint(owners[index], remoteMinerID);\n            AllMinersToken[newMiner.mAddress] = remoteMinerID;            \n            AllMinerInfo[remoteMinerID] = newMiner;\n        }\n        // Need to emit? If yes, data may be big \n        emit RemoteMinersInBatch(owners, miners);\n    }\n\n    /**\n     * @dev Get all the miner info of the specified miner\n     * @param addrMiner miner address\n     */\n    function GetMinerInfo(address addrMiner) external view returns (address owner, Miner memory miner) {\n        uint256 minerID = AllMinersToken[addrMiner];\n        owner = ownerOf(minerID);\n        miner = AllMinerInfo[minerID];\n    }\n\n    /**\n     * @dev Get all the miner address of the owner\n     * @param owner owner address\n     */\n    function GetMinersAddr(address owner) external view returns (address[] memory minersAddr) {\n        uint256 totalMiners = balanceOf(owner);\n        minersAddr = new address[](totalMiners);\n        for(uint256 index;  index < totalMiners; index++) {     \n            uint256 minerID = tokenOfOwnerByIndex(owner, index);\n            minersAddr[index] = AllMinerInfo[minerID].mAddress;\n        }\n    }\n\n    /**\n     * @dev Register or unregister miner manufactures\n     * @param manufactures manufactures to be registered or unregistered\n     * @param yesOrNo = true, to register manufactures, = false, to unregister manufactures\n     */\n    function ManageManufactures(address[] calldata manufactures, bool yesOrNo) external onlyOwner {\n      for(uint256 index;  index < manufactures.length; index++) {\n        AllManufactures[manufactures[index]] = yesOrNo;\n      }\n    }\n\n    /**\n     * @dev Update the miner status\n     * @param minerID miner ID of any type of miners\n     * @param minerStatus new status\n     */\n    function SetMinersStatus(uint256 minerID, MinerStatus minerStatus) external onlyOwner {\n        require(minerStatus != MinerStatus.Pending, 'Arkreen Miner: Wrong Input');      \n        AllMinerInfo[minerID].mStatus = minerStatus;\n    }\n\n    /**\n     * @dev Update the miner white list, add/remove the miners to/from the white list.\n     *      Only miners in the white list are allowed to onboard as an NFT.\n     * @param typeMiner Type of the miners to add, MinerType.Empty(=0) means to remove the miners\n     * @param addressMiners List of the miners\n     */\n    function UpdateMinerWhiteList(uint8 typeMiner, address[] calldata addressMiners) external onlyMinerManager {\n      address tempAddress;\n      for(uint256 index; index < addressMiners.length; index++) {\n        tempAddress = addressMiners[index];\n        if(typeMiner == 0xFF) {\n          delete whiteListMiner[tempAddress];\n          continue;\n        }\n        // Checked for non-existence\n        require( tempAddress != address(0) && !tempAddress.isContract(), 'Arkreen Miner: Wrong Address');     \n        require( whiteListMiner[tempAddress] == 0, 'Arkreen Miner: Miners Repeated');      \n        whiteListMiner[tempAddress] = uint8(typeMiner);\n      }\n    }\n\n    /**\n     * @dev Update the miner white list for batch sales. Only miners in the white list are allowed to onboard as an NFT.\n     * @param addressMiners List of the miners\n     */\n    function UpdateMinerWhiteListBatch(address[] calldata addressMiners) external onlyMinerManager {\n      uint256 indexStart = whiteListBatchIndexTail;\n      uint256 length = addressMiners.length;\n      for(uint256 index; index < length; index++) {\n        whiteListMinerBatch[indexStart + index] = addressMiners[index];\n      }\n      whiteListBatchIndexTail += length;\n    }\n\n    /**\n     * @dev get the length of the white list for batch sales\n     */\n    function numberOfWhiteListBatch() public view returns (uint256) {\n      return whiteListBatchIndexTail - whiteListBatchIndexHead;\n    }\n\n    /**\n     * @dev Check if holding miners\n     * @param owner owner address\n     */\n    function isOwner(address owner) external view returns (bool) {\n        // just considering number of tokens, token status not checked \n        return balanceOf(owner) > 0;\n    }\n\n    /**\n     * @dev Set the Arkreen managing accounts \n     * @param managerType type of the managing account\n     * @param managerAddress address of the managing account     \n     */\n    function setManager(uint256 managerType, address managerAddress) external onlyOwner {\n      AllManagers[managerType] = managerAddress;\n    }\n\n    /**\n     * @dev Set the native token address\n     * @param native address, not checked againt zero address to disable payment by native token    \n     */\n    function setNativeToken(address native) external onlyOwner {\n      tokenNative = native;\n    }    \n\n    /**\n     * @dev Withdraw all the onboarding fee\n     * @param token address of the token to withdraw, USDC/ARKE\n     */\n    function withdraw(address token) public onlyOwner {\n        address receiver = AllManagers[uint256(MinerManagerType.Payment_Receiver)];\n        if(receiver == address(0)) {\n            receiver = _msgSender();\n        }\n\n        if(token == tokenNative) {\n            TransferHelper.safeTransferETH(receiver, address(this).balance);      \n        } else {\n            uint256 balance = IERC20(token).balanceOf(address(this));\n            TransferHelper.safeTransfer(token, receiver, balance);\n        }\n      }\n\n    function tokenURI(uint256 tokenId) public view override returns (string memory){\n        return super.tokenURI(tokenId);\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public view override( ERC721EnumerableUpgradeable) returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function setBaseURI(string memory newBaseURI) external virtual onlyOwner {\n        baseURI = newBaseURI;\n    }\n\n    function _baseURI() internal view virtual override returns (string memory) {\n        return baseURI;\n    }\n\n}\n"
    },
    "contracts/ArkreenMinerTypes.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nenum MinerType {\n    SKIP_0,\n    SKIP_1,\n    StandardMiner,            // 2\n    RemoteMiner,              // 3\n    APIMiner,                 // 4\n    SocketMiner               // 5\n}\n\nenum MinerStatus {\n    Pending,            // 0\n    Normal,             // 1\n    Locked,             // 2\n    Terminated          // 3\n}\n\nstruct Miner {\n    address         mAddress;\n    MinerType       mType;\n    MinerStatus     mStatus;\n    uint32          timestamp;\n}    \n\nenum MinerManagerType {\n    Miner_Manager,        // 0\n    Register_Authority,   // 1\n    Payment_Receiver      // 2\n}\n\nstruct Signature {\n    address     token;\n    uint256     value;\n    uint256     deadline;  \n    uint8       v;\n    bytes32     r;\n    bytes32     s;              \n}\n\nstruct Sig {\n    uint8       v;\n    bytes32     r;\n    bytes32     s;              \n}"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.3) (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../StringsUpgradeable.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSAUpgradeable {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            /// @solidity memory-safe-assembly\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s = vs & bytes32(0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff);\n        uint8 v = uint8((uint256(vs) >> 255) + 27);\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n ÷ 2 + 1, and for v in (302): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", StringsUpgradeable.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-ERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (token/ERC20/extensions/draft-ERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-IERC20PermitUpgradeable.sol\";\nimport \"../ERC20Upgradeable.sol\";\nimport \"../../../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../utils/CountersUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Implementation of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on `{IERC20-approve}`, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 51\n */\nabstract contract ERC20PermitUpgradeable is Initializable, ERC20Upgradeable, IERC20PermitUpgradeable, EIP712Upgradeable {\n    using CountersUpgradeable for CountersUpgradeable.Counter;\n\n    mapping(address => CountersUpgradeable.Counter) private _nonces;\n\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private constant _PERMIT_TYPEHASH =\n        keccak256(\"Permit(address owner,address spender,uint256 value,uint256 nonce,uint256 deadline)\");\n    /**\n     * @dev In previous versions `_PERMIT_TYPEHASH` was declared as `immutable`.\n     * However, to ensure consistency with the upgradeable transpiler, we will continue\n     * to reserve a slot.\n     * @custom:oz-renamed-from _PERMIT_TYPEHASH\n     */\n    // solhint-disable-next-line var-name-mixedcase\n    bytes32 private _PERMIT_TYPEHASH_DEPRECATED_SLOT;\n\n    /**\n     * @dev Initializes the {EIP712} domain separator using the `name` parameter, and setting `version` to `\"1\"`.\n     *\n     * It's a good idea to use the same `name` that is defined as the ERC20 token name.\n     */\n    function __ERC20Permit_init(string memory name) internal onlyInitializing {\n        __EIP712_init_unchained(name, \"1\");\n    }\n\n    function __ERC20Permit_init_unchained(string memory) internal onlyInitializing {}\n\n    /**\n     * @dev See {IERC20Permit-permit}.\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= deadline, \"ERC20Permit: expired deadline\");\n\n        bytes32 structHash = keccak256(abi.encode(_PERMIT_TYPEHASH, owner, spender, value, _useNonce(owner), deadline));\n\n        bytes32 hash = _hashTypedDataV4(structHash);\n\n        address signer = ECDSAUpgradeable.recover(hash, v, r, s);\n        require(signer == owner, \"ERC20Permit: invalid signature\");\n\n        _approve(owner, spender, value);\n    }\n\n    /**\n     * @dev See {IERC20Permit-nonces}.\n     */\n    function nonces(address owner) public view virtual override returns (uint256) {\n        return _nonces[owner].current();\n    }\n\n    /**\n     * @dev See {IERC20Permit-DOMAIN_SEPARATOR}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view override returns (bytes32) {\n        return _domainSeparatorV4();\n    }\n\n    /**\n     * @dev \"Consume a nonce\": return the current value and increment.\n     *\n     * _Available since v4.1._\n     */\n    function _useNonce(address owner) internal virtual returns (uint256 current) {\n        CountersUpgradeable.Counter storage nonce = _nonces[owner];\n        current = nonce.current();\n        nonce.increment();\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/draft-IERC20PermitUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (token/ERC20/extensions/draft-IERC20Permit.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Interface of the ERC20 Permit extension allowing approvals to be made via signatures, as defined in\n * https://eips.ethereum.org/EIPS/eip-2612[EIP-2612].\n *\n * Adds the {permit} method, which can be used to change an account's ERC20 allowance (see {IERC20-allowance}) by\n * presenting a message signed by the account. By not relying on {IERC20-approve}, the token holder account doesn't\n * need to send a transaction, and thus is not required to hold Ether at all.\n */\ninterface IERC20PermitUpgradeable {\n    /**\n     * @dev Sets `value` as the allowance of `spender` over ``owner``'s tokens,\n     * given ``owner``'s signed approval.\n     *\n     * IMPORTANT: The same issues {IERC20-approve} has related to transaction\n     * ordering also apply here.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `deadline` must be a timestamp in the future.\n     * - `v`, `r` and `s` must be a valid `secp256k1` signature from `owner`\n     * over the EIP712-formatted function arguments.\n     * - the signature must use ``owner``'s current nonce (see {nonces}).\n     *\n     * For more information on the signature format, see the\n     * https://eips.ethereum.org/EIPS/eip-2612#specification[relevant EIP\n     * section].\n     */\n    function permit(\n        address owner,\n        address spender,\n        uint256 value,\n        uint256 deadline,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n\n    /**\n     * @dev Returns the current nonce for `owner`. This value must be\n     * included whenever a signature is generated for {permit}.\n     *\n     * Every successful call to {permit} increases ``owner``'s nonce by one. This\n     * prevents a signature from being used multiple times.\n     */\n    function nonces(address owner) external view returns (uint256);\n\n    /**\n     * @dev Returns the domain separator used in the encoding of the signature for {permit}, as defined by {EIP712}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function DOMAIN_SEPARATOR() external view returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/cryptography/draft-EIP712Upgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/draft-EIP712.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./ECDSAUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev https://eips.ethereum.org/EIPS/eip-712[EIP 712] is a standard for hashing and signing of typed structured data.\n *\n * The encoding specified in the EIP is very generic, and such a generic implementation in Solidity is not feasible,\n * thus this contract does not implement the encoding itself. Protocols need to implement the type-specific encoding\n * they need in their contracts using a combination of `abi.encode` and `keccak256`.\n *\n * This contract implements the EIP 712 domain separator ({_domainSeparatorV4}) that is used as part of the encoding\n * scheme, and the final step of the encoding to obtain the message digest that is then signed via ECDSA\n * ({_hashTypedDataV4}).\n *\n * The implementation of the domain separator was designed to be as efficient as possible while still properly updating\n * the chain id to protect against replay attacks on an eventual fork of the chain.\n *\n * NOTE: This contract implements the version of the encoding known as \"v4\", as implemented by the JSON RPC method\n * https://docs.metamask.io/guide/signing-data.html[`eth_signTypedDataV4` in MetaMask].\n *\n * _Available since v3.4._\n *\n * @custom:storage-size 52\n */\nabstract contract EIP712Upgradeable is Initializable {\n    /* solhint-disable var-name-mixedcase */\n    bytes32 private _HASHED_NAME;\n    bytes32 private _HASHED_VERSION;\n    bytes32 private constant _TYPE_HASH = keccak256(\"EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)\");\n\n    /* solhint-enable var-name-mixedcase */\n\n    /**\n     * @dev Initializes the domain separator and parameter caches.\n     *\n     * The meaning of `name` and `version` is specified in\n     * https://eips.ethereum.org/EIPS/eip-712#definition-of-domainseparator[EIP 712]:\n     *\n     * - `name`: the user readable name of the signing domain, i.e. the name of the DApp or the protocol.\n     * - `version`: the current major version of the signing domain.\n     *\n     * NOTE: These parameters cannot be changed except through a xref:learn::upgrading-smart-contracts.adoc[smart\n     * contract upgrade].\n     */\n    function __EIP712_init(string memory name, string memory version) internal onlyInitializing {\n        __EIP712_init_unchained(name, version);\n    }\n\n    function __EIP712_init_unchained(string memory name, string memory version) internal onlyInitializing {\n        bytes32 hashedName = keccak256(bytes(name));\n        bytes32 hashedVersion = keccak256(bytes(version));\n        _HASHED_NAME = hashedName;\n        _HASHED_VERSION = hashedVersion;\n    }\n\n    /**\n     * @dev Returns the domain separator for the current chain.\n     */\n    function _domainSeparatorV4() internal view returns (bytes32) {\n        return _buildDomainSeparator(_TYPE_HASH, _EIP712NameHash(), _EIP712VersionHash());\n    }\n\n    function _buildDomainSeparator(\n        bytes32 typeHash,\n        bytes32 nameHash,\n        bytes32 versionHash\n    ) private view returns (bytes32) {\n        return keccak256(abi.encode(typeHash, nameHash, versionHash, block.chainid, address(this)));\n    }\n\n    /**\n     * @dev Given an already https://eips.ethereum.org/EIPS/eip-712#definition-of-hashstruct[hashed struct], this\n     * function returns the hash of the fully encoded EIP712 message for this domain.\n     *\n     * This hash can be used together with {ECDSA-recover} to obtain the signer of a message. For example:\n     *\n     * ```solidity\n     * bytes32 digest = _hashTypedDataV4(keccak256(abi.encode(\n     *     keccak256(\"Mail(address to,string contents)\"),\n     *     mailTo,\n     *     keccak256(bytes(mailContents))\n     * )));\n     * address signer = ECDSA.recover(digest, signature);\n     * ```\n     */\n    function _hashTypedDataV4(bytes32 structHash) internal view virtual returns (bytes32) {\n        return ECDSAUpgradeable.toTypedDataHash(_domainSeparatorV4(), structHash);\n    }\n\n    /**\n     * @dev The hash of the name parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712NameHash() internal virtual view returns (bytes32) {\n        return _HASHED_NAME;\n    }\n\n    /**\n     * @dev The hash of the version parameter for the EIP712 domain.\n     *\n     * NOTE: This function reads from storage by default, but can be redefined to return a constant value if gas costs\n     * are a concern.\n     */\n    function _EIP712VersionHash() internal virtual view returns (bytes32) {\n        return _HASHED_VERSION;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CountersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Counters.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @title Counters\n * @author Matt Condon (@shrugs)\n * @dev Provides counters that can only be incremented, decremented or reset. This can be used e.g. to track the number\n * of elements in a mapping, issuing ERC721 ids, or counting request ids.\n *\n * Include with `using Counters for Counters.Counter;`\n */\nlibrary CountersUpgradeable {\n    struct Counter {\n        // This variable should never be directly accessed by users of the library: interactions must be restricted to\n        // the library's function. As of Solidity v0.5.2, this cannot be enforced, though there is a proposal to add\n        // this feature: see https://github.com/ethereum/solidity/issues/4637\n        uint256 _value; // default: 0\n    }\n\n    function current(Counter storage counter) internal view returns (uint256) {\n        return counter._value;\n    }\n\n    function increment(Counter storage counter) internal {\n        unchecked {\n            counter._value += 1;\n        }\n    }\n\n    function decrement(Counter storage counter) internal {\n        uint256 value = counter._value;\n        require(value > 0, \"Counter: decrement overflow\");\n        unchecked {\n            counter._value = value - 1;\n        }\n    }\n\n    function reset(Counter storage counter) internal {\n        counter._value = 0;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (governance/Governor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../utils/cryptography/draft-EIP712Upgradeable.sol\";\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../utils/math/SafeCastUpgradeable.sol\";\nimport \"../utils/structs/DoubleEndedQueueUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../utils/ContextUpgradeable.sol\";\nimport \"../utils/TimersUpgradeable.sol\";\nimport \"./IGovernorUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Core of the governance system, designed to be extended though various modules.\n *\n * This contract is abstract and requires several function to be implemented in various modules:\n *\n * - A counting module must implement {quorum}, {_quorumReached}, {_voteSucceeded} and {_countVote}\n * - A voting module must implement {_getVotes}\n * - Additionanly, the {votingPeriod} must also be implemented\n *\n * _Available since v4.3._\n */\nabstract contract GovernorUpgradeable is Initializable, ContextUpgradeable, ERC165Upgradeable, EIP712Upgradeable, IGovernorUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n    using DoubleEndedQueueUpgradeable for DoubleEndedQueueUpgradeable.Bytes32Deque;\n    using SafeCastUpgradeable for uint256;\n    using TimersUpgradeable for TimersUpgradeable.BlockNumber;\n\n    bytes32 public constant BALLOT_TYPEHASH = keccak256(\"Ballot(uint256 proposalId,uint8 support)\");\n    bytes32 public constant EXTENDED_BALLOT_TYPEHASH =\n        keccak256(\"ExtendedBallot(uint256 proposalId,uint8 support,string reason,bytes params)\");\n\n    struct ProposalCore {\n        TimersUpgradeable.BlockNumber voteStart;\n        TimersUpgradeable.BlockNumber voteEnd;\n        bool executed;\n        bool canceled;\n    }\n\n    string private _name;\n\n    mapping(uint256 => ProposalCore) private _proposals;\n\n    // This queue keeps track of the governor operating on itself. Calls to functions protected by the\n    // {onlyGovernance} modifier needs to be whitelisted in this queue. Whitelisting is set in {_beforeExecute},\n    // consumed by the {onlyGovernance} modifier and eventually reset in {_afterExecute}. This ensures that the\n    // execution of {onlyGovernance} protected calls can only be achieved through successful proposals.\n    DoubleEndedQueueUpgradeable.Bytes32Deque private _governanceCall;\n\n    /**\n     * @dev Restricts a function so it can only be executed through governance proposals. For example, governance\n     * parameter setters in {GovernorSettings} are protected using this modifier.\n     *\n     * The governance executing address may be different from the Governor's own address, for example it could be a\n     * timelock. This can be customized by modules by overriding {_executor}. The executor is only able to invoke these\n     * functions during the execution of the governor's {execute} function, and not under any other circumstances. Thus,\n     * for example, additional timelock proposers are not able to change governance parameters without going through the\n     * governance protocol (since v4.6).\n     */\n    modifier onlyGovernance() {\n        require(_msgSender() == _executor(), \"Governor: onlyGovernance\");\n        if (_executor() != address(this)) {\n            bytes32 msgDataHash = keccak256(_msgData());\n            // loop until popping the expected operation - throw if deque is empty (operation not authorized)\n            while (_governanceCall.popFront() != msgDataHash) {}\n        }\n        _;\n    }\n\n    /**\n     * @dev Sets the value for {name} and {version}\n     */\n    function __Governor_init(string memory name_) internal onlyInitializing {\n        __EIP712_init_unchained(name_, version());\n        __Governor_init_unchained(name_);\n    }\n\n    function __Governor_init_unchained(string memory name_) internal onlyInitializing {\n        _name = name_;\n    }\n\n    /**\n     * @dev Function to receive ETH that will be handled by the governor (disabled if executor is a third party contract)\n     */\n    receive() external payable virtual {\n        require(_executor() == address(this));\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, ERC165Upgradeable) returns (bool) {\n        // In addition to the current interfaceId, also support previous version of the interfaceId that did not\n        // include the castVoteWithReasonAndParams() function as standard\n        return\n            interfaceId ==\n            (type(IGovernorUpgradeable).interfaceId ^\n                this.castVoteWithReasonAndParams.selector ^\n                this.castVoteWithReasonAndParamsBySig.selector ^\n                this.getVotesWithParams.selector) ||\n            interfaceId == type(IGovernorUpgradeable).interfaceId ||\n            interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId ||\n            super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev See {IGovernor-name}.\n     */\n    function name() public view virtual override returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev See {IGovernor-version}.\n     */\n    function version() public view virtual override returns (string memory) {\n        return \"1\";\n    }\n\n    /**\n     * @dev See {IGovernor-hashProposal}.\n     *\n     * The proposal id is produced by hashing the ABI encoded `targets` array, the `values` array, the `calldatas` array\n     * and the descriptionHash (bytes32 which itself is the keccak256 hash of the description string). This proposal id\n     * can be produced from the proposal data which is part of the {ProposalCreated} event. It can even be computed in\n     * advance, before the proposal is submitted.\n     *\n     * Note that the chainId and the governor address are not part of the proposal id computation. Consequently, the\n     * same proposal (with same operation and same description) will have the same id if submitted on multiple governors\n     * across multiple networks. This also means that in order to execute the same operation twice (on the same\n     * governor) the proposer will have to change the description in order to avoid proposal id conflicts.\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual override returns (uint256) {\n        return uint256(keccak256(abi.encode(targets, values, calldatas, descriptionHash)));\n    }\n\n    /**\n     * @dev See {IGovernor-state}.\n     */\n    function state(uint256 proposalId) public view virtual override returns (ProposalState) {\n        ProposalCore storage proposal = _proposals[proposalId];\n\n        if (proposal.executed) {\n            return ProposalState.Executed;\n        }\n\n        if (proposal.canceled) {\n            return ProposalState.Canceled;\n        }\n\n        uint256 snapshot = proposalSnapshot(proposalId);\n\n        if (snapshot == 0) {\n            revert(\"Governor: unknown proposal id\");\n        }\n\n        if (snapshot >= block.number) {\n            return ProposalState.Pending;\n        }\n\n        uint256 deadline = proposalDeadline(proposalId);\n\n        if (deadline >= block.number) {\n            return ProposalState.Active;\n        }\n\n        if (_quorumReached(proposalId) && _voteSucceeded(proposalId)) {\n            return ProposalState.Succeeded;\n        } else {\n            return ProposalState.Defeated;\n        }\n    }\n\n    /**\n     * @dev See {IGovernor-proposalSnapshot}.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteStart.getDeadline();\n    }\n\n    /**\n     * @dev See {IGovernor-proposalDeadline}.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual override returns (uint256) {\n        return _proposals[proposalId].voteEnd.getDeadline();\n    }\n\n    /**\n     * @dev Part of the Governor Bravo's interface: _\"The number of votes required in order for a voter to become a proposer\"_.\n     */\n    function proposalThreshold() public view virtual returns (uint256) {\n        return 0;\n    }\n\n    /**\n     * @dev Amount of votes already cast passes the threshold limit.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Is the proposal successful or not.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual returns (bool);\n\n    /**\n     * @dev Get the voting weight of `account` at a specific `blockNumber`, for a vote as described by `params`.\n     */\n    function _getVotes(\n        address account,\n        uint256 blockNumber,\n        bytes memory params\n    ) internal view virtual returns (uint256);\n\n    /**\n     * @dev Register a vote for `proposalId` by `account` with a given `support`, voting `weight` and voting `params`.\n     *\n     * Note: Support is generic and can represent various things depending on the voting system used.\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory params\n    ) internal virtual;\n\n    /**\n     * @dev Default additional encoded parameters used by castVote methods that don't include them\n     *\n     * Note: Should be overridden by specific implementations to use an appropriate value, the\n     * meaning of the additional params, in the context of that implementation\n     */\n    function _defaultParams() internal view virtual returns (bytes memory) {\n        return \"\";\n    }\n\n    /**\n     * @dev See {IGovernor-propose}.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual override returns (uint256) {\n        require(\n            getVotes(_msgSender(), block.number - 1) >= proposalThreshold(),\n            \"Governor: proposer votes below proposal threshold\"\n        );\n\n        uint256 proposalId = hashProposal(targets, values, calldatas, keccak256(bytes(description)));\n\n        require(targets.length == values.length, \"Governor: invalid proposal length\");\n        require(targets.length == calldatas.length, \"Governor: invalid proposal length\");\n        require(targets.length > 0, \"Governor: empty proposal\");\n\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(proposal.voteStart.isUnset(), \"Governor: proposal already exists\");\n\n        uint64 snapshot = block.number.toUint64() + votingDelay().toUint64();\n        uint64 deadline = snapshot + votingPeriod().toUint64();\n\n        proposal.voteStart.setDeadline(snapshot);\n        proposal.voteEnd.setDeadline(deadline);\n\n        emit ProposalCreated(\n            proposalId,\n            _msgSender(),\n            targets,\n            values,\n            new string[](targets.length),\n            calldatas,\n            snapshot,\n            deadline,\n            description\n        );\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-execute}.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        ProposalState status = state(proposalId);\n        require(\n            status == ProposalState.Succeeded || status == ProposalState.Queued,\n            \"Governor: proposal not successful\"\n        );\n        _proposals[proposalId].executed = true;\n\n        emit ProposalExecuted(proposalId);\n\n        _beforeExecute(proposalId, targets, values, calldatas, descriptionHash);\n        _execute(proposalId, targets, values, calldatas, descriptionHash);\n        _afterExecute(proposalId, targets, values, calldatas, descriptionHash);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Internal execution mechanism. Can be overridden to implement different execution mechanism\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        string memory errorMessage = \"Governor: call reverted without message\";\n        for (uint256 i = 0; i < targets.length; ++i) {\n            (bool success, bytes memory returndata) = targets[i].call{value: values[i]}(calldatas[i]);\n            AddressUpgradeable.verifyCallResult(success, returndata, errorMessage);\n        }\n    }\n\n    /**\n     * @dev Hook before execution is triggered.\n     */\n    function _beforeExecute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory, /* values */\n        bytes[] memory calldatas,\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            for (uint256 i = 0; i < targets.length; ++i) {\n                if (targets[i] == address(this)) {\n                    _governanceCall.pushBack(keccak256(calldatas[i]));\n                }\n            }\n        }\n    }\n\n    /**\n     * @dev Hook after execution is triggered.\n     */\n    function _afterExecute(\n        uint256, /* proposalId */\n        address[] memory, /* targets */\n        uint256[] memory, /* values */\n        bytes[] memory, /* calldatas */\n        bytes32 /*descriptionHash*/\n    ) internal virtual {\n        if (_executor() != address(this)) {\n            if (!_governanceCall.empty()) {\n                _governanceCall.clear();\n            }\n        }\n    }\n\n    /**\n     * @dev Internal cancel mechanism: locks up the proposal timer, preventing it from being re-submitted. Marks it as\n     * canceled to allow distinguishing it from executed proposals.\n     *\n     * Emits a {IGovernor-ProposalCanceled} event.\n     */\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n        ProposalState status = state(proposalId);\n\n        require(\n            status != ProposalState.Canceled && status != ProposalState.Expired && status != ProposalState.Executed,\n            \"Governor: proposal not active\"\n        );\n        _proposals[proposalId].canceled = true;\n\n        emit ProposalCanceled(proposalId);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev See {IGovernor-getVotes}.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        return _getVotes(account, blockNumber, _defaultParams());\n    }\n\n    /**\n     * @dev See {IGovernor-getVotesWithParams}.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 blockNumber,\n        bytes memory params\n    ) public view virtual override returns (uint256) {\n        return _getVotes(account, blockNumber, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVote}.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReason}.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParams}.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual override returns (uint256) {\n        address voter = _msgSender();\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteBySig}.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(BALLOT_TYPEHASH, proposalId, support))),\n            v,\n            r,\n            s\n        );\n        return _castVote(proposalId, voter, support, \"\");\n    }\n\n    /**\n     * @dev See {IGovernor-castVoteWithReasonAndParamsBySig}.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override returns (uint256) {\n        address voter = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(\n                keccak256(\n                    abi.encode(\n                        EXTENDED_BALLOT_TYPEHASH,\n                        proposalId,\n                        support,\n                        keccak256(bytes(reason)),\n                        keccak256(params)\n                    )\n                )\n            ),\n            v,\n            r,\n            s\n        );\n\n        return _castVote(proposalId, voter, support, reason, params);\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function. Uses the _defaultParams().\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason\n    ) internal virtual returns (uint256) {\n        return _castVote(proposalId, account, support, reason, _defaultParams());\n    }\n\n    /**\n     * @dev Internal vote casting mechanism: Check that the vote is pending, that it has not been cast yet, retrieve\n     * voting weight using {IGovernor-getVotes} and call the {_countVote} internal function.\n     *\n     * Emits a {IGovernor-VoteCast} event.\n     */\n    function _castVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        string memory reason,\n        bytes memory params\n    ) internal virtual returns (uint256) {\n        ProposalCore storage proposal = _proposals[proposalId];\n        require(state(proposalId) == ProposalState.Active, \"Governor: vote not currently active\");\n\n        uint256 weight = _getVotes(account, proposal.voteStart.getDeadline(), params);\n        _countVote(proposalId, account, support, weight, params);\n\n        if (params.length == 0) {\n            emit VoteCast(account, proposalId, support, weight, reason);\n        } else {\n            emit VoteCastWithParams(account, proposalId, support, weight, reason, params);\n        }\n\n        return weight;\n    }\n\n    /**\n     * @dev Relays a transaction or function call to an arbitrary target. In cases where the governance executor\n     * is some contract other than the governor itself, like when using a timelock, this function can be invoked\n     * in a governance proposal to recover tokens or Ether that was sent to the governor contract by mistake.\n     * Note that if the executor is simply the governor itself, use of `relay` is redundant.\n     */\n    function relay(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) external virtual onlyGovernance {\n        AddressUpgradeable.functionCallWithValue(target, data, value);\n    }\n\n    /**\n     * @dev Address through which the governor executes action. Will be overloaded by module that execute actions\n     * through another contract such as a timelock.\n     */\n    function _executor() internal view virtual returns (address) {\n        return address(this);\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[46] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC1155/IERC1155ReceiverUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC1155/IERC1155Receiver.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../../utils/introspection/IERC165Upgradeable.sol\";\n\n/**\n * @dev _Available since v3.1._\n */\ninterface IERC1155ReceiverUpgradeable is IERC165Upgradeable {\n    /**\n     * @dev Handles the receipt of a single ERC1155 token type. This function is\n     * called at the end of a `safeTransferFrom` after the balance has been updated.\n     *\n     * NOTE: To accept the transfer, this must return\n     * `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))`\n     * (i.e. 0xf23a6e61, or its own function selector).\n     *\n     * @param operator The address which initiated the transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param id The ID of the token being transferred\n     * @param value The amount of tokens being transferred\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155Received(address,address,uint256,uint256,bytes)\"))` if transfer is allowed\n     */\n    function onERC1155Received(\n        address operator,\n        address from,\n        uint256 id,\n        uint256 value,\n        bytes calldata data\n    ) external returns (bytes4);\n\n    /**\n     * @dev Handles the receipt of a multiple ERC1155 token types. This function\n     * is called at the end of a `safeBatchTransferFrom` after the balances have\n     * been updated.\n     *\n     * NOTE: To accept the transfer(s), this must return\n     * `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))`\n     * (i.e. 0xbc197c81, or its own function selector).\n     *\n     * @param operator The address which initiated the batch transfer (i.e. msg.sender)\n     * @param from The address which previously owned the token\n     * @param ids An array containing ids of each token being transferred (order and length must match values array)\n     * @param values An array containing amounts of each token being transferred (order and length must match ids array)\n     * @param data Additional data with no specified format\n     * @return `bytes4(keccak256(\"onERC1155BatchReceived(address,address,uint256[],uint256[],bytes)\"))` if transfer is allowed\n     */\n    function onERC1155BatchReceived(\n        address operator,\n        address from,\n        uint256[] calldata ids,\n        uint256[] calldata values,\n        bytes calldata data\n    ) external returns (bytes4);\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/SafeCastUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/SafeCast.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Wrappers over Solidity's uintXX/intXX casting operators with added overflow\n * checks.\n *\n * Downcasting from uint256/int256 in Solidity does not revert on overflow. This can\n * easily result in undesired exploitation or bugs, since developers usually\n * assume that overflows raise errors. `SafeCast` restores this intuition by\n * reverting the transaction when such an operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n *\n * Can be combined with {SafeMath} and {SignedSafeMath} to extend it to smaller types, by performing\n * all math on `uint256` and `int256` and then downcasting.\n */\nlibrary SafeCastUpgradeable {\n    /**\n     * @dev Returns the downcasted uint248 from uint256, reverting on\n     * overflow (when the input is greater than largest uint248).\n     *\n     * Counterpart to Solidity's `uint248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint248(uint256 value) internal pure returns (uint248) {\n        require(value <= type(uint248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return uint248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint240 from uint256, reverting on\n     * overflow (when the input is greater than largest uint240).\n     *\n     * Counterpart to Solidity's `uint240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint240(uint256 value) internal pure returns (uint240) {\n        require(value <= type(uint240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return uint240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint232 from uint256, reverting on\n     * overflow (when the input is greater than largest uint232).\n     *\n     * Counterpart to Solidity's `uint232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint232(uint256 value) internal pure returns (uint232) {\n        require(value <= type(uint232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return uint232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint224 from uint256, reverting on\n     * overflow (when the input is greater than largest uint224).\n     *\n     * Counterpart to Solidity's `uint224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint224(uint256 value) internal pure returns (uint224) {\n        require(value <= type(uint224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return uint224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint216 from uint256, reverting on\n     * overflow (when the input is greater than largest uint216).\n     *\n     * Counterpart to Solidity's `uint216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint216(uint256 value) internal pure returns (uint216) {\n        require(value <= type(uint216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return uint216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint208 from uint256, reverting on\n     * overflow (when the input is greater than largest uint208).\n     *\n     * Counterpart to Solidity's `uint208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint208(uint256 value) internal pure returns (uint208) {\n        require(value <= type(uint208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return uint208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint200 from uint256, reverting on\n     * overflow (when the input is greater than largest uint200).\n     *\n     * Counterpart to Solidity's `uint200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint200(uint256 value) internal pure returns (uint200) {\n        require(value <= type(uint200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return uint200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint192 from uint256, reverting on\n     * overflow (when the input is greater than largest uint192).\n     *\n     * Counterpart to Solidity's `uint192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint192(uint256 value) internal pure returns (uint192) {\n        require(value <= type(uint192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return uint192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint184 from uint256, reverting on\n     * overflow (when the input is greater than largest uint184).\n     *\n     * Counterpart to Solidity's `uint184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint184(uint256 value) internal pure returns (uint184) {\n        require(value <= type(uint184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return uint184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint176 from uint256, reverting on\n     * overflow (when the input is greater than largest uint176).\n     *\n     * Counterpart to Solidity's `uint176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint176(uint256 value) internal pure returns (uint176) {\n        require(value <= type(uint176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return uint176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint168 from uint256, reverting on\n     * overflow (when the input is greater than largest uint168).\n     *\n     * Counterpart to Solidity's `uint168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint168(uint256 value) internal pure returns (uint168) {\n        require(value <= type(uint168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return uint168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint160 from uint256, reverting on\n     * overflow (when the input is greater than largest uint160).\n     *\n     * Counterpart to Solidity's `uint160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint160(uint256 value) internal pure returns (uint160) {\n        require(value <= type(uint160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return uint160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint152 from uint256, reverting on\n     * overflow (when the input is greater than largest uint152).\n     *\n     * Counterpart to Solidity's `uint152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint152(uint256 value) internal pure returns (uint152) {\n        require(value <= type(uint152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return uint152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint144 from uint256, reverting on\n     * overflow (when the input is greater than largest uint144).\n     *\n     * Counterpart to Solidity's `uint144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint144(uint256 value) internal pure returns (uint144) {\n        require(value <= type(uint144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return uint144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint136 from uint256, reverting on\n     * overflow (when the input is greater than largest uint136).\n     *\n     * Counterpart to Solidity's `uint136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint136(uint256 value) internal pure returns (uint136) {\n        require(value <= type(uint136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return uint136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint128 from uint256, reverting on\n     * overflow (when the input is greater than largest uint128).\n     *\n     * Counterpart to Solidity's `uint128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint128(uint256 value) internal pure returns (uint128) {\n        require(value <= type(uint128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return uint128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint120 from uint256, reverting on\n     * overflow (when the input is greater than largest uint120).\n     *\n     * Counterpart to Solidity's `uint120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint120(uint256 value) internal pure returns (uint120) {\n        require(value <= type(uint120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return uint120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint112 from uint256, reverting on\n     * overflow (when the input is greater than largest uint112).\n     *\n     * Counterpart to Solidity's `uint112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint112(uint256 value) internal pure returns (uint112) {\n        require(value <= type(uint112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return uint112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint104 from uint256, reverting on\n     * overflow (when the input is greater than largest uint104).\n     *\n     * Counterpart to Solidity's `uint104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint104(uint256 value) internal pure returns (uint104) {\n        require(value <= type(uint104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return uint104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint96 from uint256, reverting on\n     * overflow (when the input is greater than largest uint96).\n     *\n     * Counterpart to Solidity's `uint96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.2._\n     */\n    function toUint96(uint256 value) internal pure returns (uint96) {\n        require(value <= type(uint96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return uint96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint88 from uint256, reverting on\n     * overflow (when the input is greater than largest uint88).\n     *\n     * Counterpart to Solidity's `uint88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint88(uint256 value) internal pure returns (uint88) {\n        require(value <= type(uint88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return uint88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint80 from uint256, reverting on\n     * overflow (when the input is greater than largest uint80).\n     *\n     * Counterpart to Solidity's `uint80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint80(uint256 value) internal pure returns (uint80) {\n        require(value <= type(uint80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return uint80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint72 from uint256, reverting on\n     * overflow (when the input is greater than largest uint72).\n     *\n     * Counterpart to Solidity's `uint72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint72(uint256 value) internal pure returns (uint72) {\n        require(value <= type(uint72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return uint72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint64 from uint256, reverting on\n     * overflow (when the input is greater than largest uint64).\n     *\n     * Counterpart to Solidity's `uint64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint64(uint256 value) internal pure returns (uint64) {\n        require(value <= type(uint64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return uint64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint56 from uint256, reverting on\n     * overflow (when the input is greater than largest uint56).\n     *\n     * Counterpart to Solidity's `uint56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint56(uint256 value) internal pure returns (uint56) {\n        require(value <= type(uint56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return uint56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint48 from uint256, reverting on\n     * overflow (when the input is greater than largest uint48).\n     *\n     * Counterpart to Solidity's `uint48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint48(uint256 value) internal pure returns (uint48) {\n        require(value <= type(uint48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return uint48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint40 from uint256, reverting on\n     * overflow (when the input is greater than largest uint40).\n     *\n     * Counterpart to Solidity's `uint40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint40(uint256 value) internal pure returns (uint40) {\n        require(value <= type(uint40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return uint40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint32 from uint256, reverting on\n     * overflow (when the input is greater than largest uint32).\n     *\n     * Counterpart to Solidity's `uint32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint32(uint256 value) internal pure returns (uint32) {\n        require(value <= type(uint32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return uint32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint24 from uint256, reverting on\n     * overflow (when the input is greater than largest uint24).\n     *\n     * Counterpart to Solidity's `uint24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toUint24(uint256 value) internal pure returns (uint24) {\n        require(value <= type(uint24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return uint24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint16 from uint256, reverting on\n     * overflow (when the input is greater than largest uint16).\n     *\n     * Counterpart to Solidity's `uint16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint16(uint256 value) internal pure returns (uint16) {\n        require(value <= type(uint16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return uint16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted uint8 from uint256, reverting on\n     * overflow (when the input is greater than largest uint8).\n     *\n     * Counterpart to Solidity's `uint8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v2.5._\n     */\n    function toUint8(uint256 value) internal pure returns (uint8) {\n        require(value <= type(uint8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return uint8(value);\n    }\n\n    /**\n     * @dev Converts a signed int256 into an unsigned uint256.\n     *\n     * Requirements:\n     *\n     * - input must be greater than or equal to 0.\n     *\n     * _Available since v3.0._\n     */\n    function toUint256(int256 value) internal pure returns (uint256) {\n        require(value >= 0, \"SafeCast: value must be positive\");\n        return uint256(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int248 from int256, reverting on\n     * overflow (when the input is less than smallest int248 or\n     * greater than largest int248).\n     *\n     * Counterpart to Solidity's `int248` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 248 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt248(int256 value) internal pure returns (int248) {\n        require(value >= type(int248).min && value <= type(int248).max, \"SafeCast: value doesn't fit in 248 bits\");\n        return int248(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int240 from int256, reverting on\n     * overflow (when the input is less than smallest int240 or\n     * greater than largest int240).\n     *\n     * Counterpart to Solidity's `int240` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 240 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt240(int256 value) internal pure returns (int240) {\n        require(value >= type(int240).min && value <= type(int240).max, \"SafeCast: value doesn't fit in 240 bits\");\n        return int240(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int232 from int256, reverting on\n     * overflow (when the input is less than smallest int232 or\n     * greater than largest int232).\n     *\n     * Counterpart to Solidity's `int232` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 232 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt232(int256 value) internal pure returns (int232) {\n        require(value >= type(int232).min && value <= type(int232).max, \"SafeCast: value doesn't fit in 232 bits\");\n        return int232(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int224 from int256, reverting on\n     * overflow (when the input is less than smallest int224 or\n     * greater than largest int224).\n     *\n     * Counterpart to Solidity's `int224` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 224 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt224(int256 value) internal pure returns (int224) {\n        require(value >= type(int224).min && value <= type(int224).max, \"SafeCast: value doesn't fit in 224 bits\");\n        return int224(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int216 from int256, reverting on\n     * overflow (when the input is less than smallest int216 or\n     * greater than largest int216).\n     *\n     * Counterpart to Solidity's `int216` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 216 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt216(int256 value) internal pure returns (int216) {\n        require(value >= type(int216).min && value <= type(int216).max, \"SafeCast: value doesn't fit in 216 bits\");\n        return int216(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int208 from int256, reverting on\n     * overflow (when the input is less than smallest int208 or\n     * greater than largest int208).\n     *\n     * Counterpart to Solidity's `int208` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 208 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt208(int256 value) internal pure returns (int208) {\n        require(value >= type(int208).min && value <= type(int208).max, \"SafeCast: value doesn't fit in 208 bits\");\n        return int208(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int200 from int256, reverting on\n     * overflow (when the input is less than smallest int200 or\n     * greater than largest int200).\n     *\n     * Counterpart to Solidity's `int200` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 200 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt200(int256 value) internal pure returns (int200) {\n        require(value >= type(int200).min && value <= type(int200).max, \"SafeCast: value doesn't fit in 200 bits\");\n        return int200(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int192 from int256, reverting on\n     * overflow (when the input is less than smallest int192 or\n     * greater than largest int192).\n     *\n     * Counterpart to Solidity's `int192` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 192 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt192(int256 value) internal pure returns (int192) {\n        require(value >= type(int192).min && value <= type(int192).max, \"SafeCast: value doesn't fit in 192 bits\");\n        return int192(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int184 from int256, reverting on\n     * overflow (when the input is less than smallest int184 or\n     * greater than largest int184).\n     *\n     * Counterpart to Solidity's `int184` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 184 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt184(int256 value) internal pure returns (int184) {\n        require(value >= type(int184).min && value <= type(int184).max, \"SafeCast: value doesn't fit in 184 bits\");\n        return int184(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int176 from int256, reverting on\n     * overflow (when the input is less than smallest int176 or\n     * greater than largest int176).\n     *\n     * Counterpart to Solidity's `int176` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 176 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt176(int256 value) internal pure returns (int176) {\n        require(value >= type(int176).min && value <= type(int176).max, \"SafeCast: value doesn't fit in 176 bits\");\n        return int176(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int168 from int256, reverting on\n     * overflow (when the input is less than smallest int168 or\n     * greater than largest int168).\n     *\n     * Counterpart to Solidity's `int168` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 168 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt168(int256 value) internal pure returns (int168) {\n        require(value >= type(int168).min && value <= type(int168).max, \"SafeCast: value doesn't fit in 168 bits\");\n        return int168(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int160 from int256, reverting on\n     * overflow (when the input is less than smallest int160 or\n     * greater than largest int160).\n     *\n     * Counterpart to Solidity's `int160` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 160 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt160(int256 value) internal pure returns (int160) {\n        require(value >= type(int160).min && value <= type(int160).max, \"SafeCast: value doesn't fit in 160 bits\");\n        return int160(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int152 from int256, reverting on\n     * overflow (when the input is less than smallest int152 or\n     * greater than largest int152).\n     *\n     * Counterpart to Solidity's `int152` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 152 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt152(int256 value) internal pure returns (int152) {\n        require(value >= type(int152).min && value <= type(int152).max, \"SafeCast: value doesn't fit in 152 bits\");\n        return int152(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int144 from int256, reverting on\n     * overflow (when the input is less than smallest int144 or\n     * greater than largest int144).\n     *\n     * Counterpart to Solidity's `int144` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 144 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt144(int256 value) internal pure returns (int144) {\n        require(value >= type(int144).min && value <= type(int144).max, \"SafeCast: value doesn't fit in 144 bits\");\n        return int144(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int136 from int256, reverting on\n     * overflow (when the input is less than smallest int136 or\n     * greater than largest int136).\n     *\n     * Counterpart to Solidity's `int136` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 136 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt136(int256 value) internal pure returns (int136) {\n        require(value >= type(int136).min && value <= type(int136).max, \"SafeCast: value doesn't fit in 136 bits\");\n        return int136(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int128 from int256, reverting on\n     * overflow (when the input is less than smallest int128 or\n     * greater than largest int128).\n     *\n     * Counterpart to Solidity's `int128` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 128 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt128(int256 value) internal pure returns (int128) {\n        require(value >= type(int128).min && value <= type(int128).max, \"SafeCast: value doesn't fit in 128 bits\");\n        return int128(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int120 from int256, reverting on\n     * overflow (when the input is less than smallest int120 or\n     * greater than largest int120).\n     *\n     * Counterpart to Solidity's `int120` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 120 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt120(int256 value) internal pure returns (int120) {\n        require(value >= type(int120).min && value <= type(int120).max, \"SafeCast: value doesn't fit in 120 bits\");\n        return int120(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int112 from int256, reverting on\n     * overflow (when the input is less than smallest int112 or\n     * greater than largest int112).\n     *\n     * Counterpart to Solidity's `int112` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 112 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt112(int256 value) internal pure returns (int112) {\n        require(value >= type(int112).min && value <= type(int112).max, \"SafeCast: value doesn't fit in 112 bits\");\n        return int112(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int104 from int256, reverting on\n     * overflow (when the input is less than smallest int104 or\n     * greater than largest int104).\n     *\n     * Counterpart to Solidity's `int104` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 104 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt104(int256 value) internal pure returns (int104) {\n        require(value >= type(int104).min && value <= type(int104).max, \"SafeCast: value doesn't fit in 104 bits\");\n        return int104(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int96 from int256, reverting on\n     * overflow (when the input is less than smallest int96 or\n     * greater than largest int96).\n     *\n     * Counterpart to Solidity's `int96` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 96 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt96(int256 value) internal pure returns (int96) {\n        require(value >= type(int96).min && value <= type(int96).max, \"SafeCast: value doesn't fit in 96 bits\");\n        return int96(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int88 from int256, reverting on\n     * overflow (when the input is less than smallest int88 or\n     * greater than largest int88).\n     *\n     * Counterpart to Solidity's `int88` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 88 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt88(int256 value) internal pure returns (int88) {\n        require(value >= type(int88).min && value <= type(int88).max, \"SafeCast: value doesn't fit in 88 bits\");\n        return int88(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int80 from int256, reverting on\n     * overflow (when the input is less than smallest int80 or\n     * greater than largest int80).\n     *\n     * Counterpart to Solidity's `int80` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 80 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt80(int256 value) internal pure returns (int80) {\n        require(value >= type(int80).min && value <= type(int80).max, \"SafeCast: value doesn't fit in 80 bits\");\n        return int80(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int72 from int256, reverting on\n     * overflow (when the input is less than smallest int72 or\n     * greater than largest int72).\n     *\n     * Counterpart to Solidity's `int72` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 72 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt72(int256 value) internal pure returns (int72) {\n        require(value >= type(int72).min && value <= type(int72).max, \"SafeCast: value doesn't fit in 72 bits\");\n        return int72(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int64 from int256, reverting on\n     * overflow (when the input is less than smallest int64 or\n     * greater than largest int64).\n     *\n     * Counterpart to Solidity's `int64` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 64 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt64(int256 value) internal pure returns (int64) {\n        require(value >= type(int64).min && value <= type(int64).max, \"SafeCast: value doesn't fit in 64 bits\");\n        return int64(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int56 from int256, reverting on\n     * overflow (when the input is less than smallest int56 or\n     * greater than largest int56).\n     *\n     * Counterpart to Solidity's `int56` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 56 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt56(int256 value) internal pure returns (int56) {\n        require(value >= type(int56).min && value <= type(int56).max, \"SafeCast: value doesn't fit in 56 bits\");\n        return int56(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int48 from int256, reverting on\n     * overflow (when the input is less than smallest int48 or\n     * greater than largest int48).\n     *\n     * Counterpart to Solidity's `int48` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 48 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt48(int256 value) internal pure returns (int48) {\n        require(value >= type(int48).min && value <= type(int48).max, \"SafeCast: value doesn't fit in 48 bits\");\n        return int48(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int40 from int256, reverting on\n     * overflow (when the input is less than smallest int40 or\n     * greater than largest int40).\n     *\n     * Counterpart to Solidity's `int40` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 40 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt40(int256 value) internal pure returns (int40) {\n        require(value >= type(int40).min && value <= type(int40).max, \"SafeCast: value doesn't fit in 40 bits\");\n        return int40(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int32 from int256, reverting on\n     * overflow (when the input is less than smallest int32 or\n     * greater than largest int32).\n     *\n     * Counterpart to Solidity's `int32` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 32 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt32(int256 value) internal pure returns (int32) {\n        require(value >= type(int32).min && value <= type(int32).max, \"SafeCast: value doesn't fit in 32 bits\");\n        return int32(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int24 from int256, reverting on\n     * overflow (when the input is less than smallest int24 or\n     * greater than largest int24).\n     *\n     * Counterpart to Solidity's `int24` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 24 bits\n     *\n     * _Available since v4.7._\n     */\n    function toInt24(int256 value) internal pure returns (int24) {\n        require(value >= type(int24).min && value <= type(int24).max, \"SafeCast: value doesn't fit in 24 bits\");\n        return int24(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int16 from int256, reverting on\n     * overflow (when the input is less than smallest int16 or\n     * greater than largest int16).\n     *\n     * Counterpart to Solidity's `int16` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 16 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt16(int256 value) internal pure returns (int16) {\n        require(value >= type(int16).min && value <= type(int16).max, \"SafeCast: value doesn't fit in 16 bits\");\n        return int16(value);\n    }\n\n    /**\n     * @dev Returns the downcasted int8 from int256, reverting on\n     * overflow (when the input is less than smallest int8 or\n     * greater than largest int8).\n     *\n     * Counterpart to Solidity's `int8` operator.\n     *\n     * Requirements:\n     *\n     * - input must fit into 8 bits\n     *\n     * _Available since v3.1._\n     */\n    function toInt8(int256 value) internal pure returns (int8) {\n        require(value >= type(int8).min && value <= type(int8).max, \"SafeCast: value doesn't fit in 8 bits\");\n        return int8(value);\n    }\n\n    /**\n     * @dev Converts an unsigned uint256 into a signed int256.\n     *\n     * Requirements:\n     *\n     * - input must be less than or equal to maxInt256.\n     *\n     * _Available since v3.0._\n     */\n    function toInt256(uint256 value) internal pure returns (int256) {\n        // Note: Unsafe cast below is okay because `type(int256).max` is guaranteed to be positive\n        require(value <= uint256(type(int256).max), \"SafeCast: value doesn't fit in an int256\");\n        return int256(value);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/structs/DoubleEndedQueueUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (utils/structs/DoubleEndedQueue.sol)\npragma solidity ^0.8.4;\n\nimport \"../math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev A sequence of items with the ability to efficiently push and pop items (i.e. insert and remove) on both ends of\n * the sequence (called front and back). Among other access patterns, it can be used to implement efficient LIFO and\n * FIFO queues. Storage use is optimized, and all operations are O(1) constant time. This includes {clear}, given that\n * the existing queue contents are left in storage.\n *\n * The struct is called `Bytes32Deque`. Other types can be cast to and from `bytes32`. This data structure can only be\n * used in storage, and not in memory.\n * ```\n * DoubleEndedQueue.Bytes32Deque queue;\n * ```\n *\n * _Available since v4.6._\n */\nlibrary DoubleEndedQueueUpgradeable {\n    /**\n     * @dev An operation (e.g. {front}) couldn't be completed due to the queue being empty.\n     */\n    error Empty();\n\n    /**\n     * @dev An operation (e.g. {at}) couldn't be completed due to an index being out of bounds.\n     */\n    error OutOfBounds();\n\n    /**\n     * @dev Indices are signed integers because the queue can grow in any direction. They are 128 bits so begin and end\n     * are packed in a single storage slot for efficient access. Since the items are added one at a time we can safely\n     * assume that these 128-bit indices will not overflow, and use unchecked arithmetic.\n     *\n     * Struct members have an underscore prefix indicating that they are \"private\" and should not be read or written to\n     * directly. Use the functions provided below instead. Modifying the struct manually may violate assumptions and\n     * lead to unexpected behavior.\n     *\n     * Indices are in the range [begin, end) which means the first item is at data[begin] and the last item is at\n     * data[end - 1].\n     */\n    struct Bytes32Deque {\n        int128 _begin;\n        int128 _end;\n        mapping(int128 => bytes32) _data;\n    }\n\n    /**\n     * @dev Inserts an item at the end of the queue.\n     */\n    function pushBack(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 backIndex = deque._end;\n        deque._data[backIndex] = value;\n        unchecked {\n            deque._end = backIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Removes the item at the end of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popBack(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        value = deque._data[backIndex];\n        delete deque._data[backIndex];\n        deque._end = backIndex;\n    }\n\n    /**\n     * @dev Inserts an item at the beginning of the queue.\n     */\n    function pushFront(Bytes32Deque storage deque, bytes32 value) internal {\n        int128 frontIndex;\n        unchecked {\n            frontIndex = deque._begin - 1;\n        }\n        deque._data[frontIndex] = value;\n        deque._begin = frontIndex;\n    }\n\n    /**\n     * @dev Removes the item at the beginning of the queue and returns it.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function popFront(Bytes32Deque storage deque) internal returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        value = deque._data[frontIndex];\n        delete deque._data[frontIndex];\n        unchecked {\n            deque._begin = frontIndex + 1;\n        }\n    }\n\n    /**\n     * @dev Returns the item at the beginning of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function front(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 frontIndex = deque._begin;\n        return deque._data[frontIndex];\n    }\n\n    /**\n     * @dev Returns the item at the end of the queue.\n     *\n     * Reverts with `Empty` if the queue is empty.\n     */\n    function back(Bytes32Deque storage deque) internal view returns (bytes32 value) {\n        if (empty(deque)) revert Empty();\n        int128 backIndex;\n        unchecked {\n            backIndex = deque._end - 1;\n        }\n        return deque._data[backIndex];\n    }\n\n    /**\n     * @dev Return the item at a position in the queue given by `index`, with the first item at 0 and last item at\n     * `length(deque) - 1`.\n     *\n     * Reverts with `OutOfBounds` if the index is out of bounds.\n     */\n    function at(Bytes32Deque storage deque, uint256 index) internal view returns (bytes32 value) {\n        // int256(deque._begin) is a safe upcast\n        int128 idx = SafeCastUpgradeable.toInt128(int256(deque._begin) + SafeCastUpgradeable.toInt256(index));\n        if (idx >= deque._end) revert OutOfBounds();\n        return deque._data[idx];\n    }\n\n    /**\n     * @dev Resets the queue back to being empty.\n     *\n     * NOTE: The current items are left behind in storage. This does not affect the functioning of the queue, but misses\n     * out on potential gas refunds.\n     */\n    function clear(Bytes32Deque storage deque) internal {\n        deque._begin = 0;\n        deque._end = 0;\n    }\n\n    /**\n     * @dev Returns the number of items in the queue.\n     */\n    function length(Bytes32Deque storage deque) internal view returns (uint256) {\n        // The interface preserves the invariant that begin <= end so we assume this will not overflow.\n        // We also assume there are at most int256.max items in the queue.\n        unchecked {\n            return uint256(int256(deque._end) - int256(deque._begin));\n        }\n    }\n\n    /**\n     * @dev Returns true if the queue is empty.\n     */\n    function empty(Bytes32Deque storage deque) internal view returns (bool) {\n        return deque._end <= deque._begin;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/TimersUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Timers.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Tooling for timepoints, timers and delays\n */\nlibrary TimersUpgradeable {\n    struct Timestamp {\n        uint64 _deadline;\n    }\n\n    function getDeadline(Timestamp memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(Timestamp storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(Timestamp storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(Timestamp memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(Timestamp memory timer) internal view returns (bool) {\n        return timer._deadline > block.timestamp;\n    }\n\n    function isExpired(Timestamp memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.timestamp;\n    }\n\n    struct BlockNumber {\n        uint64 _deadline;\n    }\n\n    function getDeadline(BlockNumber memory timer) internal pure returns (uint64) {\n        return timer._deadline;\n    }\n\n    function setDeadline(BlockNumber storage timer, uint64 timestamp) internal {\n        timer._deadline = timestamp;\n    }\n\n    function reset(BlockNumber storage timer) internal {\n        timer._deadline = 0;\n    }\n\n    function isUnset(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline == 0;\n    }\n\n    function isStarted(BlockNumber memory timer) internal pure returns (bool) {\n        return timer._deadline > 0;\n    }\n\n    function isPending(BlockNumber memory timer) internal view returns (bool) {\n        return timer._deadline > block.number;\n    }\n\n    function isExpired(BlockNumber memory timer) internal view returns (bool) {\n        return isStarted(timer) && timer._deadline <= block.number;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/IGovernorUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (governance/IGovernor.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../utils/introspection/ERC165Upgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Interface of the {Governor} core.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorUpgradeable is Initializable, IERC165Upgradeable {\n    function __IGovernor_init() internal onlyInitializing {\n    }\n\n    function __IGovernor_init_unchained() internal onlyInitializing {\n    }\n    enum ProposalState {\n        Pending,\n        Active,\n        Canceled,\n        Defeated,\n        Succeeded,\n        Queued,\n        Expired,\n        Executed\n    }\n\n    /**\n     * @dev Emitted when a proposal is created.\n     */\n    event ProposalCreated(\n        uint256 proposalId,\n        address proposer,\n        address[] targets,\n        uint256[] values,\n        string[] signatures,\n        bytes[] calldatas,\n        uint256 startBlock,\n        uint256 endBlock,\n        string description\n    );\n\n    /**\n     * @dev Emitted when a proposal is canceled.\n     */\n    event ProposalCanceled(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a proposal is executed.\n     */\n    event ProposalExecuted(uint256 proposalId);\n\n    /**\n     * @dev Emitted when a vote is cast without params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     */\n    event VoteCast(address indexed voter, uint256 proposalId, uint8 support, uint256 weight, string reason);\n\n    /**\n     * @dev Emitted when a vote is cast with params.\n     *\n     * Note: `support` values should be seen as buckets. Their interpretation depends on the voting module used.\n     * `params` are additional encoded parameters. Their intepepretation also depends on the voting module used.\n     */\n    event VoteCastWithParams(\n        address indexed voter,\n        uint256 proposalId,\n        uint8 support,\n        uint256 weight,\n        string reason,\n        bytes params\n    );\n\n    /**\n     * @notice module:core\n     * @dev Name of the governor instance (used in building the ERC712 domain separator).\n     */\n    function name() public view virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Version of the governor instance (used in building the ERC712 domain separator). Default: \"1\"\n     */\n    function version() public view virtual returns (string memory);\n\n    /**\n     * @notice module:voting\n     * @dev A description of the possible `support` values for {castVote} and the way these votes are counted, meant to\n     * be consumed by UIs to show correct vote options and interpret the results. The string is a URL-encoded sequence of\n     * key-value pairs that each describe one aspect, for example `support=bravo&quorum=for,abstain`.\n     *\n     * There are 2 standard keys: `support` and `quorum`.\n     *\n     * - `support=bravo` refers to the vote options 0 = Against, 1 = For, 2 = Abstain, as in `GovernorBravo`.\n     * - `quorum=bravo` means that only For votes are counted towards quorum.\n     * - `quorum=for,abstain` means that both For and Abstain votes are counted towards quorum.\n     *\n     * If a counting module makes use of encoded `params`, it should  include this under a `params` key with a unique\n     * name that describes the behavior. For example:\n     *\n     * - `params=fractional` might refer to a scheme where votes are divided fractionally between for/against/abstain.\n     * - `params=erc721` might refer to a scheme where specific NFTs are delegated to vote.\n     *\n     * NOTE: The string can be decoded by the standard\n     * https://developer.mozilla.org/en-US/docs/Web/API/URLSearchParams[`URLSearchParams`]\n     * JavaScript class.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual returns (string memory);\n\n    /**\n     * @notice module:core\n     * @dev Hashing function used to (re)build the proposal id from the proposal details..\n     */\n    function hashProposal(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public pure virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Current state of a proposal, following Compound's convention\n     */\n    function state(uint256 proposalId) public view virtual returns (ProposalState);\n\n    /**\n     * @notice module:core\n     * @dev Block number used to retrieve user's votes and quorum. As per Compound's Comp and OpenZeppelin's\n     * ERC20Votes, the snapshot is performed at the end of this block. Hence, voting for this proposal starts at the\n     * beginning of the following block.\n     */\n    function proposalSnapshot(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:core\n     * @dev Block number at which votes close. Votes close at the end of this block, so it is possible to cast a vote\n     * during this block.\n     */\n    function proposalDeadline(uint256 proposalId) public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of block, between the proposal is created and the vote starts. This can be increassed to\n     * leave time for users to buy voting power, or delegate it, before the voting of a proposal starts.\n     */\n    function votingDelay() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Delay, in number of blocks, between the vote start and vote ends.\n     *\n     * NOTE: The {votingDelay} can delay the start of the vote. This must be considered when setting the voting\n     * duration compared to the voting delay.\n     */\n    function votingPeriod() public view virtual returns (uint256);\n\n    /**\n     * @notice module:user-config\n     * @dev Minimum number of cast voted required for a proposal to be successful.\n     *\n     * Note: The `blockNumber` parameter corresponds to the snapshot used for counting vote. This allows to scale the\n     * quorum depending on values such as the totalSupply of a token at this block (see {ERC20Votes}).\n     */\n    function quorum(uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber`.\n     *\n     * Note: this can be implemented in a number of ways, for example by reading the delegated balance from one (or\n     * multiple), {ERC20Votes} tokens.\n     */\n    function getVotes(address account, uint256 blockNumber) public view virtual returns (uint256);\n\n    /**\n     * @notice module:reputation\n     * @dev Voting power of an `account` at a specific `blockNumber` given additional encoded parameters.\n     */\n    function getVotesWithParams(\n        address account,\n        uint256 blockNumber,\n        bytes memory params\n    ) public view virtual returns (uint256);\n\n    /**\n     * @notice module:voting\n     * @dev Returns weither `account` has cast a vote on `proposalId`.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual returns (bool);\n\n    /**\n     * @dev Create a new proposal. Vote start {IGovernor-votingDelay} blocks after the proposal is created and ends\n     * {IGovernor-votingPeriod} blocks after the voting starts.\n     *\n     * Emits a {ProposalCreated} event.\n     */\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Execute a successful proposal. This requires the quorum to be reached, the vote to be successful, and the\n     * deadline to be reached.\n     *\n     * Emits a {ProposalExecuted} event.\n     *\n     * Note: some module can modify the requirements for execution, for example by adding an additional timelock.\n     */\n    function execute(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public payable virtual returns (uint256 proposalId);\n\n    /**\n     * @dev Cast a vote\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVote(uint256 proposalId, uint8 support) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteWithReason(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParams(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} event.\n     */\n    function castVoteBySig(\n        uint256 proposalId,\n        uint8 support,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev Cast a vote with a reason and additional encoded parameters using the user's cryptographic signature.\n     *\n     * Emits a {VoteCast} or {VoteCastWithParams} event depending on the length of params.\n     */\n    function castVoteWithReasonAndParamsBySig(\n        uint256 proposalId,\n        uint8 support,\n        string calldata reason,\n        bytes memory params,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual returns (uint256 balance);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorTimelockControl.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./IGovernorTimelockUpgradeable.sol\";\nimport \"../GovernorUpgradeable.sol\";\nimport \"../TimelockControllerUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} that binds the execution process to an instance of {TimelockController}. This adds a\n * delay, enforced by the {TimelockController} to all successful proposal (in addition to the voting duration). The\n * {Governor} needs the proposer (and ideally the executor) roles for the {Governor} to work properly.\n *\n * Using this model means the proposal will be operated by the {TimelockController} and not by the {Governor}. Thus,\n * the assets and permissions must be attached to the {TimelockController}. Any asset sent to the {Governor} will be\n * inaccessible.\n *\n * WARNING: Setting up the TimelockController to have additional proposers besides the governor is very risky, as it\n * grants them powers that they must be trusted or known not to use: 1) {onlyGovernance} functions like {relay} are\n * available to them through the timelock, and 2) approved governance proposals can be blocked by them, effectively\n * executing a Denial of Service attack. This risk will be mitigated in a future release.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorTimelockControlUpgradeable is Initializable, IGovernorTimelockUpgradeable, GovernorUpgradeable {\n    TimelockControllerUpgradeable private _timelock;\n    mapping(uint256 => bytes32) private _timelockIds;\n\n    /**\n     * @dev Emitted when the timelock controller used for proposal execution is modified.\n     */\n    event TimelockChange(address oldTimelock, address newTimelock);\n\n    /**\n     * @dev Set the timelock.\n     */\n    function __GovernorTimelockControl_init(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        __GovernorTimelockControl_init_unchained(timelockAddress);\n    }\n\n    function __GovernorTimelockControl_init_unchained(TimelockControllerUpgradeable timelockAddress) internal onlyInitializing {\n        _updateTimelock(timelockAddress);\n    }\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, GovernorUpgradeable) returns (bool) {\n        return interfaceId == type(IGovernorTimelockUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-state} function with added support for the `Queued` status.\n     */\n    function state(uint256 proposalId) public view virtual override(IGovernorUpgradeable, GovernorUpgradeable) returns (ProposalState) {\n        ProposalState status = super.state(proposalId);\n\n        if (status != ProposalState.Succeeded) {\n            return status;\n        }\n\n        // core tracks execution, so we just have to check if successful proposal have been queued.\n        bytes32 queueid = _timelockIds[proposalId];\n        if (queueid == bytes32(0)) {\n            return status;\n        } else if (_timelock.isOperationDone(queueid)) {\n            return ProposalState.Executed;\n        } else if (_timelock.isOperationPending(queueid)) {\n            return ProposalState.Queued;\n        } else {\n            return ProposalState.Canceled;\n        }\n    }\n\n    /**\n     * @dev Public accessor to check the address of the timelock\n     */\n    function timelock() public view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public accessor to check the eta of a queued proposal\n     */\n    function proposalEta(uint256 proposalId) public view virtual override returns (uint256) {\n        uint256 eta = _timelock.getTimestamp(_timelockIds[proposalId]);\n        return eta == 1 ? 0 : eta; // _DONE_TIMESTAMP (1) should be replaced with a 0 value\n    }\n\n    /**\n     * @dev Function to queue a proposal to the timelock.\n     */\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual override returns (uint256) {\n        uint256 proposalId = hashProposal(targets, values, calldatas, descriptionHash);\n\n        require(state(proposalId) == ProposalState.Succeeded, \"Governor: proposal not successful\");\n\n        uint256 delay = _timelock.getMinDelay();\n        _timelockIds[proposalId] = _timelock.hashOperationBatch(targets, values, calldatas, 0, descriptionHash);\n        _timelock.scheduleBatch(targets, values, calldatas, 0, descriptionHash, delay);\n\n        emit ProposalQueued(proposalId, block.timestamp + delay);\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Overridden execute function that run the already queued proposal through the timelock.\n     */\n    function _execute(\n        uint256, /* proposalId */\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override {\n        _timelock.executeBatch{value: msg.value}(targets, values, calldatas, 0, descriptionHash);\n    }\n\n    /**\n     * @dev Overridden version of the {Governor-_cancel} function to cancel the timelocked proposal if it as already\n     * been queued.\n     */\n    // This function can reenter through the external call to the timelock, but we assume the timelock is trusted and\n    // well behaved (according to TimelockController) and this will not happen.\n    // slither-disable-next-line reentrancy-no-eth\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) internal virtual override returns (uint256) {\n        uint256 proposalId = super._cancel(targets, values, calldatas, descriptionHash);\n\n        if (_timelockIds[proposalId] != 0) {\n            _timelock.cancel(_timelockIds[proposalId]);\n            delete _timelockIds[proposalId];\n        }\n\n        return proposalId;\n    }\n\n    /**\n     * @dev Address through which the governor executes action. In this case, the timelock.\n     */\n    function _executor() internal view virtual override returns (address) {\n        return address(_timelock);\n    }\n\n    /**\n     * @dev Public endpoint to update the underlying timelock instance. Restricted to the timelock itself, so updates\n     * must be proposed, scheduled, and executed through governance proposals.\n     *\n     * CAUTION: It is not recommended to change the timelock while there are other queued governance proposals.\n     */\n    function updateTimelock(TimelockControllerUpgradeable newTimelock) external virtual onlyGovernance {\n        _updateTimelock(newTimelock);\n    }\n\n    function _updateTimelock(TimelockControllerUpgradeable newTimelock) private {\n        emit TimelockChange(address(_timelock), address(newTimelock));\n        _timelock = newTimelock;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/IGovernorTimelockUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/IGovernorTimelock.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../IGovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of the {IGovernor} for timelock supporting modules.\n *\n * _Available since v4.3._\n */\nabstract contract IGovernorTimelockUpgradeable is Initializable, IGovernorUpgradeable {\n    function __IGovernorTimelock_init() internal onlyInitializing {\n    }\n\n    function __IGovernorTimelock_init_unchained() internal onlyInitializing {\n    }\n    event ProposalQueued(uint256 proposalId, uint256 eta);\n\n    function timelock() public view virtual returns (address);\n\n    function proposalEta(uint256 proposalId) public view virtual returns (uint256);\n\n    function queue(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    ) public virtual returns (uint256 proposalId);\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (governance/TimelockController.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../access/AccessControlUpgradeable.sol\";\nimport \"../token/ERC721/IERC721ReceiverUpgradeable.sol\";\nimport \"../token/ERC1155/IERC1155ReceiverUpgradeable.sol\";\nimport \"../utils/AddressUpgradeable.sol\";\nimport \"../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Contract module which acts as a timelocked controller. When set as the\n * owner of an `Ownable` smart contract, it enforces a timelock on all\n * `onlyOwner` maintenance operations. This gives time for users of the\n * controlled contract to exit before a potentially dangerous maintenance\n * operation is applied.\n *\n * By default, this contract is self administered, meaning administration tasks\n * have to go through the timelock process. The proposer (resp executor) role\n * is in charge of proposing (resp executing) operations. A common use case is\n * to position this {TimelockController} as the owner of a smart contract, with\n * a multisig or a DAO as the sole proposer.\n *\n * _Available since v3.3._\n */\ncontract TimelockControllerUpgradeable is Initializable, AccessControlUpgradeable, IERC721ReceiverUpgradeable, IERC1155ReceiverUpgradeable {\n    bytes32 public constant TIMELOCK_ADMIN_ROLE = keccak256(\"TIMELOCK_ADMIN_ROLE\");\n    bytes32 public constant PROPOSER_ROLE = keccak256(\"PROPOSER_ROLE\");\n    bytes32 public constant EXECUTOR_ROLE = keccak256(\"EXECUTOR_ROLE\");\n    bytes32 public constant CANCELLER_ROLE = keccak256(\"CANCELLER_ROLE\");\n    uint256 internal constant _DONE_TIMESTAMP = uint256(1);\n\n    mapping(bytes32 => uint256) private _timestamps;\n    uint256 private _minDelay;\n\n    /**\n     * @dev Emitted when a call is scheduled as part of operation `id`.\n     */\n    event CallScheduled(\n        bytes32 indexed id,\n        uint256 indexed index,\n        address target,\n        uint256 value,\n        bytes data,\n        bytes32 predecessor,\n        uint256 delay\n    );\n\n    /**\n     * @dev Emitted when a call is performed as part of operation `id`.\n     */\n    event CallExecuted(bytes32 indexed id, uint256 indexed index, address target, uint256 value, bytes data);\n\n    /**\n     * @dev Emitted when operation `id` is cancelled.\n     */\n    event Cancelled(bytes32 indexed id);\n\n    /**\n     * @dev Emitted when the minimum delay for future operations is modified.\n     */\n    event MinDelayChange(uint256 oldDuration, uint256 newDuration);\n\n    /**\n     * @dev Initializes the contract with a given `minDelay`, and a list of\n     * initial proposers and executors. The proposers receive both the\n     * proposer and the canceller role (for backward compatibility). The\n     * executors receive the executor role.\n     *\n     * NOTE: At construction, both the deployer and the timelock itself are\n     * administrators. This helps further configuration of the timelock by the\n     * deployer. After configuration is done, it is recommended that the\n     * deployer renounces its admin position and relies on timelocked\n     * operations to perform future maintenance.\n     */\n    function __TimelockController_init(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) internal onlyInitializing {\n        __TimelockController_init_unchained(minDelay, proposers, executors);\n    }\n\n    function __TimelockController_init_unchained(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) internal onlyInitializing {\n        _setRoleAdmin(TIMELOCK_ADMIN_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(PROPOSER_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(EXECUTOR_ROLE, TIMELOCK_ADMIN_ROLE);\n        _setRoleAdmin(CANCELLER_ROLE, TIMELOCK_ADMIN_ROLE);\n\n        // deployer + self administration\n        _setupRole(TIMELOCK_ADMIN_ROLE, _msgSender());\n        _setupRole(TIMELOCK_ADMIN_ROLE, address(this));\n\n        // register proposers and cancellers\n        for (uint256 i = 0; i < proposers.length; ++i) {\n            _setupRole(PROPOSER_ROLE, proposers[i]);\n            _setupRole(CANCELLER_ROLE, proposers[i]);\n        }\n\n        // register executors\n        for (uint256 i = 0; i < executors.length; ++i) {\n            _setupRole(EXECUTOR_ROLE, executors[i]);\n        }\n\n        _minDelay = minDelay;\n        emit MinDelayChange(0, minDelay);\n    }\n\n    /**\n     * @dev Modifier to make a function callable only by a certain role. In\n     * addition to checking the sender's role, `address(0)` 's role is also\n     * considered. Granting a role to `address(0)` is equivalent to enabling\n     * this role for everyone.\n     */\n    modifier onlyRoleOrOpenRole(bytes32 role) {\n        if (!hasRole(role, address(0))) {\n            _checkRole(role, _msgSender());\n        }\n        _;\n    }\n\n    /**\n     * @dev Contract might receive/hold ETH as part of the maintenance process.\n     */\n    receive() external payable {}\n\n    /**\n     * @dev See {IERC165-supportsInterface}.\n     */\n    function supportsInterface(bytes4 interfaceId) public view virtual override(IERC165Upgradeable, AccessControlUpgradeable) returns (bool) {\n        return interfaceId == type(IERC1155ReceiverUpgradeable).interfaceId || super.supportsInterface(interfaceId);\n    }\n\n    /**\n     * @dev Returns whether an id correspond to a registered operation. This\n     * includes both Pending, Ready and Done operations.\n     */\n    function isOperation(bytes32 id) public view virtual returns (bool registered) {\n        return getTimestamp(id) > 0;\n    }\n\n    /**\n     * @dev Returns whether an operation is pending or not.\n     */\n    function isOperationPending(bytes32 id) public view virtual returns (bool pending) {\n        return getTimestamp(id) > _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns whether an operation is ready or not.\n     */\n    function isOperationReady(bytes32 id) public view virtual returns (bool ready) {\n        uint256 timestamp = getTimestamp(id);\n        return timestamp > _DONE_TIMESTAMP && timestamp <= block.timestamp;\n    }\n\n    /**\n     * @dev Returns whether an operation is done or not.\n     */\n    function isOperationDone(bytes32 id) public view virtual returns (bool done) {\n        return getTimestamp(id) == _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Returns the timestamp at with an operation becomes ready (0 for\n     * unset operations, 1 for done operations).\n     */\n    function getTimestamp(bytes32 id) public view virtual returns (uint256 timestamp) {\n        return _timestamps[id];\n    }\n\n    /**\n     * @dev Returns the minimum delay for an operation to become valid.\n     *\n     * This value can be changed by executing an operation that calls `updateDelay`.\n     */\n    function getMinDelay() public view virtual returns (uint256 duration) {\n        return _minDelay;\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a single\n     * transaction.\n     */\n    function hashOperation(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(target, value, data, predecessor, salt));\n    }\n\n    /**\n     * @dev Returns the identifier of an operation containing a batch of\n     * transactions.\n     */\n    function hashOperationBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public pure virtual returns (bytes32 hash) {\n        return keccak256(abi.encode(targets, values, payloads, predecessor, salt));\n    }\n\n    /**\n     * @dev Schedule an operation containing a single transaction.\n     *\n     * Emits a {CallScheduled} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function schedule(\n        address target,\n        uint256 value,\n        bytes calldata data,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        bytes32 id = hashOperation(target, value, data, predecessor, salt);\n        _schedule(id, delay);\n        emit CallScheduled(id, 0, target, value, data, predecessor, delay);\n    }\n\n    /**\n     * @dev Schedule an operation containing a batch of transactions.\n     *\n     * Emits one {CallScheduled} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'proposer' role.\n     */\n    function scheduleBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt,\n        uint256 delay\n    ) public virtual onlyRole(PROPOSER_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n        _schedule(id, delay);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            emit CallScheduled(id, i, targets[i], values[i], payloads[i], predecessor, delay);\n        }\n    }\n\n    /**\n     * @dev Schedule an operation that is to becomes valid after a given delay.\n     */\n    function _schedule(bytes32 id, uint256 delay) private {\n        require(!isOperation(id), \"TimelockController: operation already scheduled\");\n        require(delay >= getMinDelay(), \"TimelockController: insufficient delay\");\n        _timestamps[id] = block.timestamp + delay;\n    }\n\n    /**\n     * @dev Cancel an operation.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'canceller' role.\n     */\n    function cancel(bytes32 id) public virtual onlyRole(CANCELLER_ROLE) {\n        require(isOperationPending(id), \"TimelockController: operation cannot be cancelled\");\n        delete _timestamps[id];\n\n        emit Cancelled(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a single transaction.\n     *\n     * Emits a {CallExecuted} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    // This function can reenter, but it doesn't pose a risk because _afterCall checks that the proposal is pending,\n    // thus any modifications to the operation during reentrancy should be caught.\n    // slither-disable-next-line reentrancy-eth\n    function execute(\n        address target,\n        uint256 value,\n        bytes calldata payload,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        bytes32 id = hashOperation(target, value, payload, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        _execute(target, value, payload);\n        emit CallExecuted(id, 0, target, value, payload);\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an (ready) operation containing a batch of transactions.\n     *\n     * Emits one {CallExecuted} event per transaction in the batch.\n     *\n     * Requirements:\n     *\n     * - the caller must have the 'executor' role.\n     */\n    function executeBatch(\n        address[] calldata targets,\n        uint256[] calldata values,\n        bytes[] calldata payloads,\n        bytes32 predecessor,\n        bytes32 salt\n    ) public payable virtual onlyRoleOrOpenRole(EXECUTOR_ROLE) {\n        require(targets.length == values.length, \"TimelockController: length mismatch\");\n        require(targets.length == payloads.length, \"TimelockController: length mismatch\");\n\n        bytes32 id = hashOperationBatch(targets, values, payloads, predecessor, salt);\n\n        _beforeCall(id, predecessor);\n        for (uint256 i = 0; i < targets.length; ++i) {\n            address target = targets[i];\n            uint256 value = values[i];\n            bytes calldata payload = payloads[i];\n            _execute(target, value, payload);\n            emit CallExecuted(id, i, target, value, payload);\n        }\n        _afterCall(id);\n    }\n\n    /**\n     * @dev Execute an operation's call.\n     */\n    function _execute(\n        address target,\n        uint256 value,\n        bytes calldata data\n    ) internal virtual {\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"TimelockController: underlying transaction reverted\");\n    }\n\n    /**\n     * @dev Checks before execution of an operation's calls.\n     */\n    function _beforeCall(bytes32 id, bytes32 predecessor) private view {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        require(predecessor == bytes32(0) || isOperationDone(predecessor), \"TimelockController: missing dependency\");\n    }\n\n    /**\n     * @dev Checks after execution of an operation's calls.\n     */\n    function _afterCall(bytes32 id) private {\n        require(isOperationReady(id), \"TimelockController: operation is not ready\");\n        _timestamps[id] = _DONE_TIMESTAMP;\n    }\n\n    /**\n     * @dev Changes the minimum timelock duration for future operations.\n     *\n     * Emits a {MinDelayChange} event.\n     *\n     * Requirements:\n     *\n     * - the caller must be the timelock itself. This can only be achieved by scheduling and later executing\n     * an operation where the timelock is the target and the data is the ABI-encoded call to this function.\n     */\n    function updateDelay(uint256 newDelay) external virtual {\n        require(msg.sender == address(this), \"TimelockController: caller must be timelock\");\n        emit MinDelayChange(_minDelay, newDelay);\n        _minDelay = newDelay;\n    }\n\n    /**\n     * @dev See {IERC721Receiver-onERC721Received}.\n     */\n    function onERC721Received(\n        address,\n        address,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC721Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155Received}.\n     */\n    function onERC1155Received(\n        address,\n        address,\n        uint256,\n        uint256,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155Received.selector;\n    }\n\n    /**\n     * @dev See {IERC1155Receiver-onERC1155BatchReceived}.\n     */\n    function onERC1155BatchReceived(\n        address,\n        address,\n        uint256[] memory,\n        uint256[] memory,\n        bytes memory\n    ) public virtual override returns (bytes4) {\n        return this.onERC1155BatchReceived.selector;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "contracts/Arkreen/ArkreenTimeLock.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/governance/TimelockControllerUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract ArkreenTimeLock is\n    Initializable,\n    TimelockControllerUpgradeable,\n    UUPSUpgradeable\n{\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        uint256 minDelay,\n        address[] memory proposers,\n        address[] memory executors\n    ) public initializer {\n        __TimelockController_init(minDelay, proposers, executors);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyRole(TIMELOCK_ADMIN_ROLE)\n    {}\n}\n"
    },
    "contracts/Arkreen/ArkreenReward.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\nimport \"@openzeppelin/contracts-upgradeable/utils/AddressUpgradeable.sol\";\n\nimport \"./ArkreenToken.sol\";\n\ncontract ArkreenReward is \n        ContextUpgradeable,\n        OwnableUpgradeable, \n        PausableUpgradeable,\n        UUPSUpgradeable\n{\n    using AddressUpgradeable for address;\n\n    string  private constant _NAME = 'Arkreen Reward';\n    string  private constant _VERSION = '1';\n    bytes32 private constant _REWARD_TYPEHASH = keccak256(\"Reward(address receiver,uint256 value,uint256 nonce)\");\n    \n    bytes32                     private _DOMAIN_SEPARATOR;\n    address                     public validationAddress;\n    ArkreenToken                public ERC20Contract;\n    mapping(address => uint256) public nonces;\n\n    //events\n    event UserWithdraw(address indexed receiver, uint256 indexed value, uint256  indexed nonce);\n\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(address tokenAKRE, address validationAddr)\n        external\n        virtual\n        initializer\n    {\n        __Ownable_init_unchained();\n        __Context_init_unchained();\n        __Pausable_init_unchained();\n        __UUPSUpgradeable_init();\n\n        ERC20Contract = ArkreenToken(tokenAKRE);\n        validationAddress = validationAddr;\n        \n        // address owner = _msgSender();\n        // assembly {\n        //     sstore(0xb53127684a568b3173ae13b9f8a6016e243e63b6e8ee1178d6a717850b5d6103, owner)\n        // }\n \n        _DOMAIN_SEPARATOR = keccak256(\n            abi.encode(\n                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),\n                keccak256(bytes(_NAME)),\n                keccak256(bytes(_VERSION)),\n                block.chainid,\n                address(this)\n            )\n        );  \n\n    }   \n\n    function pause() external onlyOwner{\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function setERC20ContractAddress(address addr) public onlyOwner {\n        require(addr != address(0), \"zero address is not allowed\");\n        require(addr.isContract(), \"is not a contract address\");\n        ERC20Contract = ArkreenToken(addr);\n    }\n\n    function setValidationAddress(address addr) public onlyOwner {\n        require(addr != address(0), \"zero address is not allowed\");\n        validationAddress = addr;\n    }\n\n    function withdraw(\n        address receiver,\n        uint256 value,\n        uint256 nonce,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual whenNotPaused{\n\n        require(validationAddress != address(0) && address(ERC20Contract) != address(0), \"address error\");\n        require(receiver == _msgSender(), \"only receiver can withdraw token\");\n        require(nonce == nonces[_msgSender()], \"nonce does not macth\");\n\n        bytes32 withdrawHash = keccak256(abi.encode(_REWARD_TYPEHASH, receiver, value, nonce));\n        bytes32 digest = keccak256(abi.encodePacked('\\x19\\x01', _DOMAIN_SEPARATOR, withdrawHash));\n        address recoveredAddress = ecrecover(digest, v, r, s);\n\n        require(recoveredAddress == validationAddress, \"signer doesn't not match or singature error\");\n        nonces[_msgSender()] += 1;\n        ERC20Contract.transfer(receiver, value);\n\n        emit UserWithdraw(receiver, value, nonce);\n    }\n\n\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        virtual\n        override\n        onlyOwner\n    {}\n\n}"
    },
    "contracts/Arkreen/ArkreenToken.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/security/PausableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport \"@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol\";\n\ncontract ArkreenToken is \n    OwnableUpgradeable,\n    PausableUpgradeable,\n    UUPSUpgradeable,\n    ERC20VotesUpgradeable\n{\n    string  private constant _NAME = 'Arkreen Token';\n    string  private constant _SYMBOL = 'AKRE';\n    \n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(uint256 amount, address foundationAddr, string calldata name, string calldata symbol)\n        external\n        virtual\n        initializer\n    {\n        __Ownable_init();\n        __Pausable_init();\n        __UUPSUpgradeable_init();\n        __ERC20Votes_init();\n        \n        if(bytes(name).length == 0 || bytes(symbol).length == 0) {\n          __ERC20_init(_NAME, _SYMBOL);\n          __ERC20Permit_init(_NAME);\n        } else {\n          __ERC20_init(name, symbol);\n          __ERC20Permit_init(name);   \n        }\n\n        _mint(foundationAddr, amount * 10 ** decimals());\n    }\n\n    function pause() external onlyOwner{\n        _pause();\n    }\n\n    function unpause() external onlyOwner {\n        _unpause();\n    }\n\n    function _beforeTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal override whenNotPaused {\n        super._beforeTokenTransfer(from, to, amount);\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal override onlyOwner\n    {}\n}"
    },
    "@openzeppelin/contracts-upgradeable/token/ERC20/extensions/ERC20VotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (token/ERC20/extensions/ERC20Votes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./draft-ERC20PermitUpgradeable.sol\";\nimport \"../../../utils/math/MathUpgradeable.sol\";\nimport \"../../../governance/utils/IVotesUpgradeable.sol\";\nimport \"../../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../../utils/cryptography/ECDSAUpgradeable.sol\";\nimport \"../../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of ERC20 to support Compound-like voting and delegation. This version is more generic than Compound's,\n * and supports token supply up to 2^224^ - 1, while COMP is limited to 2^96^ - 1.\n *\n * NOTE: If exact COMP compatibility is required, use the {ERC20VotesComp} variant of this module.\n *\n * This extension keeps a history (checkpoints) of each account's vote power. Vote power can be delegated either\n * by calling the {delegate} function directly, or by providing a signature to be used with {delegateBySig}. Voting\n * power can be queried through the public accessors {getVotes} and {getPastVotes}.\n *\n * By default, token balance does not account for voting power. This makes transfers cheaper. The downside is that it\n * requires users to delegate to themselves in order to activate checkpoints and have their voting power tracked.\n *\n * _Available since v4.2._\n */\nabstract contract ERC20VotesUpgradeable is Initializable, IVotesUpgradeable, ERC20PermitUpgradeable {\n    function __ERC20Votes_init() internal onlyInitializing {\n    }\n\n    function __ERC20Votes_init_unchained() internal onlyInitializing {\n    }\n    struct Checkpoint {\n        uint32 fromBlock;\n        uint224 votes;\n    }\n\n    bytes32 private constant _DELEGATION_TYPEHASH =\n        keccak256(\"Delegation(address delegatee,uint256 nonce,uint256 expiry)\");\n\n    mapping(address => address) private _delegates;\n    mapping(address => Checkpoint[]) private _checkpoints;\n    Checkpoint[] private _totalSupplyCheckpoints;\n\n    /**\n     * @dev Get the `pos`-th checkpoint for `account`.\n     */\n    function checkpoints(address account, uint32 pos) public view virtual returns (Checkpoint memory) {\n        return _checkpoints[account][pos];\n    }\n\n    /**\n     * @dev Get number of checkpoints for `account`.\n     */\n    function numCheckpoints(address account) public view virtual returns (uint32) {\n        return SafeCastUpgradeable.toUint32(_checkpoints[account].length);\n    }\n\n    /**\n     * @dev Get the address `account` is currently delegating to.\n     */\n    function delegates(address account) public view virtual override returns (address) {\n        return _delegates[account];\n    }\n\n    /**\n     * @dev Gets the current votes balance for `account`\n     */\n    function getVotes(address account) public view virtual override returns (uint256) {\n        uint256 pos = _checkpoints[account].length;\n        return pos == 0 ? 0 : _checkpoints[account][pos - 1].votes;\n    }\n\n    /**\n     * @dev Retrieve the number of votes for `account` at the end of `blockNumber`.\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastVotes(address account, uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_checkpoints[account], blockNumber);\n    }\n\n    /**\n     * @dev Retrieve the `totalSupply` at the end of `blockNumber`. Note, this value is the sum of all balances.\n     * It is but NOT the sum of all the delegated votes!\n     *\n     * Requirements:\n     *\n     * - `blockNumber` must have been already mined\n     */\n    function getPastTotalSupply(uint256 blockNumber) public view virtual override returns (uint256) {\n        require(blockNumber < block.number, \"ERC20Votes: block not yet mined\");\n        return _checkpointsLookup(_totalSupplyCheckpoints, blockNumber);\n    }\n\n    /**\n     * @dev Lookup a value in a list of (sorted) checkpoints.\n     */\n    function _checkpointsLookup(Checkpoint[] storage ckpts, uint256 blockNumber) private view returns (uint256) {\n        // We run a binary search to look for the earliest checkpoint taken after `blockNumber`.\n        //\n        // During the loop, the index of the wanted checkpoint remains in the range [low-1, high).\n        // With each iteration, either `low` or `high` is moved towards the middle of the range to maintain the invariant.\n        // - If the middle checkpoint is after `blockNumber`, we look in [low, mid)\n        // - If the middle checkpoint is before or equal to `blockNumber`, we look in [mid+1, high)\n        // Once we reach a single value (when low == high), we've found the right checkpoint at the index high-1, if not\n        // out of bounds (in which case we're looking too far in the past and the result is 0).\n        // Note that if the latest checkpoint available is exactly for `blockNumber`, we end up with an index that is\n        // past the end of the array, so we technically don't find a checkpoint after `blockNumber`, but it works out\n        // the same.\n        uint256 high = ckpts.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (ckpts[mid].fromBlock > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n\n        return high == 0 ? 0 : ckpts[high - 1].votes;\n    }\n\n    /**\n     * @dev Delegate votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) public virtual override {\n        _delegate(_msgSender(), delegatee);\n    }\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) public virtual override {\n        require(block.timestamp <= expiry, \"ERC20Votes: signature expired\");\n        address signer = ECDSAUpgradeable.recover(\n            _hashTypedDataV4(keccak256(abi.encode(_DELEGATION_TYPEHASH, delegatee, nonce, expiry))),\n            v,\n            r,\n            s\n        );\n        require(nonce == _useNonce(signer), \"ERC20Votes: invalid nonce\");\n        _delegate(signer, delegatee);\n    }\n\n    /**\n     * @dev Maximum token supply. Defaults to `type(uint224).max` (2^224^ - 1).\n     */\n    function _maxSupply() internal view virtual returns (uint224) {\n        return type(uint224).max;\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been increased.\n     */\n    function _mint(address account, uint256 amount) internal virtual override {\n        super._mint(account, amount);\n        require(totalSupply() <= _maxSupply(), \"ERC20Votes: total supply risks overflowing votes\");\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _add, amount);\n    }\n\n    /**\n     * @dev Snapshots the totalSupply after it has been decreased.\n     */\n    function _burn(address account, uint256 amount) internal virtual override {\n        super._burn(account, amount);\n\n        _writeCheckpoint(_totalSupplyCheckpoints, _subtract, amount);\n    }\n\n    /**\n     * @dev Move voting power when tokens are transferred.\n     *\n     * Emits a {DelegateVotesChanged} event.\n     */\n    function _afterTokenTransfer(\n        address from,\n        address to,\n        uint256 amount\n    ) internal virtual override {\n        super._afterTokenTransfer(from, to, amount);\n\n        _moveVotingPower(delegates(from), delegates(to), amount);\n    }\n\n    /**\n     * @dev Change delegation for `delegator` to `delegatee`.\n     *\n     * Emits events {DelegateChanged} and {DelegateVotesChanged}.\n     */\n    function _delegate(address delegator, address delegatee) internal virtual {\n        address currentDelegate = delegates(delegator);\n        uint256 delegatorBalance = balanceOf(delegator);\n        _delegates[delegator] = delegatee;\n\n        emit DelegateChanged(delegator, currentDelegate, delegatee);\n\n        _moveVotingPower(currentDelegate, delegatee, delegatorBalance);\n    }\n\n    function _moveVotingPower(\n        address src,\n        address dst,\n        uint256 amount\n    ) private {\n        if (src != dst && amount > 0) {\n            if (src != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[src], _subtract, amount);\n                emit DelegateVotesChanged(src, oldWeight, newWeight);\n            }\n\n            if (dst != address(0)) {\n                (uint256 oldWeight, uint256 newWeight) = _writeCheckpoint(_checkpoints[dst], _add, amount);\n                emit DelegateVotesChanged(dst, oldWeight, newWeight);\n            }\n        }\n    }\n\n    function _writeCheckpoint(\n        Checkpoint[] storage ckpts,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) private returns (uint256 oldWeight, uint256 newWeight) {\n        uint256 pos = ckpts.length;\n        oldWeight = pos == 0 ? 0 : ckpts[pos - 1].votes;\n        newWeight = op(oldWeight, delta);\n\n        if (pos > 0 && ckpts[pos - 1].fromBlock == block.number) {\n            ckpts[pos - 1].votes = SafeCastUpgradeable.toUint224(newWeight);\n        } else {\n            ckpts.push(Checkpoint({fromBlock: SafeCastUpgradeable.toUint32(block.number), votes: SafeCastUpgradeable.toUint224(newWeight)}));\n        }\n    }\n\n    function _add(uint256 a, uint256 b) private pure returns (uint256) {\n        return a + b;\n    }\n\n    function _subtract(uint256 a, uint256 b) private pure returns (uint256) {\n        return a - b;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/math/MathUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.0) (utils/math/Math.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Standard math utilities missing in the Solidity language.\n */\nlibrary MathUpgradeable {\n    enum Rounding {\n        Down, // Toward negative infinity\n        Up, // Toward infinity\n        Zero // Toward zero\n    }\n\n    /**\n     * @dev Returns the largest of two numbers.\n     */\n    function max(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a >= b ? a : b;\n    }\n\n    /**\n     * @dev Returns the smallest of two numbers.\n     */\n    function min(uint256 a, uint256 b) internal pure returns (uint256) {\n        return a < b ? a : b;\n    }\n\n    /**\n     * @dev Returns the average of two numbers. The result is rounded towards\n     * zero.\n     */\n    function average(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b) / 2 can overflow.\n        return (a & b) + (a ^ b) / 2;\n    }\n\n    /**\n     * @dev Returns the ceiling of the division of two numbers.\n     *\n     * This differs from standard division with `/` in that it rounds up instead\n     * of rounding down.\n     */\n    function ceilDiv(uint256 a, uint256 b) internal pure returns (uint256) {\n        // (a + b - 1) / b can overflow on addition, so we distribute.\n        return a == 0 ? 0 : (a - 1) / b + 1;\n    }\n\n    /**\n     * @notice Calculates floor(x * y / denominator) with full precision. Throws if result overflows a uint256 or denominator == 0\n     * @dev Original credit to Remco Bloemen under MIT license (https://xn--2-umb.com/21/muldiv)\n     * with further edits by Uniswap Labs also under MIT license.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator\n    ) internal pure returns (uint256 result) {\n        unchecked {\n            // 512-bit multiply [prod1 prod0] = x * y. Compute the product mod 2^256 and mod 2^256 - 1, then use\n            // use the Chinese Remainder Theorem to reconstruct the 512 bit result. The result is stored in two 256\n            // variables such that product = prod1 * 2^256 + prod0.\n            uint256 prod0; // Least significant 256 bits of the product\n            uint256 prod1; // Most significant 256 bits of the product\n            assembly {\n                let mm := mulmod(x, y, not(0))\n                prod0 := mul(x, y)\n                prod1 := sub(sub(mm, prod0), lt(mm, prod0))\n            }\n\n            // Handle non-overflow cases, 256 by 256 division.\n            if (prod1 == 0) {\n                return prod0 / denominator;\n            }\n\n            // Make sure the result is less than 2^256. Also prevents denominator == 0.\n            require(denominator > prod1);\n\n            ///////////////////////////////////////////////\n            // 512 by 256 division.\n            ///////////////////////////////////////////////\n\n            // Make division exact by subtracting the remainder from [prod1 prod0].\n            uint256 remainder;\n            assembly {\n                // Compute remainder using mulmod.\n                remainder := mulmod(x, y, denominator)\n\n                // Subtract 256 bit number from 512 bit number.\n                prod1 := sub(prod1, gt(remainder, prod0))\n                prod0 := sub(prod0, remainder)\n            }\n\n            // Factor powers of two out of denominator and compute largest power of two divisor of denominator. Always >= 1.\n            // See https://cs.stackexchange.com/q/138556/92363.\n\n            // Does not overflow because the denominator cannot be zero at this stage in the function.\n            uint256 twos = denominator & (~denominator + 1);\n            assembly {\n                // Divide denominator by twos.\n                denominator := div(denominator, twos)\n\n                // Divide [prod1 prod0] by twos.\n                prod0 := div(prod0, twos)\n\n                // Flip twos such that it is 2^256 / twos. If twos is zero, then it becomes one.\n                twos := add(div(sub(0, twos), twos), 1)\n            }\n\n            // Shift in bits from prod1 into prod0.\n            prod0 |= prod1 * twos;\n\n            // Invert denominator mod 2^256. Now that denominator is an odd number, it has an inverse modulo 2^256 such\n            // that denominator * inv = 1 mod 2^256. Compute the inverse by starting with a seed that is correct for\n            // four bits. That is, denominator * inv = 1 mod 2^4.\n            uint256 inverse = (3 * denominator) ^ 2;\n\n            // Use the Newton-Raphson iteration to improve the precision. Thanks to Hensel's lifting lemma, this also works\n            // in modular arithmetic, doubling the correct bits in each step.\n            inverse *= 2 - denominator * inverse; // inverse mod 2^8\n            inverse *= 2 - denominator * inverse; // inverse mod 2^16\n            inverse *= 2 - denominator * inverse; // inverse mod 2^32\n            inverse *= 2 - denominator * inverse; // inverse mod 2^64\n            inverse *= 2 - denominator * inverse; // inverse mod 2^128\n            inverse *= 2 - denominator * inverse; // inverse mod 2^256\n\n            // Because the division is now exact we can divide by multiplying with the modular inverse of denominator.\n            // This will give us the correct result modulo 2^256. Since the preconditions guarantee that the outcome is\n            // less than 2^256, this is the final result. We don't need to compute the high bits of the result and prod1\n            // is no longer required.\n            result = prod0 * inverse;\n            return result;\n        }\n    }\n\n    /**\n     * @notice Calculates x * y / denominator with full precision, following the selected rounding direction.\n     */\n    function mulDiv(\n        uint256 x,\n        uint256 y,\n        uint256 denominator,\n        Rounding rounding\n    ) internal pure returns (uint256) {\n        uint256 result = mulDiv(x, y, denominator);\n        if (rounding == Rounding.Up && mulmod(x, y, denominator) > 0) {\n            result += 1;\n        }\n        return result;\n    }\n\n    /**\n     * @dev Returns the square root of a number. It the number is not a perfect square, the value is rounded down.\n     *\n     * Inspired by Henry S. Warren, Jr.'s \"Hacker's Delight\" (Chapter 11).\n     */\n    function sqrt(uint256 a) internal pure returns (uint256) {\n        if (a == 0) {\n            return 0;\n        }\n\n        // For our first guess, we get the biggest power of 2 which is smaller than the square root of the target.\n        // We know that the \"msb\" (most significant bit) of our target number `a` is a power of 2 such that we have\n        // `msb(a) <= a < 2*msb(a)`.\n        // We also know that `k`, the position of the most significant bit, is such that `msb(a) = 2**k`.\n        // This gives `2**k < a <= 2**(k+1)` → `2**(k/2) <= sqrt(a) < 2 ** (k/2+1)`.\n        // Using an algorithm similar to the msb conmputation, we are able to compute `result = 2**(k/2)` which is a\n        // good first aproximation of `sqrt(a)` with at least 1 correct bit.\n        uint256 result = 1;\n        uint256 x = a;\n        if (x >> 128 > 0) {\n            x >>= 128;\n            result <<= 64;\n        }\n        if (x >> 64 > 0) {\n            x >>= 64;\n            result <<= 32;\n        }\n        if (x >> 32 > 0) {\n            x >>= 32;\n            result <<= 16;\n        }\n        if (x >> 16 > 0) {\n            x >>= 16;\n            result <<= 8;\n        }\n        if (x >> 8 > 0) {\n            x >>= 8;\n            result <<= 4;\n        }\n        if (x >> 4 > 0) {\n            x >>= 4;\n            result <<= 2;\n        }\n        if (x >> 2 > 0) {\n            result <<= 1;\n        }\n\n        // At this point `result` is an estimation with one bit of precision. We know the true value is a uint128,\n        // since it is the square root of a uint256. Newton's method converges quadratically (precision doubles at\n        // every iteration). We thus need at most 7 iteration to turn our partial result with one bit of precision\n        // into the expected uint128 result.\n        unchecked {\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            result = (result + a / result) >> 1;\n            return min(result, a / result);\n        }\n    }\n\n    /**\n     * @notice Calculates sqrt(a), following the selected rounding direction.\n     */\n    function sqrt(uint256 a, Rounding rounding) internal pure returns (uint256) {\n        uint256 result = sqrt(a);\n        if (rounding == Rounding.Up && result * result < a) {\n            result += 1;\n        }\n        return result;\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/utils/IVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (governance/utils/IVotes.sol)\npragma solidity ^0.8.0;\n\n/**\n * @dev Common interface for {ERC20Votes}, {ERC721Votes}, and other {Votes}-enabled contracts.\n *\n * _Available since v4.5._\n */\ninterface IVotesUpgradeable {\n    /**\n     * @dev Emitted when an account changes their delegate.\n     */\n    event DelegateChanged(address indexed delegator, address indexed fromDelegate, address indexed toDelegate);\n\n    /**\n     * @dev Emitted when a token transfer or delegate change results in changes to a delegate's number of votes.\n     */\n    event DelegateVotesChanged(address indexed delegate, uint256 previousBalance, uint256 newBalance);\n\n    /**\n     * @dev Returns the current amount of votes that `account` has.\n     */\n    function getVotes(address account) external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of votes that `account` had at the end of a past block (`blockNumber`).\n     */\n    function getPastVotes(address account, uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the total supply of votes available at the end of a past block (`blockNumber`).\n     *\n     * NOTE: This value is the sum of all available votes, which is not necessarily the sum of all delegated votes.\n     * Votes that have not been delegated are still part of total supply, even though they would not participate in a\n     * vote.\n     */\n    function getPastTotalSupply(uint256 blockNumber) external view returns (uint256);\n\n    /**\n     * @dev Returns the delegate that `account` has chosen.\n     */\n    function delegates(address account) external view returns (address);\n\n    /**\n     * @dev Delegates votes from the sender to `delegatee`.\n     */\n    function delegate(address delegatee) external;\n\n    /**\n     * @dev Delegates votes from signer to `delegatee`.\n     */\n    function delegateBySig(\n        address delegatee,\n        uint256 nonce,\n        uint256 expiry,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) external;\n}\n"
    },
    "contracts/test/ArkreenTokenTest.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"../Arkreen/ArkreenToken.sol\";\n\n// For testing of contract upgrading \ncontract ArkreenTokenTest is ArkreenToken\n{\n    function burn(address user, uint256 amount) external onlyOwner {\n        super._burn(user, amount);\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/utils/CheckpointsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.5.0) (utils/Checkpoints.sol)\npragma solidity ^0.8.0;\n\nimport \"./math/MathUpgradeable.sol\";\nimport \"./math/SafeCastUpgradeable.sol\";\n\n/**\n * @dev This library defines the `History` struct, for checkpointing values as they change at different points in\n * time, and later looking up past values by block number. See {Votes} as an example.\n *\n * To create a history of checkpoints define a variable type `Checkpoints.History` in your contract, and store a new\n * checkpoint for the current transaction block using the {push} function.\n *\n * _Available since v4.5._\n */\nlibrary CheckpointsUpgradeable {\n    struct Checkpoint {\n        uint32 _blockNumber;\n        uint224 _value;\n    }\n\n    struct History {\n        Checkpoint[] _checkpoints;\n    }\n\n    /**\n     * @dev Returns the value in the latest checkpoint, or zero if there are no checkpoints.\n     */\n    function latest(History storage self) internal view returns (uint256) {\n        uint256 pos = self._checkpoints.length;\n        return pos == 0 ? 0 : self._checkpoints[pos - 1]._value;\n    }\n\n    /**\n     * @dev Returns the value at a given block number. If a checkpoint is not available at that block, the closest one\n     * before it is returned, or zero otherwise.\n     */\n    function getAtBlock(History storage self, uint256 blockNumber) internal view returns (uint256) {\n        require(blockNumber < block.number, \"Checkpoints: block not yet mined\");\n\n        uint256 high = self._checkpoints.length;\n        uint256 low = 0;\n        while (low < high) {\n            uint256 mid = MathUpgradeable.average(low, high);\n            if (self._checkpoints[mid]._blockNumber > blockNumber) {\n                high = mid;\n            } else {\n                low = mid + 1;\n            }\n        }\n        return high == 0 ? 0 : self._checkpoints[high - 1]._value;\n    }\n\n    /**\n     * @dev Pushes a value onto a History so that it is stored as the checkpoint for the current block.\n     *\n     * Returns previous value and new value.\n     */\n    function push(History storage self, uint256 value) internal returns (uint256, uint256) {\n        uint256 pos = self._checkpoints.length;\n        uint256 old = latest(self);\n        if (pos > 0 && self._checkpoints[pos - 1]._blockNumber == block.number) {\n            self._checkpoints[pos - 1]._value = SafeCastUpgradeable.toUint224(value);\n        } else {\n            self._checkpoints.push(\n                Checkpoint({_blockNumber: SafeCastUpgradeable.toUint32(block.number), _value: SafeCastUpgradeable.toUint224(value)})\n            );\n        }\n        return (old, value);\n    }\n\n    /**\n     * @dev Pushes a value onto a History, by updating the latest value using binary operation `op`. The new value will\n     * be set to `op(latest, delta)`.\n     *\n     * Returns previous value and new value.\n     */\n    function push(\n        History storage self,\n        function(uint256, uint256) view returns (uint256) op,\n        uint256 delta\n    ) internal returns (uint256, uint256) {\n        return push(self, op(latest(self), delta));\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.7.2) (governance/extensions/GovernorVotesQuorumFraction.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./GovernorVotesUpgradeable.sol\";\nimport \"../../utils/CheckpointsUpgradeable.sol\";\nimport \"../../utils/math/SafeCastUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token and a quorum expressed as a\n * fraction of the total supply.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorVotesQuorumFractionUpgradeable is Initializable, GovernorVotesUpgradeable {\n    using CheckpointsUpgradeable for CheckpointsUpgradeable.History;\n\n    uint256 private _quorumNumerator; // DEPRECATED\n    CheckpointsUpgradeable.History private _quorumNumeratorHistory;\n\n    event QuorumNumeratorUpdated(uint256 oldQuorumNumerator, uint256 newQuorumNumerator);\n\n    /**\n     * @dev Initialize quorum as a fraction of the token's total supply.\n     *\n     * The fraction is specified as `numerator / denominator`. By default the denominator is 100, so quorum is\n     * specified as a percent: a numerator of 10 corresponds to quorum being 10% of total supply. The denominator can be\n     * customized by overriding {quorumDenominator}.\n     */\n    function __GovernorVotesQuorumFraction_init(uint256 quorumNumeratorValue) internal onlyInitializing {\n        __GovernorVotesQuorumFraction_init_unchained(quorumNumeratorValue);\n    }\n\n    function __GovernorVotesQuorumFraction_init_unchained(uint256 quorumNumeratorValue) internal onlyInitializing {\n        _updateQuorumNumerator(quorumNumeratorValue);\n    }\n\n    /**\n     * @dev Returns the current quorum numerator. See {quorumDenominator}.\n     */\n    function quorumNumerator() public view virtual returns (uint256) {\n        return _quorumNumeratorHistory._checkpoints.length == 0 ? _quorumNumerator : _quorumNumeratorHistory.latest();\n    }\n\n    /**\n     * @dev Returns the quorum numerator at a specific block number. See {quorumDenominator}.\n     */\n    function quorumNumerator(uint256 blockNumber) public view virtual returns (uint256) {\n        // If history is empty, fallback to old storage\n        uint256 length = _quorumNumeratorHistory._checkpoints.length;\n        if (length == 0) {\n            return _quorumNumerator;\n        }\n\n        // Optimistic search, check the latest checkpoint\n        CheckpointsUpgradeable.Checkpoint memory latest = _quorumNumeratorHistory._checkpoints[length - 1];\n        if (latest._blockNumber <= blockNumber) {\n            return latest._value;\n        }\n\n        // Otherwize, do the binary search\n        return _quorumNumeratorHistory.getAtBlock(blockNumber);\n    }\n\n    /**\n     * @dev Returns the quorum denominator. Defaults to 100, but may be overridden.\n     */\n    function quorumDenominator() public view virtual returns (uint256) {\n        return 100;\n    }\n\n    /**\n     * @dev Returns the quorum for a block number, in terms of number of votes: `supply * numerator / denominator`.\n     */\n    function quorum(uint256 blockNumber) public view virtual override returns (uint256) {\n        return (token.getPastTotalSupply(blockNumber) * quorumNumerator(blockNumber)) / quorumDenominator();\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - Must be called through a governance proposal.\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function updateQuorumNumerator(uint256 newQuorumNumerator) external virtual onlyGovernance {\n        _updateQuorumNumerator(newQuorumNumerator);\n    }\n\n    /**\n     * @dev Changes the quorum numerator.\n     *\n     * Emits a {QuorumNumeratorUpdated} event.\n     *\n     * Requirements:\n     *\n     * - New numerator must be smaller or equal to the denominator.\n     */\n    function _updateQuorumNumerator(uint256 newQuorumNumerator) internal virtual {\n        require(\n            newQuorumNumerator <= quorumDenominator(),\n            \"GovernorVotesQuorumFraction: quorumNumerator over quorumDenominator\"\n        );\n\n        uint256 oldQuorumNumerator = quorumNumerator();\n\n        // Make sure we keep track of the original numerator in contracts upgraded from a version without checkpoints.\n        if (oldQuorumNumerator != 0 && _quorumNumeratorHistory._checkpoints.length == 0) {\n            _quorumNumeratorHistory._checkpoints.push(\n                CheckpointsUpgradeable.Checkpoint({_blockNumber: 0, _value: SafeCastUpgradeable.toUint224(oldQuorumNumerator)})\n            );\n        }\n\n        // Set new quorum for future proposals\n        _quorumNumeratorHistory.push(newQuorumNumerator);\n\n        emit QuorumNumeratorUpdated(oldQuorumNumerator, newQuorumNumerator);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[48] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorVotes.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../utils/IVotesUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for voting weight extraction from an {ERC20Votes} token, or since v4.5 an {ERC721Votes} token.\n *\n * _Available since v4.3._\n *\n * @custom:storage-size 51\n */\nabstract contract GovernorVotesUpgradeable is Initializable, GovernorUpgradeable {\n    IVotesUpgradeable public token;\n\n    function __GovernorVotes_init(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        __GovernorVotes_init_unchained(tokenAddress);\n    }\n\n    function __GovernorVotes_init_unchained(IVotesUpgradeable tokenAddress) internal onlyInitializing {\n        token = tokenAddress;\n    }\n\n    /**\n     * Read the voting weight from the token's built in snapshot mechanism (see {Governor-_getVotes}).\n     */\n    function _getVotes(\n        address account,\n        uint256 blockNumber,\n        bytes memory /*params*/\n    ) internal view virtual override returns (uint256) {\n        return token.getPastVotes(account, blockNumber);\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[50] private __gap;\n}\n"
    },
    "contracts/Arkreen/ArkreenGovernor.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/GovernorUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorVotesQuorumFractionUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/governance/extensions/GovernorTimelockControlUpgradeable.sol\";\nimport \"@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol\";\n\ncontract ArkreenGovernor is\n    Initializable,\n    OwnableUpgradeable,\n    GovernorUpgradeable,\n    GovernorSettingsUpgradeable,\n    GovernorCountingSimpleUpgradeable,\n    GovernorVotesUpgradeable,\n    GovernorVotesQuorumFractionUpgradeable,\n    GovernorTimelockControlUpgradeable,\n    UUPSUpgradeable\n{\n    /// @custom:oz-upgrades-unsafe-allow constructor\n    constructor() {\n        _disableInitializers();\n    }\n\n    function initialize(\n        IVotesUpgradeable _token,\n        TimelockControllerUpgradeable _timelock\n    ) public initializer {\n        __Governor_init(\"ArkreenGovernor\");\n        __GovernorSettings_init(\n            1, /* 1 block */\n            50400, /* 1 week */\n            0\n        );\n        __GovernorVotes_init(_token);\n        __GovernorCountingSimple_init();\n        __GovernorVotesQuorumFraction_init(4);\n        __GovernorTimelockControl_init(_timelock);\n        __Ownable_init();\n        __UUPSUpgradeable_init();\n    }\n\n    function _authorizeUpgrade(address newImplementation)\n        internal\n        override\n        onlyOwner\n    {}\n\n    // The following functions are overrides required by Solidity.\n\n    function votingDelay()\n        public\n        view\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingDelay();\n    }\n\n    function votingPeriod()\n        public\n        view\n        override(IGovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.votingPeriod();\n    }\n\n    function quorum(uint256 blockNumber)\n        public\n        view\n        override(IGovernorUpgradeable, GovernorVotesQuorumFractionUpgradeable)\n        returns (uint256)\n    {\n        return super.quorum(blockNumber);\n    }\n\n    function state(uint256 proposalId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (ProposalState)\n    {\n        return super.state(proposalId);\n    }\n\n    function propose(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        string memory description\n    )\n        public\n        override(GovernorUpgradeable, IGovernorUpgradeable)\n        returns (uint256)\n    {\n        return super.propose(targets, values, calldatas, description);\n    }\n\n    function proposalThreshold()\n        public\n        view\n        override(GovernorUpgradeable, GovernorSettingsUpgradeable)\n        returns (uint256)\n    {\n        return super.proposalThreshold();\n    }\n\n    function supportsInterface(bytes4 interfaceId)\n        public\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (bool)\n    {\n        return super.supportsInterface(interfaceId);\n    }\n\n    function _execute(\n        uint256 proposalId,\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n    {\n        super._execute(proposalId, targets, values, calldatas, descriptionHash);\n    }\n\n    function _cancel(\n        address[] memory targets,\n        uint256[] memory values,\n        bytes[] memory calldatas,\n        bytes32 descriptionHash\n    )\n        internal\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (uint256)\n    {\n        return super._cancel(targets, values, calldatas, descriptionHash);\n    }\n\n    function _executor()\n        internal\n        view\n        override(GovernorUpgradeable, GovernorTimelockControlUpgradeable)\n        returns (address)\n    {\n        return super._executor();\n    }\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorSettingsUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (governance/extensions/GovernorSettings.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for settings updatable through governance.\n *\n * _Available since v4.4._\n */\nabstract contract GovernorSettingsUpgradeable is Initializable, GovernorUpgradeable {\n    uint256 private _votingDelay;\n    uint256 private _votingPeriod;\n    uint256 private _proposalThreshold;\n\n    event VotingDelaySet(uint256 oldVotingDelay, uint256 newVotingDelay);\n    event VotingPeriodSet(uint256 oldVotingPeriod, uint256 newVotingPeriod);\n    event ProposalThresholdSet(uint256 oldProposalThreshold, uint256 newProposalThreshold);\n\n    /**\n     * @dev Initialize the governance parameters.\n     */\n    function __GovernorSettings_init(\n        uint256 initialVotingDelay,\n        uint256 initialVotingPeriod,\n        uint256 initialProposalThreshold\n    ) internal onlyInitializing {\n        __GovernorSettings_init_unchained(initialVotingDelay, initialVotingPeriod, initialProposalThreshold);\n    }\n\n    function __GovernorSettings_init_unchained(\n        uint256 initialVotingDelay,\n        uint256 initialVotingPeriod,\n        uint256 initialProposalThreshold\n    ) internal onlyInitializing {\n        _setVotingDelay(initialVotingDelay);\n        _setVotingPeriod(initialVotingPeriod);\n        _setProposalThreshold(initialProposalThreshold);\n    }\n\n    /**\n     * @dev See {IGovernor-votingDelay}.\n     */\n    function votingDelay() public view virtual override returns (uint256) {\n        return _votingDelay;\n    }\n\n    /**\n     * @dev See {IGovernor-votingPeriod}.\n     */\n    function votingPeriod() public view virtual override returns (uint256) {\n        return _votingPeriod;\n    }\n\n    /**\n     * @dev See {Governor-proposalThreshold}.\n     */\n    function proposalThreshold() public view virtual override returns (uint256) {\n        return _proposalThreshold;\n    }\n\n    /**\n     * @dev Update the voting delay. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function setVotingDelay(uint256 newVotingDelay) public virtual onlyGovernance {\n        _setVotingDelay(newVotingDelay);\n    }\n\n    /**\n     * @dev Update the voting period. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function setVotingPeriod(uint256 newVotingPeriod) public virtual onlyGovernance {\n        _setVotingPeriod(newVotingPeriod);\n    }\n\n    /**\n     * @dev Update the proposal threshold. This operation can only be performed through a governance proposal.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function setProposalThreshold(uint256 newProposalThreshold) public virtual onlyGovernance {\n        _setProposalThreshold(newProposalThreshold);\n    }\n\n    /**\n     * @dev Internal setter for the voting delay.\n     *\n     * Emits a {VotingDelaySet} event.\n     */\n    function _setVotingDelay(uint256 newVotingDelay) internal virtual {\n        emit VotingDelaySet(_votingDelay, newVotingDelay);\n        _votingDelay = newVotingDelay;\n    }\n\n    /**\n     * @dev Internal setter for the voting period.\n     *\n     * Emits a {VotingPeriodSet} event.\n     */\n    function _setVotingPeriod(uint256 newVotingPeriod) internal virtual {\n        // voting period must be at least one block long\n        require(newVotingPeriod > 0, \"GovernorSettings: voting period too low\");\n        emit VotingPeriodSet(_votingPeriod, newVotingPeriod);\n        _votingPeriod = newVotingPeriod;\n    }\n\n    /**\n     * @dev Internal setter for the proposal threshold.\n     *\n     * Emits a {ProposalThresholdSet} event.\n     */\n    function _setProposalThreshold(uint256 newProposalThreshold) internal virtual {\n        emit ProposalThresholdSet(_proposalThreshold, newProposalThreshold);\n        _proposalThreshold = newProposalThreshold;\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[47] private __gap;\n}\n"
    },
    "@openzeppelin/contracts-upgradeable/governance/extensions/GovernorCountingSimpleUpgradeable.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v4.6.0) (governance/extensions/GovernorCountingSimple.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../GovernorUpgradeable.sol\";\nimport \"../../proxy/utils/Initializable.sol\";\n\n/**\n * @dev Extension of {Governor} for simple, 3 options, vote counting.\n *\n * _Available since v4.3._\n */\nabstract contract GovernorCountingSimpleUpgradeable is Initializable, GovernorUpgradeable {\n    function __GovernorCountingSimple_init() internal onlyInitializing {\n    }\n\n    function __GovernorCountingSimple_init_unchained() internal onlyInitializing {\n    }\n    /**\n     * @dev Supported vote types. Matches Governor Bravo ordering.\n     */\n    enum VoteType {\n        Against,\n        For,\n        Abstain\n    }\n\n    struct ProposalVote {\n        uint256 againstVotes;\n        uint256 forVotes;\n        uint256 abstainVotes;\n        mapping(address => bool) hasVoted;\n    }\n\n    mapping(uint256 => ProposalVote) private _proposalVotes;\n\n    /**\n     * @dev See {IGovernor-COUNTING_MODE}.\n     */\n    // solhint-disable-next-line func-name-mixedcase\n    function COUNTING_MODE() public pure virtual override returns (string memory) {\n        return \"support=bravo&quorum=for,abstain\";\n    }\n\n    /**\n     * @dev See {IGovernor-hasVoted}.\n     */\n    function hasVoted(uint256 proposalId, address account) public view virtual override returns (bool) {\n        return _proposalVotes[proposalId].hasVoted[account];\n    }\n\n    /**\n     * @dev Accessor to the internal vote counts.\n     */\n    function proposalVotes(uint256 proposalId)\n        public\n        view\n        virtual\n        returns (\n            uint256 againstVotes,\n            uint256 forVotes,\n            uint256 abstainVotes\n        )\n    {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n        return (proposalvote.againstVotes, proposalvote.forVotes, proposalvote.abstainVotes);\n    }\n\n    /**\n     * @dev See {Governor-_quorumReached}.\n     */\n    function _quorumReached(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return quorum(proposalSnapshot(proposalId)) <= proposalvote.forVotes + proposalvote.abstainVotes;\n    }\n\n    /**\n     * @dev See {Governor-_voteSucceeded}. In this module, the forVotes must be strictly over the againstVotes.\n     */\n    function _voteSucceeded(uint256 proposalId) internal view virtual override returns (bool) {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        return proposalvote.forVotes > proposalvote.againstVotes;\n    }\n\n    /**\n     * @dev See {Governor-_countVote}. In this module, the support follows the `VoteType` enum (from Governor Bravo).\n     */\n    function _countVote(\n        uint256 proposalId,\n        address account,\n        uint8 support,\n        uint256 weight,\n        bytes memory // params\n    ) internal virtual override {\n        ProposalVote storage proposalvote = _proposalVotes[proposalId];\n\n        require(!proposalvote.hasVoted[account], \"GovernorVotingSimple: vote already cast\");\n        proposalvote.hasVoted[account] = true;\n\n        if (support == uint8(VoteType.Against)) {\n            proposalvote.againstVotes += weight;\n        } else if (support == uint8(VoteType.For)) {\n            proposalvote.forVotes += weight;\n        } else if (support == uint8(VoteType.Abstain)) {\n            proposalvote.abstainVotes += weight;\n        } else {\n            revert(\"GovernorVotingSimple: invalid value for enum VoteType\");\n        }\n    }\n\n    /**\n     * @dev This empty reserved space is put in place to allow future versions to add new\n     * variables without shifting down storage in the inheritance chain.\n     * See https://docs.openzeppelin.com/contracts/4.x/upgradeable#storage_gaps\n     */\n    uint256[49] private __gap;\n}\n"
    },
    "contracts/Arkreen/ArkreenNotary.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.9;\n\nimport '@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol';\nimport '@openzeppelin/contracts-upgradeable/utils/ContextUpgradeable.sol';\n\ncontract ArkreenNotary is \n    ContextUpgradeable,\n    UUPSUpgradeable,\n    OwnableUpgradeable\n{\n    uint256 public updateCount;\n\n    string  public blockHash;\n    string  public cid;\n    uint256 public blockHeight;\n    uint256 public totalPowerGeneraton;\n    uint256 public circulatingSupply;\n\n    address public dataManager;\n\n    string public arweaveTransactionId;\n    \n    //events\n    event DataSaved2(string indexed blockHash, string indexed cid, uint256 blockHeight, uint256 totalPowerGeneraton, uint256 circulatingSupply, string arweaveTransactionId);\n    \n    //modifier\n    modifier onlyDataManager(){\n        require(_msgSender() == dataManager, \"Only data manager can do this!\");\n        _;\n    }\n\n    //initialize\n    function initialize(address manager_) external virtual initializer {\n        __UUPSUpgradeable_init();\n        __Ownable_init_unchained();\n\n        dataManager = manager_;\n    }\n\n    function saveData(\n        string calldata blockHash_,\n        string calldata cid_,\n        uint256 blockHeight_,\n        uint256 totalPowerGeneraton_,\n        uint256 circulatingSupply_,\n        string calldata arweaveTransactionId_\n    ) public onlyDataManager {\n        require(blockHeight_ >= blockHeight, \"blockHeight data must increase!\");\n        require(totalPowerGeneraton_ >= totalPowerGeneraton, \"totalPowerGeneraton data must increase!\");\n        require(circulatingSupply_ >= circulatingSupply, \"circulatingSupply data must increase!\");\n\n        blockHash          = blockHash_;\n        cid                = cid_;\n        blockHeight        = blockHeight_;\n        totalPowerGeneraton = totalPowerGeneraton_;\n        circulatingSupply  = circulatingSupply_;\n\n        arweaveTransactionId = arweaveTransactionId_;\n\n        updateCount += 1;\n\n        emit DataSaved2(blockHash, cid, blockHeight, totalPowerGeneraton, circulatingSupply, arweaveTransactionId);\n    }\n\n    function setDataManager(address newManager) external onlyOwner {\n        require(newManager != address(0), \"zero address is forbidden !\");\n        require(dataManager != newManager, \"identical address is forbidden !\");\n        \n        dataManager = newManager;\n    }\n\n    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner\n    {}\n}"
    },
    "contracts/interfaces/IArkreenBuilder.sol": {
      "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.9;\r\n\r\ninterface IArkreenBuilder {\r\n\r\n    function artBank() external view returns (address);\r\n\r\n}\r\n"
    }
  },
  "settings": {
    "metadata": {
      "bytecodeHash": "none",
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": true,
      "runs": 500
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates",
          "storageLayout"
        ],
        "": [
          "ast"
        ]
      }
    }
  }
}