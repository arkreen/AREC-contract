// SPDX-License-Identifier: MIT
pragma solidity ^0.8.9;
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/token/ERC20/utils/SafeERC20Upgradeable.sol";
import "@openzeppelin/contracts-upgradeable/utils/cryptography/ECDSAUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/security/ReentrancyGuardUpgradeable.sol";

import "../interfaces/IkWhToken.sol";

contract GreenPower is OwnableUpgradeable, UUPSUpgradeable, ReentrancyGuardUpgradeable {

    // keccak256("offset(uint256 txid,address staker,address cspminer,uint256 amount,uint256 nonce,uint256 deadline)");
    bytes32 public constant  OFFSET_TYPEHASH = 0xF970E4374212202D8F38B4CD5B1067E6B25AE9F3F76C60C2C45771C286C3F19D;  

    // keccak256("stake(uint256 txid,address staker,address cspminer,uint256 amount,uint256 period,uint256 nonce,uint256 deadline)");
    bytes32 public constant  STAKE_TYPEHASH = 0xF970E4374212202D8F38B4CD5B1067E6B25AE9F3F76C60C2C45771C286C3F19D;  

    // keccak256("unstake(uint256 txid,address staker,address cspminer,uint256 amount,uint256 nonce,uint256 deadline)");
    bytes32 public constant UNSTAKE_TYPEHASH = 0xDF27D93C407B51719EF6DE1C85A91844E20B5B3AFADCC7C5BF0828E9F5C6AAC3;  

    struct StakeInfo {
        uint96  amountStake;   							  // Enough for AKRE: 10**28 
        uint32  releaseTime;                  // Timestamp the stake can be released  
        uint32  nonce;
    }  

    struct OffsetInfo {
        address   owner;
        uint16    offsetCounter;
        uint48    totalOffset;
    }  

    struct Sig {
        uint8       v;
        bytes32     r;
        bytes32     s;              
    }

    bytes32 public _DOMAIN_SEPARATOR;
    address public akreToken;
    address public kWhToken;
    address public manager;


    mapping(address => StakeInfo) public stakeInfo;

    // MSB0:20: Owner address; MSB20:4: reserved; MSB24:2: Nonce; MSB28:6: Total Offset (Unit: kWh);  
    mapping(address => OffsetInfo) public minerOffsetInfo;

    uint96 public totalStake;

    modifier ensure(uint256 deadline) {
        require(block.timestamp <= deadline, "Deadline Expired!");
        _;
    }

    event Stake(uint256 indexed txid, address indexed staker, address plugMiner, uint256 amount);
    event Unstake(uint256 indexed txid, address indexed staker, address plugMiner, uint256 amount, uint256 reward, uint256 nonce);

    /// @custom:oz-upgrades-unsafe-allow constructor
    constructor() {
        _disableInitializers();
    }

    function initialize(address akre, address kWh, address _manager) external virtual initializer {
        __Ownable_init_unchained();
        __UUPSUpgradeable_init();     
        __ReentrancyGuard_init();   
        akreToken = akre;
        kWhToken = kWh;
        manager = _manager;

        _DOMAIN_SEPARATOR = keccak256(
            abi.encode(
                keccak256('EIP712Domain(string name,string version,uint256 chainId,address verifyingContract)'),
                keccak256(bytes("Plug Miner ESG")),
                keccak256(bytes("1")),
                block.chainid,
                address(this)
            )
        );  
    }   

    function postUpdate() external onlyProxy onlyOwner 
    {}

    function _authorizeUpgrade(address newImplementation) internal virtual override onlyOwner
    {}

    modifier onlyManager(){
        require(msg.sender == manager, "CLAIM: Not Manager");
        _;
    }

    function changeManager(address newManager) external onlyOwner {
        if (newManager != address(0))  manager = newManager;
    }

    function offsetPower(uint256 txid, address plugMiner, uint256 amount, uint256 nonce, uint256 deadline, Sig calldata signature) external nonReentrant ensure(deadline) {
        require (amount > 0, "Zero Stake"); 

        uint256 offsetInfo = minerOffsetInfo[plugMiner];                                          // also works for the 1st time offseting
        require (nonce == stakeInfo[msg.sender].nonce, "Nonce Not Match"); 

        bytes32 offsetHash = keccak256(abi.encode(OFFSET_TYPEHASH, txid, msg.sender, plugMiner, amount, nonce, deadline));
        bytes32 digest = keccak256(abi.encodePacked('\x19\x01', _DOMAIN_SEPARATOR, offsetHash));
        address managerAddress = ECDSAUpgradeable.recover(digest, signature.v, signature.r, signature.s);

        require(managerAddress == manager, "Wrong Signature");

        if (offsetInfo == 0) offsetInfo = uint256(uint160(msg.sender)) << 96;
        else require ((offsetInfo >> 96) == uint160(msg.sender), "Wrong Owner"); 
        
        offsetInfo += (uint16(nonce) << 48) + uint48(amount);   // Nonce: enough for more than 150 years; amount: 6 Bytes, ~2.8 *(10**14) kWh
        minerOffsetInfo[plugMiner] = offsetInfo;

        //IkWhToken(kWhToken).convertKWh();

        stakeInfo[msg.sender].nonce =  uint64(nonce + 1);
        stakeInfo[msg.sender].amountStake = stakeInfo[msg.sender].amountStake + uint96(amount);   
        totalStake = totalStake + uint96(amount);

        require(IERC20Upgradeable(akreToken).transferFrom(msg.sender, address(this), amount));

        emit Stake(txid, msg.sender, plugMiner, amount);
    }

    function stake(uint256 txid, address plugMiner, uint256 amount, uint256 period, uint256 nonce, uint256 deadline, Sig calldata signature) external nonReentrant ensure(deadline) {
        require (amount > 0, "Zero Stake"); 
        require (msg.sender == minerOffsetInfo[plugMiner].owner, "Not Owner"); 
        require (nonce == stakeInfo[msg.sender].nonce, "Nonce Not Match"); 
        require ((period%30) == 0, "Wrong period");

        require ((block.timestamp + period * 3600 * 24) >= stakeInfo[msg.sender].releaseTime, "Short Period");

        bytes32 stakeHash = keccak256(abi.encode(STAKE_TYPEHASH, txid, msg.sender, plugMiner, amount, period, nonce, deadline));
        bytes32 digest = keccak256(abi.encodePacked('\x19\x01', _DOMAIN_SEPARATOR, stakeHash));
        address managerAddress = ECDSAUpgradeable.recover(digest, signature.v, signature.r, signature.s);
        require(managerAddress == manager, "Wrong Signature");

        stakeInfo[msg.sender].nonce =  uint32(nonce + 1);
        stakeInfo[msg.sender].amountStake = stakeInfo[msg.sender].amountStake + uint96(amount);   // imposssible overflow for AKRE
        stakeInfo[msg.sender].releaseTime = uint32(block.timestamp + period * 3600 * 24);
        totalStake = totalStake + uint96(amount);

        emit Stake(txid, msg.sender, plugMiner, amount, period, nonce);

        require(IERC20Upgradeable(akreToken).transferFrom(msg.sender, address(this), amount));
    }

    function unstake(uint256 txid, address plugMiner, uint256 amount, uint256 nonce, uint256 deadline, Sig calldata signature) external nonReentrant ensure(deadline){
        require (amount > 0, "Zero Stake"); 
        require (msg.sender == minerOffsetInfo[plugMiner].owner, "Not Owner"); 
        require (nonce == stakeInfo[msg.sender].nonce, "Nonce Not Match"); 
        require(stakeInfo[msg.sender].amountStake >= uint96(amount), "Unstake Overflowed");
        require (block.timestamp >= stakeInfo[msg.sender].releaseTime, "Not Released");

        bytes32 unstakeHash = keccak256(abi.encode(UNSTAKE_TYPEHASH, txid, msg.sender, plugMiner, amount, nonce, deadline));
        bytes32 digest = keccak256(abi.encodePacked('\x19\x01', _DOMAIN_SEPARATOR, unstakeHash));
        address managerAddress = ECDSAUpgradeable.recover(digest, signature.v, signature.r, signature.s);
        require(managerAddress == manager, "Wrong Signature");

        stakeInfo[msg.sender].nonce =  stakeInfo[msg.sender].nonce + 1;
        
        uint256 amountStakeNew = stakeInfo[msg.sender].amountStake - uint96(amount);
        if (amountStakeNew == 0) stakeInfo[msg.sender].releaseTime = 0;
        stakeInfo[msg.sender].amountStake = amountStakeNew;

        totalStake = totalStake - uint96(amount);

        require(IERC20Upgradeable(akreToken).transfer(msg.sender, amount));
        emit Unstake(txid, msg.sender, plugMiner, amount, nonce);
    }
}